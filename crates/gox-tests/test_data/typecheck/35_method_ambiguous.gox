// Test ambiguous method - same method name from two embedded types
package main

type A struct{}

func (a A) Foo() int {
    return 1
}

type B struct{}

func (b B) Foo() int {
    return 2
}

type C struct {
    A
    B
}

func main() {
    c := C{}
    
    // Ambiguous: both A.Foo and B.Foo at same depth
    _ = c.Foo()
    
    // Explicit access is OK
    _ = c.A.Foo()
    _ = c.B.Foo()
}

=== typecheck ===
E2510

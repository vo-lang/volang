// Test: bitwise operators
package main

func main() {
    a := 10  // 0b1010
    b := 12  // 0b1100
    
    // AND: 0b1010 & 0b1100 = 0b1000 = 8
    and := a & b
    assert(and == 8, "10 & 12 should be 8")
    
    // OR: 0b1010 | 0b1100 = 0b1110 = 14
    or := a | b
    assert(or == 14, "10 | 12 should be 14")
    
    // XOR: 0b1010 ^ 0b1100 = 0b0110 = 6
    xor := a ^ b
    assert(xor == 6, "10 ^ 12 should be 6")
    
    // Left shift: 10 << 1 = 20
    shl := a << 1
    assert(shl == 20, "10 << 1 should be 20")
    
    // Right shift: 10 >> 1 = 5
    shr := a >> 1
    assert(shr == 5, "10 >> 1 should be 5")
}

=== codegen ===
module main

const 0 string "10 & 12 should be 8"
const 1 string "10 | 12 should be 14"
const 2 string "10 ^ 12 should be 6"
const 3 string "10 << 1 should be 20"
const 4 string "10 >> 1 should be 5"

func main
  locals 20
  0: LoadInt r1, 10
  1: Mov r0, r1
  2: LoadInt r3, 12
  3: Mov r2, r3
  4: Band r5, r0, r2
  5: Mov r4, r5
  6: LoadInt r6, 8
  7: EqI64 r7, r4, r6
  8: LoadConst r8, $0
  9: AssertBegin r7, 1, 175
  10: AssertArg r8, 14
  11: AssertEnd
  12: LoadNil r9
  13: Bor r7, r0, r2
  14: Mov r6, r7
  15: LoadInt r8, 14
  16: EqI64 r9, r6, r8
  17: LoadConst r10, $1
  18: AssertBegin r9, 1, 281
  19: AssertArg r10, 14
  20: AssertEnd
  21: LoadNil r11
  22: Bxor r9, r0, r2
  23: Mov r8, r9
  24: LoadInt r10, 6
  25: EqI64 r11, r8, r10
  26: LoadConst r12, $2
  27: AssertBegin r11, 1, 389
  28: AssertArg r12, 14
  29: AssertEnd
  30: LoadNil r13
  31: LoadInt r11, 1
  32: Shl r12, r0, r11
  33: Mov r10, r12
  34: LoadInt r13, 20
  35: EqI64 r14, r10, r13
  36: LoadConst r15, $3
  37: AssertBegin r14, 1, 488
  38: AssertArg r15, 14
  39: AssertEnd
  40: LoadNil r16
  41: LoadInt r14, 1
  42: Shr r15, r0, r14
  43: Mov r13, r15
  44: LoadInt r16, 5
  45: EqI64 r17, r13, r16
  46: LoadConst r18, $4
  47: AssertBegin r17, 1, 589
  48: AssertArg r18, 14
  49: AssertEnd
  50: LoadNil r19
  51: Return r0, 0
end

func $init
  locals 0
  0: Return r0, 0
end

func $entry
  locals 0
  0: Call 1, r0, 0, 0
  1: Call 0, r0, 0, 0
  2: Return r0, 0
end

entry $entry

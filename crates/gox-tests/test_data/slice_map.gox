package main

// Comprehensive slice, map, and nested type tests

type Point struct {
    x int
    y int
}

type Container struct {
    id     int
    points []int
    scores map[string]int
}

type ObjNode object {
    value int
    name  string
}

type Complex struct {
    title   string
    numbers []int
    lookup  map[int]int
    point   Point
}

func main() {
    // Test 1: Int slice with access and modification
    s1 := []int{10, 20, 30, 40, 50}
    assert(len(s1) == 5, "slice len should be 5")
    assert(s1[0] == 10, "s1[0] should be 10")
    assert(s1[4] == 50, "s1[4] should be 50")
    s1[2] = 999
    assert(s1[2] == 999, "s1[2] after modification should be 999")
    
    // Test 2: Slice append chain
    s2 := []int{1}
    s2 = append(s2, 2)
    s2 = append(s2, 3)
    s2 = append(s2, 4)
    s2 = append(s2, 5)
    assert(len(s2) == 5, "appended slice len should be 5")
    assert(s2[4] == 5, "s2[4] should be 5")
    
    // Test 3: String-int map
    m1 := map[string]int{"apple": 1, "banana": 2, "cherry": 3, "date": 4}
    assert(len(m1) == 4, "map len should be 4")
    assert(m1["apple"] == 1, "m1[apple] should be 1")
    assert(m1["cherry"] == 3, "m1[cherry] should be 3")
    m1["elderberry"] = 5
    assert(m1["elderberry"] == 5, "m1[elderberry] should be 5")
    
    // Test 4: Int-int map
    m2 := map[int]int{100: 1, 200: 2, 300: 3}
    assert(m2[100] == 1, "m2[100] should be 1")
    assert(m2[200] == 2, "m2[200] should be 2")
    m2[400] = 4
    assert(m2[400] == 4, "m2[400] should be 4")
    
    // Test 5: Struct with slice and map fields
    c1 := Container{42, []int{1, 2, 3, 4}, map[string]int{"a": 10, "b": 20}}
    assert(c1.id == 42, "c1.id should be 42")
    assert(len(c1.points) == 4, "c1.points len should be 4")
    assert(c1.points[0] == 1, "c1.points[0] should be 1")
    
    // Test 6: Map field access
    scores := c1.scores
    assert(len(scores) == 2, "scores len should be 2")
    assert(scores["a"] == 10, "scores[a] should be 10")
    assert(scores["b"] == 20, "scores[b] should be 20")
    
    // Test 7: Map field index assignment
    c1.scores["c"] = 30
    assert(c1.scores["c"] == 30, "c1.scores[c] should be 30")
    
    // Test 8: Nested struct field access
    cplx := Complex{"test", []int{1, 2}, map[int]int{1: 100}, Point{10, 20}}
    assert(cplx.point.x == 10, "cplx.point.x should be 10")
    assert(cplx.point.y == 20, "cplx.point.y should be 20")
    
    // Test 9: Object reference sharing
    obj1 := ObjNode{100, "node1"}
    obj2 := obj1
    obj2.value = 999
    assert(obj1.value == 999, "object reference: obj1.value should be 999")
    assert(obj2.value == 999, "object reference: obj2.value should be 999")
    
    // Test 10: Sum slice elements
    data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    sum := 0
    for i := 0; i < len(data); i++ {
        sum = sum + data[i]
    }
    assert(sum == 55, "sum of 1..10 should be 55, got ", sum)
    
    // Test 11: Find max in slice
    vals := []int{3, 1, 4, 1, 5, 9, 2, 6}
    max := vals[0]
    for i := 1; i < len(vals); i++ {
        if vals[i] > max {
            max = vals[i]
        }
    }
    assert(max == 9, "max should be 9, got ", max)
    
    // Test 12: Using struct as map key
    pm := map[Point]int{}
    p1 := Point{1, 2}
    p2 := Point{3, 4}
    p3 := Point{1, 2}  // Same as p1
    pm[p1] = 100
    pm[p2] = 200
    assert(pm[p1] == 100, "pm[p1] should be 100")
    assert(pm[p2] == 200, "pm[p2] should be 200")
    assert(pm[p3] == 100, "pm[p3] should be 100 (same key as p1)")
    
    println("slice_map_test: ALL PASSED")
}

// Test: Comprehensive example with multiple declarations and statements
package main

import "fmt"
import "math"

const (
    MaxSize = 100
    MinSize = 1
)

var globalCounter int

type Point struct {
    x int
    y int
}

type Counter struct {
    value int
}

interface Shape {
    Area() float64
    Perimeter() float64
}

func (c Counter) Inc() {
    c.value++
}

func (c Counter) Get() int {
    return c.value
}

func add(a, b int) int {
    return a + b
}

func swap(a, b int) (int, int) {
    return b, a
}

func sum(nums ...int) int {
    total := 0
    for i := 0; i < len(nums); i++ {
        total += nums[i]
    }
    return total
}

func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a := 0
    b := 1
    for i := 2; i <= n; i++ {
        c := a + b
        a = b
        b = c
    }
    return b
}

func classify(x int) string {
    switch {
    case x < 0:
        return "negative"
    case x == 0:
        return "zero"
    case x > 0:
        return "positive"
    default:
        return "unknown"
    }
}

func process(ch chan int) {
    for {
        v := <-ch
        if v < 0 {
            return
        }
    }
}

func main() {
    x := 1
    y := 2
    z := add(x, y)
    
    p := Point{x: 10, y: 20}
    
    arr := [5]int{1, 2, 3, 4, 5}
    slice := []int{1, 2, 3}
    m := map[string]int{"a": 1, "b": 2}
    
    for i := 0; i < 10; i++ {
        if i%2 == 0 {
            continue
        }
        z += i
    }
    
    go process(ch)
    defer cleanup()
    
    return
}

func cleanup() {
}

=== parser ===
File {
  package: "main",
  imports: [
    "fmt",
    "math",
  ],
  decls: [
    Const {
      specs: [
        ConstSpec {
          names: ["MaxSize"],
          values: [
            100,
          ],
        },
        ConstSpec {
          names: ["MinSize"],
          values: [
            1,
          ],
        },
      ],
    },
    Var {
      specs: [
        VarSpec {
          names: ["globalCounter"],
          type: int,
        },
      ],
    },
    Type { name: "Point", type: struct { x int; y int; } },
    Type { name: "Counter", type: struct { value int; } },
    Interface {
      name: "Shape",
      methods: [
        Area,
        Perimeter,
      ],
    },
    Func {
      receiver: (c Counter),
      name: "Inc",
      body: {
        IncDec { expr: c.value, inc: true },
      },
    },
    Func {
      receiver: (c Counter),
      name: "Get",
      results: [int],
      body: {
        Return [c.value],
      },
    },
    Func {
      name: "add",
      params: [
        (a, b int),
      ],
      results: [int],
      body: {
        Return [(a Add b)],
      },
    },
    Func {
      name: "swap",
      params: [
        (a, b int),
      ],
      results: [int, int],
      body: {
        Return [b, a],
      },
    },
    Func {
      name: "sum",
      params: [
        (nums int),
      ],
      results: [int],
      variadic: true,
      body: {
        ShortVar { names: ["total"], values: [0] },
        For {
          init:
            ShortVar { names: ["i"], values: [0] },
          cond: (i Lt len(nums)),
          post:
            IncDec { expr: i, inc: true },
          body: {
            Assign { lhs: [total], op: Add, rhs: [nums[i]] },
          },
        },
        Empty,
        Return [total],
      },
    },
    Func {
      name: "factorial",
      params: [
        (n int),
      ],
      results: [int],
      body: {
        If {
          cond: (n LtEq 1),
          then: {
            Return [1],
          },
        },
        Empty,
        Return [(n Mul factorial((n Sub 1)))],
      },
    },
    Func {
      name: "fibonacci",
      params: [
        (n int),
      ],
      results: [int],
      body: {
        If {
          cond: (n LtEq 1),
          then: {
            Return [n],
          },
        },
        Empty,
        ShortVar { names: ["a"], values: [0] },
        ShortVar { names: ["b"], values: [1] },
        For {
          init:
            ShortVar { names: ["i"], values: [2] },
          cond: (i LtEq n),
          post:
            IncDec { expr: i, inc: true },
          body: {
            ShortVar { names: ["c"], values: [(a Add b)] },
            Assign { lhs: [a], op: Assign, rhs: [b] },
            Assign { lhs: [b], op: Assign, rhs: [c] },
          },
        },
        Empty,
        Return [b],
      },
    },
    Func {
      name: "classify",
      params: [
        (x int),
      ],
      results: [string],
      body: {
        Switch {
          cases: [
            case [(x Lt 0)]: {
              Return ["negative"],
            },
            case [(x Eq 0)]: {
              Return ["zero"],
            },
            case [(x Gt 0)]: {
              Return ["positive"],
            },
            case []: {
              Return ["unknown"],
            },
          ],
        },
        Empty,
      },
    },
    Func {
      name: "process",
      params: [
        (ch chan int),
      ],
      body: {
        For {
          body: {
            ShortVar { names: ["v"], values: [<-ch] },
            If {
              cond: (v Lt 0),
              then: {
                Return [],
              },
            },
            Empty,
          },
        },
        Empty,
      },
    },
    Func {
      name: "main",
      body: {
        ShortVar { names: ["x"], values: [1] },
        ShortVar { names: ["y"], values: [2] },
        ShortVar { names: ["z"], values: [add(x, y)] },
        ShortVar { names: ["p"], values: [Point{x: 10, y: 20}] },
        ShortVar { names: ["arr"], values: [[5]int{1, 2, 3, 4, 5}] },
        ShortVar { names: ["slice"], values: [[]int{1, 2, 3}] },
        ShortVar { names: ["m"], values: [map[string]int{"a": 1, "b": 2}] },
        For {
          init:
            ShortVar { names: ["i"], values: [0] },
          cond: (i Lt 10),
          post:
            IncDec { expr: i, inc: true },
          body: {
            If {
              cond: ((i Rem 2) Eq 0),
              then: {
                Continue,
              },
            },
            Empty,
            Assign { lhs: [z], op: Add, rhs: [i] },
          },
        },
        Empty,
        Go(process(ch)),
        Defer(cleanup()),
        Return [],
      },
    },
    Func {
      name: "cleanup",
      body: {
      },
    },
  ],
}

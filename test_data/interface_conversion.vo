// Test: interface type conversions
package main

type E interface{}

type I1 interface {
    m1()
}

type I2 interface {
    m1()
    m2(x int)
}

type I3 interface {
    m1()
    m2() int
}

// Type that implements I1
type T1 struct{}

func (t T1) m1() {}

// Type that implements I2
type T2 struct{}

func (t T2) m1() {}
func (t T2) m2(x int) {}

// Type that implements I3
type T3 struct{}

func (t T3) m1() {}
func (t T3) m2() int { return 0 }

func main() {
    var e E
    var i1 I1
    var i2 I2
    var i3 I3
    
    // Initialize with concrete types
    i1 = T1{}
    i2 = T2{}
    i3 = T3{}
    
    // === Test 1: Conversion to empty interface (always OK) ===
    _ = E(0)
    _ = E(nil)
    _ = E(e)
    _ = E(i1)
    _ = E(i2)
    _ = E(i3)
    println("Test 1 PASSED: conversion to empty interface")
    
    // === Test 2: I1(nil) should work ===
    _ = I1(nil)
    println("Test 2 PASSED: I1(nil)")
    
    // === Test 3: I1(i1) should work ===
    _ = I1(i1)
    println("Test 3 PASSED: I1(i1)")
    
    // === Test 4: I1(i2) should work (I2 has m1()) ===
    _ = I1(i2)
    println("Test 4 PASSED: I1(i2) - I2 implements I1")
    
    // === Test 5: I2(nil) should work ===
    _ = I2(nil)
    println("Test 5 PASSED: I2(nil)")
    
    // === Test 6: I2(i2) should work ===
    _ = I2(i2)
    println("Test 6 PASSED: I2(i2)")
    
    // === Test 7: I3(nil) should work ===
    _ = I3(nil)
    println("Test 7 PASSED: I3(nil)")
    
    // === Test 8: I3(i3) should work ===
    _ = I3(i3)
    println("Test 8 PASSED: I3(i3)")
    
    println("interface_conversion: ALL PASSED")
}


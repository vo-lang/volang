package main

type Counter struct {
	value int
}

func (c *Counter) Inc() {
	c.value++
}

func (c *Counter) Get() int {
	return c.value
}

type Container struct {
	counter Counter
	name    string
}

func main() {
	c := Container{
		counter: Counter{value: 10},
		name:    "test",
	}
	
	// Dynamic access to get counter field
	var box interface{} = c
	
	// Type assert to Counter
	counter, ok :=  box~>counter?.(Counter)
	assert(ok, "type assert to Counter failed")
	
	// Call method on extracted Counter
	assert(counter.Get() == 10, "expected 10")
	println("Get() before Inc:", counter.Get())
	
	// Inc modifies local copy (value semantics)
	counter.Inc()
	assert(counter.Get() == 11, "after Inc expected 11")
	println("Get() after Inc:", counter.Get())
	
	// Original should be unchanged (value semantics)
	counterAny2, _ := box~>counter
	counter2, _ := counterAny2.(Counter)
	assert(counter2.Get() == 10, "original should be 10")
	println("original unchanged:", counter2.Get())
	
	println("done")
}

// expected output:
// Get() before Inc: 10
// Get() after Inc: 11
// original unchanged: 10
// done

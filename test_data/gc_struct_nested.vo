// Test GC with nested struct containing GcRefs
// Struct fields may be GcRefs

package main

type Node struct {
	Value int
	Left  *Node
	Right *Node
}

func newNode(v int) *Node {
	return &Node{Value: v}
}

func insert(n *Node, v int) *Node {
	if n == nil {
		return newNode(v)
	}
	if v < n.Value {
		n.Left = insert(n.Left, v)
	} else {
		n.Right = insert(n.Right, v)
	}
	return n
}

func sum(n *Node) int {
	if n == nil {
		return 0
	}
	return n.Value + sum(n.Left) + sum(n.Right)
}

func count(n *Node) int {
	if n == nil {
		return 0
	}
	return 1 + count(n.Left) + count(n.Right)
}

type Person struct {
	Name    string
	Friends []*Person
	Data    map[string]string
}

func main() {
	// Test 1: Binary tree with pointers
	var root *Node
	values := []int{50, 25, 75, 12, 37, 62, 87}
	for _, v := range values {
		root = insert(root, v)
	}
	assert(count(root) == 7)
	assert(sum(root) == 348)

	// Test 2: Struct with slice of pointers
	alice := &Person{Name: "Alice", Friends: []*Person{}, Data: make(map[string]string)}
	bob := &Person{Name: "Bob", Friends: []*Person{}, Data: make(map[string]string)}
	charlie := &Person{Name: "Charlie", Friends: []*Person{}, Data: make(map[string]string)}
	
	alice.Friends = append(alice.Friends, bob, charlie)
	bob.Friends = append(bob.Friends, alice)
	charlie.Friends = append(charlie.Friends, alice, bob)
	
	alice.Data["role"] = "admin"
	bob.Data["role"] = "user"
	
	assert(alice.Name == "Alice")
	assert(len(alice.Friends) == 2)
	assert(alice.Friends[0].Name == "Bob")
	assert(charlie.Friends[1].Data["role"] == "user")

	println("gc_struct_nested: PASSED")
}

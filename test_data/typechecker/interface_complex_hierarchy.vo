package main

// Test: Complex interface hierarchies and combinations
// Focus: Multiple embedding, diamond patterns, method shadowing

// ============================================
// Part 1: Deep Interface Embedding
// ============================================

type Readable interface {
    Read() string
}

type Writable interface {
    Write(s string)
}

type Closable interface {
    Close() bool
}

type ReadWritable interface {
    Readable
    Writable
}

type ReadClosable interface {
    Readable
    Closable
}

type WriteClosable interface {
    Writable
    Closable
}

type ReadWriteClosable interface {
    Readable
    Writable
    Closable
}

type File struct {
    content string
    closed  bool
}

func (f *File) Read() string {
    return f.content
}

func (f *File) Write(s string) {
    f.content = f.content + s
}

func (f *File) Close() bool {
    f.closed = true
    return true
}

func testDeepEmbedding() {
    f := &File{content: "initial", closed: false}
    
    var r Readable = f
    assert(r.Read() == "initial", "testDeepEmbedding: Read should work")
    
    var w Writable = f
    w.Write("-appended")
    assert(f.content == "initial-appended", "testDeepEmbedding: Write should work")
    
    var c Closable = f
    c.Close()
    assert(f.closed == true, "testDeepEmbedding: Close should work")
    
    f2 := &File{content: "", closed: false}
    var rw ReadWritable = f2
    rw.Write("hello")
    assert(rw.Read() == "hello", "testDeepEmbedding: ReadWritable should work")
    
    f3 := &File{content: "data", closed: false}
    var rwc ReadWriteClosable = f3
    rwc.Write("-more")
    s := rwc.Read()
    assert(s == "data-more", "testDeepEmbedding: ReadWriteClosable Read")
    rwc.Close()
    assert(f3.closed == true, "testDeepEmbedding: ReadWriteClosable Close")
}

// ============================================
// Part 2: Diamond Pattern (Same Method from Multiple Paths)
// ============================================

type Named interface {
    Name() string
}

type Described interface {
    Named
    Description() string
}

type Identified interface {
    Named
    ID() int
}

type FullInfo interface {
    Described
    Identified
}

type Entity struct {
    name        string
    description string
    id          int
}

func (e Entity) Name() string        { return e.name }
func (e Entity) Description() string { return e.description }
func (e Entity) ID() int             { return e.id }

func testDiamondPattern() {
    e := Entity{name: "TestEntity", description: "A test entity", id: 42}
    
    var n Named = e
    assert(n.Name() == "TestEntity", "testDiamondPattern: Named.Name()")
    
    var d Described = e
    assert(d.Name() == "TestEntity", "testDiamondPattern: Described.Name()")
    assert(d.Description() == "A test entity", "testDiamondPattern: Described.Description()")
    
    var i Identified = e
    assert(i.Name() == "TestEntity", "testDiamondPattern: Identified.Name()")
    assert(i.ID() == 42, "testDiamondPattern: Identified.ID()")
    
    var f FullInfo = e
    assert(f.Name() == "TestEntity", "testDiamondPattern: FullInfo.Name()")
    assert(f.Description() == "A test entity", "testDiamondPattern: FullInfo.Description()")
    assert(f.ID() == 42, "testDiamondPattern: FullInfo.ID()")
}

// ============================================
// Part 3: Multiple Implementors with Interface Composition
// ============================================

type Validator interface {
    Validate() bool
}

type Serializable interface {
    Serialize() string
}

type ValidatedSerializable interface {
    Validator
    Serializable
}

type SimpleData struct {
    value int
}

func (sd SimpleData) Validate() bool {
    return sd.value >= 0
}

func (sd SimpleData) Serialize() string {
    if sd.value < 0 {
        return "negative"
    }
    return "positive"
}

type ComplexData struct {
    values []int
    name   string
}

func (cd ComplexData) Validate() bool {
    for _, v := range cd.values {
        if v < 0 {
            return false
        }
    }
    return len(cd.name) > 0
}

func (cd ComplexData) Serialize() string {
    return cd.name
}

func testMultipleImplementors() {
    var vs ValidatedSerializable
    
    sd := SimpleData{value: 10}
    vs = sd
    assert(vs.Validate() == true, "testMultipleImplementors: SimpleData valid")
    assert(vs.Serialize() == "positive", "testMultipleImplementors: SimpleData serialize")
    
    sd2 := SimpleData{value: -5}
    vs = sd2
    assert(vs.Validate() == false, "testMultipleImplementors: SimpleData invalid")
    
    cd := ComplexData{values: []int{1, 2, 3}, name: "test"}
    vs = cd
    assert(vs.Validate() == true, "testMultipleImplementors: ComplexData valid")
    assert(vs.Serialize() == "test", "testMultipleImplementors: ComplexData serialize")
    
    cd2 := ComplexData{values: []int{1, -2, 3}, name: "test"}
    vs = cd2
    assert(vs.Validate() == false, "testMultipleImplementors: ComplexData invalid")
}

// ============================================
// Part 4: Interface with Interface Parameter/Return
// ============================================

type Wrapper interface {
    Wrap(inner Readable) Readable
    Unwrap() Readable
}

type BufferedWrapper struct {
    inner  Readable
    prefix string
}

func (bw *BufferedWrapper) Wrap(inner Readable) Readable {
    bw.inner = inner
    return bw
}

func (bw *BufferedWrapper) Unwrap() Readable {
    return bw.inner
}

func (bw *BufferedWrapper) Read() string {
    if bw.inner == nil {
        return bw.prefix
    }
    return bw.prefix + bw.inner.Read()
}

func testInterfaceInInterface() {
    inner := &File{content: "content", closed: false}
    wrapper := &BufferedWrapper{prefix: "[prefix]"}
    
    var w Wrapper = wrapper
    result := w.Wrap(inner)
    
    assert(result.Read() == "[prefix]content", "testInterfaceInInterface: wrapped read")
    
    unwrapped := w.Unwrap()
    assert(unwrapped.Read() == "content", "testInterfaceInInterface: unwrapped read")
}

// ============================================
// Part 5: Struct Embedding with Interface Field
// ============================================

type Logger interface {
    Log(msg string)
}

type ConsoleLogger struct {
    lastMsg string
}

func (cl *ConsoleLogger) Log(msg string) {
    cl.lastMsg = msg
}

type ServiceWithLogger struct {
    Logger
    name string
}

func (s *ServiceWithLogger) DoWork() {
    s.Log("Working on " + s.name)
}

func testStructWithInterfaceField() {
    logger := &ConsoleLogger{}
    svc := &ServiceWithLogger{Logger: logger, name: "task1"}
    
    svc.DoWork()
    assert(logger.lastMsg == "Working on task1", "testStructWithInterfaceField: log message")
    
    // Can also call Log directly through embedding
    svc.Log("direct call")
    assert(logger.lastMsg == "direct call", "testStructWithInterfaceField: direct log")
}

// ============================================
// Part 6: Chained Interface Assignment
// ============================================

type Level1Iface interface {
    Method1() int
}

type Level2Iface interface {
    Level1Iface
    Method2() int
}

type Level3Iface interface {
    Level2Iface
    Method3() int
}

type ThreeLevelImpl struct {
    val int
}

func (t ThreeLevelImpl) Method1() int { return t.val }
func (t ThreeLevelImpl) Method2() int { return t.val * 2 }
func (t ThreeLevelImpl) Method3() int { return t.val * 3 }

func testChainedAssignment() {
    impl := ThreeLevelImpl{val: 10}
    
    var l3 Level3Iface = impl
    assert(l3.Method1() == 10, "testChainedAssignment: l3.Method1()")
    assert(l3.Method2() == 20, "testChainedAssignment: l3.Method2()")
    assert(l3.Method3() == 30, "testChainedAssignment: l3.Method3()")
    
    // Assign to parent interface
    var l2 Level2Iface = l3
    assert(l2.Method1() == 10, "testChainedAssignment: l2.Method1()")
    assert(l2.Method2() == 20, "testChainedAssignment: l2.Method2()")
    
    var l1 Level1Iface = l2
    assert(l1.Method1() == 10, "testChainedAssignment: l1.Method1()")
}

// ============================================
// Part 7: Empty Interface as Universal Container
// ============================================

type Container interface {
    Store(key string, value interface{})
    Load(key string) (interface{}, bool)
    Keys() []string
}

type MapContainer struct {
    data map[string]interface{}
}

func (mc *MapContainer) Store(key string, value interface{}) {
    if mc.data == nil {
        mc.data = make(map[string]interface{})
    }
    mc.data[key] = value
}

func (mc *MapContainer) Load(key string) (interface{}, bool) {
    v, ok := mc.data[key]
    return v, ok
}

func (mc *MapContainer) Keys() []string {
    result := make([]string, 0, len(mc.data))
    for k := range mc.data {
        result = append(result, k)
    }
    return result
}

func testEmptyInterfaceContainer() {
    var c Container = &MapContainer{}
    
    c.Store("int", 42)
    c.Store("string", "hello")
    c.Store("slice", []int{1, 2, 3})
    
    v1, ok1 := c.Load("int")
    assert(ok1 == true, "testEmptyInterfaceContainer: int exists")
    _ = v1
    
    v2, ok2 := c.Load("string")
    assert(ok2 == true, "testEmptyInterfaceContainer: string exists")
    _ = v2
    
    _, ok3 := c.Load("missing")
    assert(ok3 == false, "testEmptyInterfaceContainer: missing not found")
    
    keys := c.Keys()
    assert(len(keys) == 3, "testEmptyInterfaceContainer: should have 3 keys")
}

// ============================================
// Part 8: Interface Slice Operations
// ============================================

type Stringer interface {
    String() string
}

type IntWrapper struct{ v int }
type StrWrapper struct{ v string }
type BoolWrapper struct{ v bool }

func (iw IntWrapper) String() string {
    if iw.v == 0 {
        return "0"
    }
    return "int"
}

func (sw StrWrapper) String() string  { return sw.v }
func (bw BoolWrapper) String() string {
    if bw.v {
        return "true"
    }
    return "false"
}

type StringerProcessor interface {
    JoinAll(items []Stringer, sep string) string
    FindFirst(items []Stringer, predicate func(Stringer) bool) (Stringer, bool)
}

type StrProc struct{}

func (sp StrProc) JoinAll(items []Stringer, sep string) string {
    result := ""
    for i, item := range items {
        if i > 0 {
            result = result + sep
        }
        result = result + item.String()
    }
    return result
}

func (sp StrProc) FindFirst(items []Stringer, predicate func(Stringer) bool) (Stringer, bool) {
    for _, item := range items {
        if predicate(item) {
            return item, true
        }
    }
    return nil, false
}

func testInterfaceSlice() {
    var sp StringerProcessor = StrProc{}
    
    items := []Stringer{
        IntWrapper{v: 42},
        StrWrapper{v: "hello"},
        BoolWrapper{v: true},
    }
    
    joined := sp.JoinAll(items, ", ")
    assert(joined == "int, hello, true", "testInterfaceSlice: JoinAll")
    
    found, ok := sp.FindFirst(items, func(s Stringer) bool {
        return s.String() == "hello"
    })
    assert(ok == true, "testInterfaceSlice: FindFirst found")
    assert(found.String() == "hello", "testInterfaceSlice: FindFirst value")
    
    _, ok2 := sp.FindFirst(items, func(s Stringer) bool {
        return s.String() == "missing"
    })
    assert(ok2 == false, "testInterfaceSlice: FindFirst not found")
}

// ============================================
// Part 9: Method with Receiver Type Variations
// ============================================

type Configurable interface {
    GetConfig() map[string]string
    SetConfig(key, value string)
}

type Config1 struct {
    data map[string]string
}

// Pointer receiver for both
func (c *Config1) GetConfig() map[string]string {
    if c.data == nil {
        return make(map[string]string)
    }
    return c.data
}

func (c *Config1) SetConfig(key, value string) {
    if c.data == nil {
        c.data = make(map[string]string)
    }
    c.data[key] = value
}

type Config2 struct {
    data map[string]string
}

// Value receiver for Get, Pointer for Set
func (c Config2) GetConfig() map[string]string {
    if c.data == nil {
        return make(map[string]string)
    }
    return c.data
}

func (c *Config2) SetConfig(key, value string) {
    if c.data == nil {
        c.data = make(map[string]string)
    }
    c.data[key] = value
}

func testReceiverVariations() {
    // Config1: *Config1 implements Configurable
    var c1 Configurable = &Config1{}
    c1.SetConfig("key1", "value1")
    cfg := c1.GetConfig()
    assert(cfg["key1"] == "value1", "testReceiverVariations: Config1 set/get")
    
    // Config2: *Config2 implements Configurable
    var c2 Configurable = &Config2{}
    c2.SetConfig("key2", "value2")
    cfg2 := c2.GetConfig()
    assert(cfg2["key2"] == "value2", "testReceiverVariations: Config2 set/get")
}

// ============================================
// Part 10: Deeply Nested Generics-like Pattern
// ============================================

type Mapper interface {
    Map(f func(interface{}) interface{}) Mapper
    Value() interface{}
}

type Option struct {
    hasValue bool
    value    interface{}
}

func Some(v interface{}) *Option {
    return &Option{hasValue: true, value: v}
}

func None() *Option {
    return &Option{hasValue: false, value: nil}
}

func (o *Option) Map(f func(interface{}) interface{}) Mapper {
    if !o.hasValue {
        return None()
    }
    return Some(f(o.value))
}

func (o *Option) Value() interface{} {
    return o.value
}

func testMapperPattern() {
    var m Mapper = Some(10)
    
    m2 := m.Map(func(v interface{}) interface{} {
        return v.(int) * 2
    })
    assert(m2.Value().(int) == 20, "testMapperPattern: first map")
    
    m3 := m2.Map(func(v interface{}) interface{} {
        return v.(int) + 5
    })
    assert(m3.Value().(int) == 25, "testMapperPattern: second map")
    
    var empty Mapper = None()
    m4 := empty.Map(func(v interface{}) interface{} {
        return v.(int) * 100
    })
    assert(m4.Value() == nil, "testMapperPattern: None map returns None")
}

func main() {
    testDeepEmbedding()
    testDiamondPattern()
    testMultipleImplementors()
    testInterfaceInInterface()
    testStructWithInterfaceField()
    testChainedAssignment()
    testEmptyInterfaceContainer()
    testInterfaceSlice()
    testReceiverVariations()
    testMapperPattern()
    
    println("interface_complex_hierarchy: ALL PASSED")
}

// Test dynamic attribute access: obj~>field
package main

type Person struct {
	Name string
	Age  int
}

type Nested struct {
	Inner *Person
	Value int
}

func main() {
	// Dynamic field access
	p := &Person{Name: "Alice", Age: 30}
	var obj interface{} = p
	
	v1, err := obj~>Name
	if err != nil {
		println("Error Name:", err)
		return
	}
	if v1.(string) != "Alice" {
		println("FAIL: Name expected Alice, got", v1.(string))
		return
	}
	println("Name =", v1.(string))
	
	v2, err := obj~>Age
	if err != nil {
		println("Error Age:", err)
		return
	}
	if v2.(int) != 30 {
		println("FAIL: Age expected 30, got", v2.(int))
		return
	}
	println("Age =", v2.(int))
	
	// Non-existing field
	_, err = obj~>NonExistent
	if err == nil {
		println("FAIL: NonExistent should return error")
		return
	}
	println("NonExistent error:", err)
	
	// Nested struct
	n := &Nested{Inner: &Person{Name: "Bob", Age: 25}, Value: 100}
	var nobj interface{} = n
	
	v3, err := nobj~>Value
	if err != nil {
		println("Error Value:", err)
		return
	}
	if v3.(int) != 100 {
		println("FAIL: Value expected 100, got", v3.(int))
		return
	}
	println("Value =", v3.(int))
	
	v4, err := nobj~>Inner
	if err != nil {
		println("Error Inner:", err)
		return
	}
	inner := v4.(*Person)
	if inner.Name != "Bob" {
		println("FAIL: Inner.Name expected Bob, got", inner.Name)
		return
	}
	println("Inner.Name =", inner.Name)
	
	println("All dyn_get_attr tests passed!")
}

// Test LHS type-driven conversion for dynamic calls
package main

type Calc struct {
	val int
}

type Pair struct {
	A int
	B int
}

func (c *Calc) GetInt() int {
	return c.val
}

func (c *Calc) GetString() string {
	return "hello"
}

func (c *Calc) GetPair() (int, string) {
	return c.val, "world"
}

func (c *Calc) GetStruct() Pair {
	return Pair{A: c.val, B: 7}
}

func (c *Calc) GetStructAndInt() (Pair, int) {
	return Pair{A: c.val, B: 7}, c.val
}

func (c *Calc) GetStructPtr() *Pair {
	p := &Pair{A: c.val, B: 7}
	return p
}

func (c *Calc) GetPtrAndInt() (*Pair, int) {
	p := &Pair{A: c.val, B: 7}
	return p, c.val
}

func main() {
	c := &Calc{val: 42}
	var obj interface{} = c

	// Test 1: LHS is any (short var decl) - should box
	r1, err := obj~>GetInt()
	assert(err == nil, "GetInt should succeed")
	// r1 is any, need type assertion
	assert(r1.(int) == 42, "expected 42")
	println("Test 1 (any): GetInt() =", r1.(int))

	// Test 2: LHS has concrete type - should NOT box
	var result int
	result, err = obj~>GetInt()
	assert(err == nil, "GetInt should succeed")
	// result is int directly, no type assertion needed
	assert(result == 42, "expected 42")
	println("Test 2 (int): GetInt() =", result)

	// Test 3: Multi-return with any
	r1, r2, err := obj~>GetPair()
	assert(err == nil, "GetPair should succeed")
	assert(r1.(int) == 42 && r2.(string) == "world", "GetPair mismatch")
	println("Test 3 (any,any): GetPair() =", r1.(int), r2.(string))

	// Test 4: Multi-return with concrete types
	var n int
	var s string
	n, s, err = obj~>GetPair()
	assert(err == nil, "GetPair should succeed")
	assert(n == 42 && s == "world", "GetPair mismatch")
	println("Test 4 (int,string): GetPair() =", n, s)

	// Test 4.1: Struct return with any
	pAny, err := obj~>GetStruct()
	assert(err == nil, "GetStruct should succeed")
	assert(pAny.(Pair).A == 42 && pAny.(Pair).B == 7, "GetStruct mismatch")
	println("Test 4.1 (any): GetStruct() =", pAny.(Pair).A, pAny.(Pair).B)

	// Test 4.2: Struct return with concrete type
	var p Pair
	p, err = obj~>GetStruct()
	assert(err == nil, "GetStruct should succeed")
	assert(p.A == 42 && p.B == 7, "GetStruct mismatch")
	println("Test 4.2 (Pair): GetStruct() =", p.A, p.B)

	// Test 4.3: Multi-return with struct first (validates return layout/offset)
	p2, i2, err := obj~>GetStructAndInt()
	assert(err == nil, "GetStructAndInt should succeed")
	assert(p2.(Pair).A == 42 && p2.(Pair).B == 7 && i2.(int) == 42, "GetStructAndInt mismatch")
	println("Test 4.3 (any,any): GetStructAndInt() =", p2.(Pair).A, p2.(Pair).B, i2.(int))

	// Test 4.4: Multi-return with struct first (concrete types)
	var p3 Pair
	var i3 int
	p3, i3, err = obj~>GetStructAndInt()
	assert(err == nil, "GetStructAndInt should succeed")
	assert(p3.A == 42 && p3.B == 7 && i3 == 42, "GetStructAndInt mismatch")
	println("Test 4.4 (Pair,int): GetStructAndInt() =", p3.A, p3.B, i3)

	// Test 4.5: Struct pointer return with any
	ppAny, err := obj~>GetStructPtr()
	assert(err == nil, "GetStructPtr should succeed")
	assert(ppAny.(*Pair).A == 42 && ppAny.(*Pair).B == 7, "GetStructPtr mismatch")
	println("Test 4.5 (any): GetStructPtr() =", ppAny.(*Pair).A, ppAny.(*Pair).B)

	// Test 4.6: Struct pointer return with concrete type
	var pp *Pair
	pp, err = obj~>GetStructPtr()
	assert(err == nil, "GetStructPtr should succeed")
	assert(pp.A == 42 && pp.B == 7, "GetStructPtr mismatch")
	println("Test 4.6 (*Pair): GetStructPtr() =", pp.A, pp.B)

	// Test 4.7: Multi-return with pointer first (validates return layout/offset width=1)
	pp2, i4, err := obj~>GetPtrAndInt()
	assert(err == nil, "GetPtrAndInt should succeed")
	assert(pp2.(*Pair).A == 42 && pp2.(*Pair).B == 7 && i4.(int) == 42, "GetPtrAndInt mismatch")
	println("Test 4.7 (any,any): GetPtrAndInt() =", pp2.(*Pair).A, pp2.(*Pair).B, i4.(int))

	// Test 4.8: Multi-return with pointer first (concrete types)
	var pp3 *Pair
	var i5 int
	pp3, i5, err = obj~>GetPtrAndInt()
	assert(err == nil, "GetPtrAndInt should succeed")
	assert(pp3.A == 42 && pp3.B == 7 && i5 == 42, "GetPtrAndInt mismatch")
	println("Test 4.8 (*Pair,int): GetPtrAndInt() =", pp3.A, pp3.B, i5)

	// ============================================================
	// Field access tests
	// ============================================================
	println("=== Testing field access LHS types ===")

	type Data struct {
		Count int
		Name  string
	}
	var data interface{} = &Data{Count: 100, Name: "test"}
	var dataVal interface{} = Data{Count: 101, Name: "test2"}

	// Test 5: Field access with any LHS
	f1, err := data~>Count
	assert(err == nil, "field Count should succeed")
	assert(f1.(int) == 100, "expected 100")
	println("Test 5 (any): data~>Count =", f1.(int))

	// Test 6: Field access with concrete type LHS
	var count int
	count, err = data~>Count
	assert(err == nil, "field Count should succeed")
	assert(count == 100, "expected 100")
	println("Test 6 (int): data~>Count =", count)

	// Test 6.1: Field access on struct value (non-pointer)
	f1v, err := dataVal~>Count
	assert(err == nil, "field Count on value should succeed")
	assert(f1v.(int) == 101, "expected 101")
	println("Test 6.1 (any): dataVal~>Count =", f1v.(int))

	// ============================================================
	// Map index tests
	// ============================================================
	println("=== Testing map index LHS types ===")

	var m interface{} = map[string]int{"a": 1, "b": 2}

	// Test 7: Map index with any LHS
	v1, err := m~>["a"]
	assert(err == nil, "map[a] should succeed")
	assert(v1.(int) == 1, "expected 1")
	println("Test 7 (any): m~>[a] =", v1.(int))

	// Test 8: Map index with concrete type LHS
	var val int
	val, err = m~>["b"]
	assert(err == nil, "map[b] should succeed")
	assert(val == 2, "expected 2")
	println("Test 8 (int): m~>[b] =", val)

	// ============================================================
	// Slice index tests
	// ============================================================
	println("=== Testing slice index LHS types ===")

	var sl interface{} = []int{10, 20, 30}

	// Test 9: Slice index with any LHS
	s1, err := sl~>[1]
	assert(err == nil, "slice[1] should succeed")
	assert(s1.(int) == 20, "expected 20")
	println("Test 9 (any): sl~>[1] =", s1.(int))

	// Test 10: Slice index with concrete type LHS
	var elem int
	elem, err = sl~>[2]
	assert(err == nil, "slice[2] should succeed")
	assert(elem == 30, "expected 30")
	println("Test 10 (int): sl~>[2] =", elem)

	println("=== All LHS type tests passed! ===")
}

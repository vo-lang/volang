// Test: Error Handling Sugar - comprehensive coverage
// Covers: ? operator, fail statement, errdefer
package main

// Error type implementation
type MyError struct {
    msg string
}

func (e MyError) Error() string {
    return e.msg
}

func (e MyError) Code() int {
    return 0
}

func (e MyError) Unwrap() error {
    return nil
}

func (e MyError) Data() any {
    return nil
}

func newError(msg string) error {
    return MyError{msg: msg}
}

// Global counters
var counter int

func resetCounter() {
    counter = 0
}

func incCounter(n int) {
    counter += n
}

// ============ Helper functions ============

func getInt(succeed bool) (int, error) {
    if !succeed {
        return 0, newError("getInt failed")
    }
    return 42, nil
}

func getString(succeed bool) (string, error) {
    if !succeed {
        return "", newError("getString failed")
    }
    return "hello", nil
}

func getMultiple(succeed bool) (int, string, error) {
    if !succeed {
        return 0, "", newError("getMultiple failed")
    }
    return 100, "world", nil
}

func justError(succeed bool) error {
    if !succeed {
        return newError("justError failed")
    }
    return nil
}

func add(a int, b int) int {
    return a + b
}

func process(val int) (int, error) {
    if val < 0 {
        return 0, newError("negative value")
    }
    return val * 2, nil
}

// ============ Test 1: ? as function argument ============
func useValue(v int) int {
    return v + 1000
}

func testQuestionAsArg(succeed bool) (int, error) {
    result := useValue(getInt(succeed)?)
    return result, nil
}

// ============ Test 2: ? in complex expression ============
func testQuestionInExpression(succeed bool) (int, error) {
    result := (getInt(succeed)? + 10) * 2
    return result, nil
}

// ============ Test 3: Chained ? with different types ============
func testChainedDifferentTypes(s1 bool, s2 bool) (string, error) {
    val := getInt(s1)?
    str := getString(s2)?
    return str + ":" + string(rune('0' + val%10)), nil
}

// ============ Test 4: ? in for loop body ============
func testQuestionInLoop(count int, failAt int) (int, error) {
    sum := 0
    for i := 0; i < count; i += 1 {
        succeed := i != failAt
        val := getInt(succeed)?
        sum += val
    }
    return sum, nil
}

// ============ Test 5: ? with immediate use (no assignment) ============
func testQuestionNoAssign(succeed bool) error {
    justError(succeed)?
    return nil
}

// ============ Test 6: Multiple ? on same line (chained calls) ============
func testMultipleQuestionOneLine(s1 bool, s2 bool) (int, error) {
    result := process(getInt(s1)?)?
    if !s2 {
        fail newError("explicit fail")
    }
    return result, nil
}

// ============ Test 7: ? with errdefer - precise interaction ============
func testQuestionWithErrdefer(failPoint int) (int, error) {
    errdefer incCounter(1)
    
    if failPoint == 1 {
        fail newError("fail at point 1")
    }
    
    errdefer incCounter(10)
    
    val := getInt(failPoint != 2)?
    
    errdefer incCounter(100)
    
    if failPoint == 3 {
        fail newError("fail at point 3")
    }
    
    return val, nil
}

// ============ Test 8: ? with both defer and errdefer ============
var deferOrder []int

func testDeferAndErrdeferOrder(shouldFail bool) error {
    deferOrder = []int{}
    
    defer func() {
        deferOrder = append(deferOrder, 1)
    }()
    
    errdefer func() {
        deferOrder = append(deferOrder, 2)
    }()
    
    defer func() {
        deferOrder = append(deferOrder, 3)
    }()
    
    errdefer func() {
        deferOrder = append(deferOrder, 4)
    }()
    
    justError(shouldFail)?
    
    return nil
}

// ============ Test 9: fail with multiple return values ============
func testFailMultipleReturns(failAt int) (int, string, bool, error) {
    if failAt == 1 {
        fail newError("fail at 1")
    }
    
    val := getInt(failAt != 2)?
    
    if failAt == 3 {
        fail newError("fail at 3")
    }
    
    return val, "success", true, nil
}

// ============ Test 10: Nested function with ? propagation ============
func innerFunc(succeed bool) (int, error) {
    return getInt(succeed)
}

func middleFunc(succeed bool) (int, error) {
    val := innerFunc(succeed)?
    return val + 10, nil
}

func outerFunc(succeed bool) (int, error) {
    val := middleFunc(succeed)?
    return val + 100, nil
}

// ============ Test 11: ? with slice operations ============
func getSlice(succeed bool) ([]int, error) {
    if !succeed {
        return nil, newError("getSlice failed")
    }
    return []int{1, 2, 3, 4, 5}, nil
}

func testQuestionWithSlice(succeed bool) (int, error) {
    slice := getSlice(succeed)?
    sum := 0
    for i := 0; i < len(slice); i += 1 {
        sum += slice[i]
    }
    return sum, nil
}

// ============ Test 12: ? with map operations ============
func getMap(succeed bool) (map[string]int, error) {
    if !succeed {
        return nil, newError("getMap failed")
    }
    return map[string]int{"a": 1, "b": 2, "c": 3}, nil
}

func testQuestionWithMap(succeed bool) (int, error) {
    m := getMap(succeed)?
    return m["a"] + m["b"] + m["c"], nil
}

// ============ Test 13: errdefer captures variable at defer time ============
func testErrdeferCapture(shouldFail bool) (int, error) {
    value := 10
    
    errdefer func() {
        counter = value
    }()
    
    value = 20
    
    if shouldFail {
        fail newError("capture test failure")
    }
    
    value = 30
    return value, nil
}

// ============ Test 14: Multiple fail paths ============
func testMultipleFailPaths(path int) error {
    errdefer incCounter(1)
    
    switch path {
    case 1:
        fail newError("path 1")
    case 2:
        justError(false)?
    case 3:
        _ = getInt(false)?
    }
    
    return nil
}

// ============ Test 15: ? result used multiple times ============
func testQuestionResultReuse(succeed bool) (int, error) {
    val := getInt(succeed)?
    return val + val + val, nil
}

// ============ Test 16: Conditional ? execution ============
func testConditionalQuestion(condition bool, succeed bool) (int, error) {
    var result int
    if condition {
        result = getInt(succeed)?
    } else {
        result = 999
    }
    return result, nil
}

// ============ Test 17: ? in switch statement ============
func testQuestionInSwitch(selector int, succeed bool) (string, error) {
    switch selector {
    case 1:
        val := getInt(succeed)?
        return "one:" + string(rune('0'+val%10)), nil
    case 2:
        str := getString(succeed)?
        return "two:" + str, nil
    default:
        return "default", nil
    }
}

// Note: Test 18 (errdefer with panic) removed - panic/recover semantics 
// are separate from error handling sugar

func main() int {
    println("=== Test 1: ? as function argument ===")
    val, err := testQuestionAsArg(true)
    assert(err == nil, "should succeed")
    assert(val == 1042, "42 + 1000 = 1042")
    _, err = testQuestionAsArg(false)
    assert(err != nil, "should propagate error")
    println("PASSED")

    println("")
    println("=== Test 2: ? in complex expression ===")
    val, err = testQuestionInExpression(true)
    assert(err == nil, "should succeed")
    assert(val == 104, "(42 + 10) * 2 = 104")
    _, err = testQuestionInExpression(false)
    assert(err != nil, "should propagate error")
    println("PASSED")

    println("")
    println("=== Test 3: Chained ? with different types ===")
    str, err := testChainedDifferentTypes(true, true)
    assert(err == nil, "should succeed")
    assert(str == "hello:2", "should be hello:2")
    _, err = testChainedDifferentTypes(false, true)
    assert(err != nil, "first ? should fail")
    _, err = testChainedDifferentTypes(true, false)
    assert(err != nil, "second ? should fail")
    println("PASSED")

    println("")
    println("=== Test 4: ? in for loop ===")
    val, err = testQuestionInLoop(3, -1)
    assert(err == nil, "should succeed")
    assert(val == 126, "42 * 3 = 126")
    _, err = testQuestionInLoop(5, 2)
    assert(err != nil, "should fail at iteration 2")
    println("PASSED")

    println("")
    println("=== Test 5: ? with no assignment (statement context) ===")
    err = testQuestionNoAssign(true)
    assert(err == nil, "should succeed")
    err = testQuestionNoAssign(false)
    assert(err != nil, "should propagate error")
    println("PASSED")

    println("")
    println("=== Test 6: Multiple ? on one line ===")
    val, err = testMultipleQuestionOneLine(true, true)
    assert(err == nil, "should succeed")
    assert(val == 84, "42 * 2 = 84")
    _, err = testMultipleQuestionOneLine(false, true)
    assert(err != nil, "inner ? should fail")
    _, err = testMultipleQuestionOneLine(true, false)
    assert(err != nil, "explicit fail should trigger")
    println("PASSED")

    println("")
    println("=== Test 7: ? with errdefer - precise interaction ===")
    resetCounter()
    val, err = testQuestionWithErrdefer(0)
    assert(err == nil && val == 42, "should succeed")
    assert(counter == 0, "no errdefer on success")
    
    resetCounter()
    _, err = testQuestionWithErrdefer(1)
    assert(err != nil, "fail at point 1")
    assert(counter == 1, "only first errdefer runs")
    
    resetCounter()
    _, err = testQuestionWithErrdefer(2)
    assert(err != nil, "fail at point 2 via ?")
    assert(counter == 11, "first two errdefer run: 10+1=11")
    
    resetCounter()
    _, err = testQuestionWithErrdefer(3)
    assert(err != nil, "fail at point 3")
    assert(counter == 111, "all three errdefer run: 100+10+1=111")
    println("PASSED")

    println("")
    println("=== Test 8a: defer and errdefer order (success) ===")
    err = testDeferAndErrdeferOrder(true)
    assert(err == nil, "should succeed")
    assert(len(deferOrder) == 2, "only defer runs on success")
    // Registration: defer(1), errdefer(2), defer(3), errdefer(4)
    // On success (defer only, FIFO): defer(1), defer(3)
    assert(deferOrder[0] == 1, "first defer runs first")
    assert(deferOrder[1] == 3, "second defer runs second")
    
    println("")
    println("=== Test 8b: defer and errdefer order (failure) ===")
    err = testDeferAndErrdeferOrder(false)
    assert(err != nil, "should fail")
    assert(len(deferOrder) == 4, "all run on error")
    // Registration: defer(1), errdefer(2), defer(3), errdefer(4)
    // On error (FIFO): defer(1), errdefer(2), defer(3), errdefer(4)
    assert(deferOrder[0] == 1, "first defer")
    assert(deferOrder[1] == 2, "first errdefer")
    assert(deferOrder[2] == 3, "second defer")
    assert(deferOrder[3] == 4, "second errdefer")
    println("PASSED")

    println("")
    println("=== Test 9: fail with multiple return values ===")
    v1, v2, v3, err := testFailMultipleReturns(0)
    assert(err == nil, "should succeed")
    assert(v1 == 42 && v2 == "success" && v3 == true, "values correct")
    _, _, _, err = testFailMultipleReturns(1)
    assert(err != nil, "fail at 1")
    _, _, _, err = testFailMultipleReturns(2)
    assert(err != nil, "fail at 2 via ?")
    _, _, _, err = testFailMultipleReturns(3)
    assert(err != nil, "fail at 3")
    println("PASSED")

    println("")
    println("=== Test 10: Nested function with ? propagation ===")
    val, err = outerFunc(true)
    assert(err == nil, "should succeed")
    assert(val == 152, "42 + 10 + 100 = 152")
    _, err = outerFunc(false)
    assert(err != nil, "error propagates through all levels")
    println("PASSED")

    println("")
    println("=== Test 11: ? with slice operations ===")
    val, err = testQuestionWithSlice(true)
    assert(err == nil, "should succeed")
    assert(val == 15, "1+2+3+4+5 = 15")
    _, err = testQuestionWithSlice(false)
    assert(err != nil, "should propagate error")
    println("PASSED")

    println("")
    println("=== Test 12: ? with map operations ===")
    val, err = testQuestionWithMap(true)
    assert(err == nil, "should succeed")
    assert(val == 6, "1+2+3 = 6")
    _, err = testQuestionWithMap(false)
    assert(err != nil, "should propagate error")
    println("PASSED")

    println("")
    println("=== Test 13a: errdefer captures variable (success) ===")
    resetCounter()
    val, err = testErrdeferCapture(false)
    assert(err == nil && val == 30, "should return 30")
    assert(counter == 0, "errdefer not run on success")
    
    println("")
    println("=== Test 13b: errdefer captures variable (failure) ===")
    resetCounter()
    _, err = testErrdeferCapture(true)
    assert(err != nil, "should fail")
    assert(counter == 20, "errdefer captures value at fail time")
    println("PASSED")

    println("")
    println("=== Test 14: Multiple fail paths ===")
    resetCounter()
    err = testMultipleFailPaths(0)
    assert(err == nil && counter == 0, "success path")
    
    resetCounter()
    err = testMultipleFailPaths(1)
    assert(err != nil && counter == 1, "explicit fail")
    
    resetCounter()
    err = testMultipleFailPaths(2)
    assert(err != nil && counter == 1, "? on error-only")
    
    resetCounter()
    err = testMultipleFailPaths(3)
    assert(err != nil && counter == 1, "? on (T, error)")
    println("PASSED")

    println("")
    println("=== Test 15: ? result used multiple times ===")
    val, err = testQuestionResultReuse(true)
    assert(err == nil, "should succeed")
    assert(val == 126, "42 + 42 + 42 = 126")
    _, err = testQuestionResultReuse(false)
    assert(err != nil, "should propagate error")
    println("PASSED")

    println("")
    println("=== Test 16: Conditional ? execution ===")
    val, err = testConditionalQuestion(true, true)
    assert(err == nil && val == 42, "condition true, succeed")
    val, err = testConditionalQuestion(false, false)
    assert(err == nil && val == 999, "condition false, skip ?")
    _, err = testConditionalQuestion(true, false)
    assert(err != nil, "condition true, fail")
    println("PASSED")

    println("")
    println("=== Test 17: ? in switch statement ===")
    str, err = testQuestionInSwitch(1, true)
    assert(err == nil && str == "one:2", "case 1 succeed")
    str, err = testQuestionInSwitch(2, true)
    assert(err == nil && str == "two:hello", "case 2 succeed")
    str, err = testQuestionInSwitch(99, true)
    assert(err == nil && str == "default", "default case")
    _, err = testQuestionInSwitch(1, false)
    assert(err != nil, "case 1 fail")
    println("PASSED")

    println("")
    println("=== All Error Handling Sugar tests PASSED ===")
    return 0
}

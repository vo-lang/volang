// Test: method values as first-class functions
// Go spec: t.M is a method value, a function that calls M with t as receiver
package main

type Counter struct {
    value int
}

func (c *Counter) Inc() {
    c.value += 1
}

func (c *Counter) Add(n int) {
    c.value += n
}

func (c Counter) Get() int {
    return c.value
}

func (c Counter) Double() int {
    return c.value * 2
}

type Calculator struct {
    result int
}

func (c *Calculator) Apply(op func(int, int) int, a, b int) {
    c.result = op(a, b)
}

func add(a, b int) int { return a + b }
func mul(a, b int) int { return a * b }

func main() {
    // Test 1: Method value with pointer receiver
    c := &Counter{value: 0}
    inc := c.Inc  // method value
    inc()
    inc()
    inc()
    assert(c.value == 3, "method value Inc should work")
    
    // Test 2: Method value with value receiver
    c2 := Counter{value: 10}
    getVal := c2.Get  // method value, copies c2
    assert(getVal() == 10, "method value Get should return 10")
    c2.value = 20
    // getVal still has old copy (value receiver)
    // Actually in Go, method value captures the receiver at call time
    // So getVal() should still use original value
    
    // Test 3: Store method value in variable and call later
    c3 := &Counter{value: 5}
    addFn := c3.Add
    addFn(10)
    assert(c3.value == 15, "stored method value Add")
    addFn(5)
    assert(c3.value == 20, "stored method value Add second call")
    
    // Test 4: Method value as argument to function
    c4 := &Counter{value: 0}
    applyTwice(c4.Inc)
    assert(c4.value == 2, "method value passed as argument")
    
    // Test 5: Method value in slice
    c5 := &Counter{value: 0}
    ops := []func(){c5.Inc, c5.Inc, c5.Inc}
    for _, op := range ops {
        op()
    }
    assert(c5.value == 3, "method values in slice")
    
    // Test 6: Method value from interface
    var iface interface {
        Get() int
    } = Counter{value: 42}
    getFn := iface.Get
    assert(getFn() == 42, "method value from interface")
    
    // Test 7: Method value in map
    c7 := &Counter{value: 100}
    methods := map[string]func(){
        "inc": c7.Inc,
    }
    methods["inc"]()
    methods["inc"]()
    assert(c7.value == 102, "method value in map")
    
    // Test 8: Chained method value capture
    c8 := &Counter{value: 0}
    incrementers := make([]func(), 3)
    for i := 0; i < 3; i += 1 {
        // Each iteration captures the same c8.Inc
        incrementers[i] = c8.Inc
    }
    for _, f := range incrementers {
        f()
    }
    assert(c8.value == 3, "chained method value captures")
    
    // Test 9: Method with return value
    c9 := Counter{value: 7}
    doubleFn := c9.Double
    assert(doubleFn() == 14, "method value with return")
    
    // Test 10: Calculator with function argument
    calc := &Calculator{}
    calc.Apply(add, 3, 4)
    assert(calc.result == 7, "calculator add")
    calc.Apply(mul, 3, 4)
    assert(calc.result == 12, "calculator mul")
    
    println("method_value: ok")
}

func applyTwice(f func()) {
    f()
    f()
}

// Test: switch with nested statements and break behavior
// Go spec: break in switch exits the switch, not enclosing loop
package main

func main() {
    // Test 1: Basic switch break (implicit at end of case)
    result1 := 0
    switch 2 {
    case 1:
        result1 = 1
    case 2:
        result1 = 2
        // implicit break here
    case 3:
        result1 = 3
    }
    assert(result1 == 2, "basic switch case 2")
    
    // Test 2: Explicit break in switch does not exit loop
    count2 := 0
    for i := 0; i < 5; i += 1 {
        switch i {
        case 2:
            break  // breaks switch, not loop
        default:
            count2 += 1
        }
    }
    assert(count2 == 4, "break in switch doesn't exit loop")
    
    // Test 3: Break with label exits outer loop
    count3 := 0
outer:
    for i := 0; i < 5; i += 1 {
        switch i {
        case 2:
            break outer  // breaks the labeled loop
        default:
            count3 += 1
        }
    }
    assert(count3 == 2, "break outer exits loop at i=2")
    
    // Test 4: Nested switch
    outer4 := ""
    inner4 := ""
    x, y := 1, 2
    switch x {
    case 1:
        outer4 = "x=1"
        switch y {
        case 1:
            inner4 = "y=1"
        case 2:
            inner4 = "y=2"
        }
    case 2:
        outer4 = "x=2"
    }
    assert(outer4 == "x=1", "nested switch outer")
    assert(inner4 == "y=2", "nested switch inner")
    
    // Test 5: Switch in switch, inner break
    result5 := ""
    switch 1 {
    case 1:
        result5 += "A"
        switch 2 {
        case 2:
            result5 += "B"
            break  // breaks inner switch only
        case 3:
            result5 += "C"
        }
        result5 += "D"  // still executes
    }
    assert(result5 == "ABD", "inner break doesn't affect outer")
    
    // Test 6: Switch inside if inside for
    sum6 := 0
    for i := 0; i < 10; i += 1 {
        if i%2 == 0 {
            switch {
            case i < 5:
                sum6 += 1
            default:
                break  // breaks switch, not for
            }
        }
    }
    assert(sum6 == 3, "switch in if in for: 0,2,4 match < 5")
    
    // Test 7: Continue in loop containing switch
    sum7 := 0
    for i := 0; i < 5; i += 1 {
        switch i {
        case 2:
            continue  // continues the for loop
        }
        sum7 += i
    }
    assert(sum7 == 8, "continue in switch: 0+1+3+4=8")
    
    // Test 8: Break to labeled switch (unusual but valid)
    result8 := 0
myswitch:
    switch {
    case true:
        result8 = 1
        break myswitch
        result8 = 2  // unreachable
    }
    assert(result8 == 1, "break to labeled switch")
    
    // Test 9: For with labeled switch, break inner loop
    count9 := 0
outer9:
    for i := 0; i < 3; i += 1 {
        for j := 0; j < 3; j += 1 {
            switch {
            case j == 1:
                break outer9
            }
            count9 += 1
        }
    }
    assert(count9 == 1, "break outer from inside switch")
    
    // Test 10: Empty switch cases with fallthrough
    result10 := ""
    n := 1
    switch n {
    case 1:
        result10 += "one"
        fallthrough
    case 2:
        result10 += "-two"
        // no fallthrough, stops here
    case 3:
        result10 += "-three"
    }
    assert(result10 == "one-two", "fallthrough stops at case 2")
    
    println("switch_nested_break: ok")
}

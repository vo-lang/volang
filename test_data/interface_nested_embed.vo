// Test: Deeply nested interface embedding and conversion
// Coverage: interface A embeds B embeds C, type implements all
package main

type Reader interface {
    Read() int
}

type Writer interface {
    Write(v int)
}

type ReadWriter interface {
    Reader
    Writer
}

type Closer interface {
    Close()
}

type ReadWriteCloser interface {
    ReadWriter
    Closer
}

type Buffer struct {
    data   []int
    closed bool
}

func (b *Buffer) Read() int {
    if len(b.data) == 0 {
        return -1
    }
    v := b.data[0]
    b.data = b.data[1:]
    return v
}

func (b *Buffer) Write(v int) {
    b.data = append(b.data, v)
}

func (b *Buffer) Close() {
    b.closed = true
}

func useReader(r Reader) int {
    return r.Read()
}

func useWriter(w Writer, v int) {
    w.Write(v)
}

func useReadWriter(rw ReadWriter) {
    rw.Write(42)
    v := rw.Read()
    assert(v == 42, "ReadWriter round-trip")
}

func useCloser(c Closer) {
    c.Close()
}

func main() {
    // Test 1: Concrete type implements all interfaces
    buf := &Buffer{data: []int{}}
    
    // Test 2: Assign to most specific interface
    var rwc ReadWriteCloser = buf
    rwc.Write(10)
    rwc.Write(20)
    assert(rwc.Read() == 10, "rwc.Read() should return 10")
    
    // Test 3: Upcast to less specific interface
    var rw ReadWriter = rwc
    rw.Write(30)
    assert(rw.Read() == 20, "rw.Read() should return 20")
    
    // Test 4: Further upcast to single-method interface
    var r Reader = rw
    assert(r.Read() == 30, "r.Read() should return 30")
    
    // Test 5: Direct assignment from concrete to partial interface
    buf2 := &Buffer{data: []int{100, 200}}
    var w Writer = buf2
    w.Write(300)
    assert(buf2.data[2] == 300, "Writer.Write should work")
    
    // Test 6: Type assertion from nested interface
    var any1 any = rwc
    recovered, ok := any1.(ReadWriteCloser)
    assert(ok == true, "type assertion to original interface")
    recovered.Write(999)
    
    // Test 7: Cross-interface type assertion
    var r2 Reader = buf
    rw2, ok2 := r2.(ReadWriter)
    assert(ok2 == true, "Reader can be asserted to ReadWriter")
    rw2.Write(1000)
    
    // Test 8: Use embedded interface in function
    buf3 := &Buffer{data: []int{}}
    useReadWriter(buf3)
    
    // Test 9: nil interface conversion
    var nilRWC ReadWriteCloser = nil
    var nilRW ReadWriter = nilRWC
    assert(nilRW == nil, "nil converts to nil")
    
    // Test 10: Interface with same method from different paths
    // (Tested via top-level types defined above)
    
    println("interface_nested_embed: ok")
}

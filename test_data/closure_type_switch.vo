// Test: type switch inside closure
// Coverage: closure capturing interface values and performing type switches
package main

type Animal interface {
    Speak() string
}

type Dog struct {
    name string
}

func (d Dog) Speak() string {
    return "Woof"
}

type Cat struct {
    name string
}

func (c Cat) Speak() string {
    return "Meow"
}

func main() {
    // Test 1: closure with type switch on captured interface
    var animal Animal = Dog{name: "Buddy"}
    
    describe := func() string {
        switch v := animal.(type) {
        case Dog:
            return "Dog named " + v.name
        case Cat:
            return "Cat named " + v.name
        default:
            return "Unknown"
        }
    }
    
    result := describe()
    assert(result == "Dog named Buddy", "closure type switch 1")
    
    // Test 2: closure sees updated interface value
    animal = Cat{name: "Whiskers"}
    result2 := describe()
    assert(result2 == "Cat named Whiskers", "closure type switch 2")
    
    // Test 3: type switch with any in closure
    var val any = 42
    
    typeOf := func() string {
        switch val.(type) {
        case int:
            return "int"
        case string:
            return "string"
        case bool:
            return "bool"
        default:
            return "other"
        }
    }
    
    assert(typeOf() == "int", "any type switch int")
    val = "hello"
    assert(typeOf() == "string", "any type switch string")
    val = true
    assert(typeOf() == "bool", "any type switch bool")
    val = []int{1, 2, 3}
    assert(typeOf() == "other", "any type switch other")
    
    // Test 4: nested closure with type switch
    var outer any = 100
    
    outerFn := func() func() int {
        return func() int {
            switch v := outer.(type) {
            case int:
                return v * 2
            default:
                return 0
            }
        }
    }
    
    innerFn := outerFn()
    assert(innerFn() == 200, "nested closure type switch")
    
    outer = "not int"
    assert(innerFn() == 0, "nested closure type switch changed")
    
    // Test 5: type switch with multiple types in case
    var mixed any = int64(999)
    
    numericCheck := func() bool {
        switch mixed.(type) {
        case int, int32, int64:
            return true
        default:
            return false
        }
    }
    
    assert(numericCheck(), "multi-type case int64")
    mixed = int(123)
    assert(numericCheck(), "multi-type case int")
    mixed = "string"
    assert(!numericCheck(), "multi-type case string fails")
    
    println("closure_type_switch: ok")
}

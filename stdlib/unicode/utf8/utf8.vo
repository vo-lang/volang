package utf8

// Constants
const (
    RuneError = '\uFFFD' // the "error" rune or "Unicode replacement character"
    RuneSelf  = 0x80     // characters below RuneSelf are represented as themselves in a single byte
    MaxRune   = '\U0010FFFF' // maximum valid Unicode code point
    UTFMax    = 4        // maximum number of bytes of a UTF-8 encoded Unicode character
)

// Code points in the surrogate range are not valid for UTF-8.
const (
    surrogateMin = 0xD800
    surrogateMax = 0xDFFF
)

// Byte masks and limits for UTF-8 encoding
const (
    t1 = 0b00000000
    tx = 0b10000000
    t2 = 0b11000000
    t3 = 0b11100000
    t4 = 0b11110000
    t5 = 0b11111000

    maskx = 0b00111111
    mask2 = 0b00011111
    mask3 = 0b00001111
    mask4 = 0b00000111

    rune1Max = 1<<7 - 1
    rune2Max = 1<<11 - 1
    rune3Max = 1<<16 - 1

    locb = 0x80 // lowest continuation byte
    hicb = 0xBF // highest continuation byte

    // First byte markers: high nibble = acceptRanges index, low nibble = size
    xx = 0xF1 // invalid: size 1
    as = 0xF0 // ASCII: size 1
    s1 = 0x02 // accept 0, size 2
    s2 = 0x13 // accept 1, size 3
    s3 = 0x03 // accept 0, size 3
    s4 = 0x23 // accept 2, size 3
    s5 = 0x34 // accept 3, size 4
    s6 = 0x04 // accept 0, size 4
    s7 = 0x44 // accept 4, size 4
)

// first is information about the first byte in a UTF-8 sequence.
var first = [256]uint8{
    //   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F
    as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F
    //   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
    xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
    xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
    xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
    xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
    xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
    s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
    s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
    s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
}

// acceptRange gives the range of valid values for the second byte in a UTF-8 sequence.
type acceptRange struct {
    lo uint8
    hi uint8
}

// acceptRanges has size 16 to avoid bounds checks in the code that uses it.
var acceptRanges = [16]acceptRange{
    {locb, hicb}, // 0: default
    {0xA0, hicb}, // 1: E0 - avoid overlong
    {locb, 0x9F}, // 2: ED - avoid surrogate
    {0x90, hicb}, // 3: F0 - avoid overlong
    {locb, 0x8F}, // 4: F4 - avoid > MaxRune
    {locb, hicb}, // 5-15: unused padding
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
    {locb, hicb},
}

// RuneLen returns the number of bytes required to encode the rune.
// It returns -1 if the rune is not a valid value to encode in UTF-8.
func RuneLen(r rune) int {
    if r < 0 {
        return -1
    }
    if r <= rune1Max {
        return 1
    }
    if r <= rune2Max {
        return 2
    }
    if surrogateMin <= r && r <= surrogateMax {
        return -1
    }
    if r <= rune3Max {
        return 3
    }
    if r <= MaxRune {
        return 4
    }
    return -1
}

// RuneCount returns the number of runes in p.
func RuneCount(p []byte) int {
    count := 0
    i := 0
    for i < len(p) {
        _, size := DecodeRune(p[i:])
        i += size
        count++
    }
    return count
}

// RuneCountInString returns the number of runes in s.
func RuneCountInString(s string) int {
    count := 0
    i := 0
    for i < len(s) {
        _, size := DecodeRuneInString(s[i:])
        i += size
        count++
    }
    return count
}

// Valid reports whether p consists entirely of valid UTF-8-encoded runes.
func Valid(p []byte) bool {
    i := 0
    for i < len(p) {
        r, size := DecodeRune(p[i:])
        if r == RuneError && size == 1 {
            return false
        }
        i += size
    }
    return true
}

// ValidString reports whether s consists entirely of valid UTF-8-encoded runes.
func ValidString(s string) bool {
    i := 0
    for i < len(s) {
        r, size := DecodeRuneInString(s[i:])
        if r == RuneError && size == 1 {
            return false
        }
        i += size
    }
    return true
}

// ValidRune reports whether r can be legally encoded as UTF-8.
func ValidRune(r rune) bool {
    if r < 0 {
        return false
    }
    if r >= 0xD800 && r <= 0xDFFF {
        return false
    }
    if r > MaxRune {
        return false
    }
    return true
}

// DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes.
// If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,
// it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.
func DecodeRune(p []byte) (rune, int) {
    n := len(p)
    if n < 1 {
        return RuneError, 0
    }
    p0 := p[0]
    // Fast path for ASCII
    if p0 < RuneSelf {
        return rune(p0), 1
    }
    x := first[p0]
    if x >= as {
        // Invalid or ASCII (already handled above, so must be invalid)
        return RuneError, 1
    }
    sz := int(x & 7)
    accept := acceptRanges[x>>4]
    if n < sz {
        return RuneError, 1
    }
    b1 := p[1]
    if b1 < accept.lo || accept.hi < b1 {
        return RuneError, 1
    }
    if sz <= 2 {
        return rune(p0&mask2)<<6 | rune(b1&maskx), 2
    }
    b2 := p[2]
    if b2 < locb || hicb < b2 {
        return RuneError, 1
    }
    if sz <= 3 {
        return rune(p0&mask3)<<12 | rune(b1&maskx)<<6 | rune(b2&maskx), 3
    }
    b3 := p[3]
    if b3 < locb || hicb < b3 {
        return RuneError, 1
    }
    return rune(p0&mask4)<<18 | rune(b1&maskx)<<12 | rune(b2&maskx)<<6 | rune(b3&maskx), 4
}

// DecodeRuneInString is like DecodeRune but its input is a string.
func DecodeRuneInString(s string) (rune, int) {
    n := len(s)
    if n < 1 {
        return RuneError, 0
    }
    s0 := s[0]
    // Fast path for ASCII
    if s0 < RuneSelf {
        return rune(s0), 1
    }
    x := first[s0]
    if x >= as {
        return RuneError, 1
    }
    sz := int(x & 7)
    accept := acceptRanges[x>>4]
    if n < sz {
        return RuneError, 1
    }
    s1 := s[1]
    if s1 < accept.lo || accept.hi < s1 {
        return RuneError, 1
    }
    if sz <= 2 {
        return rune(s0&mask2)<<6 | rune(s1&maskx), 2
    }
    s2 := s[2]
    if s2 < locb || hicb < s2 {
        return RuneError, 1
    }
    if sz <= 3 {
        return rune(s0&mask3)<<12 | rune(s1&maskx)<<6 | rune(s2&maskx), 3
    }
    s3 := s[3]
    if s3 < locb || hicb < s3 {
        return RuneError, 1
    }
    return rune(s0&mask4)<<18 | rune(s1&maskx)<<12 | rune(s2&maskx)<<6 | rune(s3&maskx), 4
}

// DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes.
func DecodeLastRune(p []byte) (rune, int) {
    end := len(p)
    if end == 0 {
        return RuneError, 0
    }
    start := end - 1
    if p[start] < 0x80 {
        return rune(p[start]), 1
    }
    lim := end - UTFMax
    if lim < 0 {
        lim = 0
    }
    for start--; start >= lim; start-- {
        if RuneStart(p[start]) {
            break
        }
    }
    if start < 0 {
        start = 0
    }
    r, size := DecodeRune(p[start:end])
    if start+size != end {
        return RuneError, 1
    }
    return r, size
}

// DecodeLastRuneInString is like DecodeLastRune but its input is a string.
func DecodeLastRuneInString(s string) (rune, int) {
    end := len(s)
    if end == 0 {
        return RuneError, 0
    }
    start := end - 1
    if s[start] < 0x80 {
        return rune(s[start]), 1
    }
    lim := end - UTFMax
    if lim < 0 {
        lim = 0
    }
    for start--; start >= lim; start-- {
        if s[start]&0xC0 != 0x80 {
            break
        }
    }
    if start < 0 {
        start = 0
    }
    r, size := DecodeRuneInString(s[start:end])
    if start+size != end {
        return RuneError, 1
    }
    return r, size
}

// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.
// It returns the number of bytes written.
func EncodeRune(p []byte, r rune) int {
    if r < 0x80 {
        p[0] = byte(r)
        return 1
    }
    if r < 0x800 {
        p[0] = byte(0xC0 | (r >> 6))
        p[1] = byte(0x80 | (r & 0x3F))
        return 2
    }
    if r >= 0xD800 && r <= 0xDFFF {
        r = RuneError
    }
    if r < 0x10000 {
        p[0] = byte(0xE0 | (r >> 12))
        p[1] = byte(0x80 | ((r >> 6) & 0x3F))
        p[2] = byte(0x80 | (r & 0x3F))
        return 3
    }
    if r > MaxRune {
        r = RuneError
        p[0] = byte(0xE0 | (r >> 12))
        p[1] = byte(0x80 | ((r >> 6) & 0x3F))
        p[2] = byte(0x80 | (r & 0x3F))
        return 3
    }
    p[0] = byte(0xF0 | (r >> 18))
    p[1] = byte(0x80 | ((r >> 12) & 0x3F))
    p[2] = byte(0x80 | ((r >> 6) & 0x3F))
    p[3] = byte(0x80 | (r & 0x3F))
    return 4
}

// AppendRune appends the UTF-8 encoding of r to the end of p and returns the extended buffer.
func AppendRune(p []byte, r rune) []byte {
    if r < 0x80 {
        return append(p, byte(r))
    }
    if r < 0x800 {
        return append(p, byte(0xC0|(r>>6)), byte(0x80|(r&0x3F)))
    }
    if r >= 0xD800 && r <= 0xDFFF {
        r = RuneError
    }
    if r < 0x10000 {
        return append(p, byte(0xE0|(r>>12)), byte(0x80|((r>>6)&0x3F)), byte(0x80|(r&0x3F)))
    }
    if r > MaxRune {
        r = RuneError
        return append(p, byte(0xE0|(r>>12)), byte(0x80|((r>>6)&0x3F)), byte(0x80|(r&0x3F)))
    }
    return append(p, byte(0xF0|(r>>18)), byte(0x80|((r>>12)&0x3F)), byte(0x80|((r>>6)&0x3F)), byte(0x80|(r&0x3F)))
}

// FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
func FullRune(p []byte) bool {
    n := len(p)
    if n == 0 {
        return false
    }
    x := first[p[0]]
    if n >= int(x&7) {
        return true // ASCII, invalid or valid.
    }
    // Must be short or invalid.
    accept := acceptRanges[x>>4]
    if n > 1 && (p[1] < accept.lo || accept.hi < p[1]) {
        return true
    } else if n > 2 && (p[2] < locb || hicb < p[2]) {
        return true
    }
    return false
}

// FullRuneInString is like FullRune but its input is a string.
func FullRuneInString(s string) bool {
    n := len(s)
    if n == 0 {
        return false
    }
    x := first[s[0]]
    if n >= int(x&7) {
        return true // ASCII, invalid, or valid.
    }
    // Must be short or invalid.
    accept := acceptRanges[x>>4]
    if n > 1 && (s[1] < accept.lo || accept.hi < s[1]) {
        return true
    } else if n > 2 && (s[2] < locb || hicb < s[2]) {
        return true
    }
    return false
}

// RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune.
func RuneStart(b byte) bool {
    return b&0xC0 != 0x80
}

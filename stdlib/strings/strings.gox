package strings

// Extern functions (implemented in Rust)
extern func Index(s, substr string) int
extern func LastIndex(s, substr string) int
extern func Count(s, substr string) int
extern func ToLower(s string) string
extern func ToUpper(s string) string
extern func TrimSpace(s string) string
extern func Trim(s, cutset string) string
extern func TrimLeft(s, cutset string) string
extern func TrimRight(s, cutset string) string
extern func Split(s, sep string) []string
extern func Replace(s, old, new string, n int) string
extern func EqualFold(s, t string) bool

// GoX-implemented functions

// HasPrefix tests whether the string s begins with prefix.
func HasPrefix(s, prefix string) bool {
    return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}

// HasSuffix tests whether the string s ends with suffix.
func HasSuffix(s, suffix string) bool {
    return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}

// Contains reports whether substr is within s.
func Contains(s, substr string) bool {
    return Index(s, substr) >= 0
}

// Compare returns an integer comparing two strings lexicographically.
func Compare(a, b string) int {
    if a == b {
        return 0
    }
    if a < b {
        return -1
    }
    return 1
}

// Repeat returns a new string consisting of count copies of s.
func Repeat(s string, count int) string {
    if count <= 0 {
        return ""
    }
    result := ""
    for i := 0; i < count; i += 1 {
        result = result + s
    }
    return result
}

// TrimPrefix returns s without the provided leading prefix string.
func TrimPrefix(s, prefix string) string {
    if HasPrefix(s, prefix) {
        return s[len(prefix):]
    }
    return s
}

// TrimSuffix returns s without the provided trailing suffix string.
func TrimSuffix(s, suffix string) string {
    if HasSuffix(s, suffix) {
        return s[:len(s)-len(suffix)]
    }
    return s
}

// ReplaceAll returns a copy of s with all occurrences of old replaced by new.
func ReplaceAll(s, old, new string) string {
    return Replace(s, old, new, -1)
}

// Join concatenates the elements of parts to create a single string.
func Join(parts []string, sep string) string {
    if len(parts) == 0 {
        return ""
    }
    result := parts[0]
    for i := 1; i < len(parts); i += 1 {
        result = result + sep + parts[i]
    }
    return result
}

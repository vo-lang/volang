// Package dyn provides dynamic access APIs for working with any/interface{} values.
//
// Vo supports two ways to access dynamic values:
//
// 1. The ~> operator (recommended for most cases):
//
//    val := data~>field?        // get field
//    val := data~>[key]?        // get index
//    data~>field = val          // set field (requires error return)
//    data~>[key] = val          // set index (requires error return)
//
// 2. The dyn package functions (for explicit error handling):
//
//    val, err := dyn.GetAttr(data, "field")
//    val, err := dyn.GetIndex(data, key)
//    err := dyn.SetAttr(data, "field", val)
//    err := dyn.SetIndex(data, key, val)
//
// The ~> operator desugars to these functions internally.
//
// # Supported Types
//
// Dynamic access works on:
//   - Structs: field access by name
//   - Pointers to structs: field access and method calls
//   - Maps: key-based access
//   - Slices/Arrays: integer index access
//   - Custom types implementing dyn interfaces
//
// # Error Handling
//
// All operations return errors. Use errors.Is() to check:
//
//    if errors.Is(err, dyn.ErrBadField) { ... }
//
package dyn

import "errors"

// =============================================================================
// Error Values
// =============================================================================

// ErrUnknown indicates an unknown or unexpected error.
var ErrUnknown = errors.NewDynUnknown("dynamic access: unknown error")

// ErrNilBase indicates the base value is nil.
var ErrNilBase = errors.NewDynNilBase("dynamic access: base value is nil")

// ErrBadField indicates the field does not exist on the type.
var ErrBadField = errors.NewDynBadField("dynamic access: field does not exist")

// ErrBadIndex indicates the index type is invalid for the container.
var ErrBadIndex = errors.NewDynBadIndex("dynamic access: invalid index type")

// ErrOutOfBounds indicates the index is outside valid range.
var ErrOutOfBounds = errors.NewDynOutOfBounds("dynamic access: index out of bounds")

// ErrBadCall indicates the value cannot be called as a function.
var ErrBadCall = errors.NewDynBadCall("dynamic access: cannot call value")

// ErrSigMismatch indicates function signature does not match arguments.
var ErrSigMismatch = errors.NewDynSigMismatch("dynamic access: signature mismatch")

// ErrTypeMismatch indicates type assertion or conversion failed.
var ErrTypeMismatch = errors.NewDynTypeMismatch("dynamic access: type mismatch")

// =============================================================================
// Public API Functions
// =============================================================================

// GetAttr retrieves a field or method from a struct/pointer by name.
// For maps, use GetIndex instead.
func GetAttr(base any, name string) (any, error)

// GetIndex retrieves an element from a container by key.
func GetIndex(base any, key any) (any, error)

// SetAttr sets a field value on a struct pointer by name.
// Note: base must be a pointer for the change to persist.
func SetAttr(base any, name string, value any) error

// SetIndex sets an element in a container by key.
func SetIndex(base any, key any, value any) error

// =============================================================================
// Protocol Methods (Language-Level)
// =============================================================================
//
// The ~> operator recognizes these methods on any type:
//
//   DynAttr(name string) (any, error)      - a~>field
//   DynSetAttr(name string, val any) error - a~>field = val
//   DynIndex(key any) (any, error)         - a~>[key]
//   DynSetIndex(key any, val any) error    - a~>[key] = val
//   DynCall(args ...any) (any, error)      - a~>(args)
//
// No interface implementation required. The runtime looks up
// these methods by name (duck typing).
//
// =============================================================================
// Type Constraint Interfaces (Optional)
// =============================================================================
//
// These interfaces are for documentation and compile-time type constraints.
// The ~> operator does NOT check interface implementation.

// AttrObject is a type constraint for types with DynAttr.
type AttrObject interface {
    DynAttr(name string) (any, error)
}

// IndexObject is a type constraint for types with DynIndex.
type IndexObject interface {
    DynIndex(key any) (any, error)
}

// CallObject is a type constraint for types with DynCall.
type CallObject interface {
    DynCall(args ...any) (any, error)
}

// SetAttrObject is a type constraint for types with DynSetAttr.
type SetAttrObject interface {
    DynSetAttr(name string, value any) error
}

// SetIndexObject is a type constraint for types with DynSetIndex.
type SetIndexObject interface {
    DynSetIndex(key any, value any) error
}

// Object combines all read-only dynamic access interfaces.
type Object interface {
    AttrObject
    IndexObject
    CallObject
}

// SetObject combines all write dynamic access interfaces.
type SetObject interface {
    SetAttrObject
    SetIndexObject
}

// =============================================================================
// Built-in Dynamic Containers
// =============================================================================

// MapObject is a dynamic object container using string keys.
type MapObject map[string]any

func (m MapObject) DynAttr(name string) (any, error) {
    return m.DynIndex(name)
}

func (m MapObject) DynIndex(key any) (any, error) {
    k, ok := key.(string)
    if !ok {
        return nil, ErrBadIndex
    }
    v, ok := m[k]
    if !ok {
        return nil, ErrBadField
    }
    return v, nil
}

func (m MapObject) DynSetAttr(name string, value any) error {
    return m.DynSetIndex(name, value)
}

func (m MapObject) DynSetIndex(key any, value any) error {
    k, ok := key.(string)
    if !ok {
        return ErrBadIndex
    }
    m[k] = value
    return nil
}

// SliceObject is a dynamic array container.
type SliceObject []any

func (s SliceObject) DynIndex(key any) (any, error) {
    i, ok := key.(int)
    if !ok {
        return nil, ErrBadIndex
    }
    if i < 0 || i >= len(s) {
        return nil, ErrOutOfBounds
    }
    return s[i], nil
}

func (s SliceObject) DynSetIndex(key any, value any) error {
    i, ok := key.(int)
    if !ok {
        return ErrBadIndex
    }
    if i < 0 || i >= len(s) {
        return ErrOutOfBounds
    }
    s[i] = value
    return nil
}

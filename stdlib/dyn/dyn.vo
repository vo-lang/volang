package dyn

import "errors"

// Error codes for dynamic access operations.
// Range 1000-1099 is reserved for dyn package.
const (
    ErrUnknown      = 1000 // Unknown error
    ErrNilBase      = 1001 // Base value is nil
    ErrBadField     = 1002 // Field does not exist
    ErrBadIndex     = 1003 // Invalid index type
    ErrOutOfBounds  = 1004 // Index out of bounds
    ErrBadCall      = 1005 // Cannot call value
    ErrSigMismatch  = 1006 // Signature mismatch
    ErrTypeMismatch = 1007 // Type mismatch
)

// NewError creates a dynamic access error with the given code and message.
func NewError(code int, msg string) error {
    return errors.NewCode(code, msg)
}

type AttrObject interface {
    __attr(name string) (any, error)
}

type IndexObject interface {
    __index(key any) (any, error)
}

type CallObject interface {
    __call(args ...any) (any, error)
}

type Object interface {
    AttrObject
    IndexObject
    CallObject
}

type SetAttrObject interface {
    __setattr(name string, value any) error
}

type SetIndexObject interface {
    __setindex(key any, value any) error
}

type SetObject interface {
    SetAttrObject
    SetIndexObject
}

// Extern functions (implemented in Rust)
func SetAttr(base any, name string, value any) error
func SetIndex(base any, key any, value any) error

// anymap is the standard dynamic object container.
type MapObject map[string]any

func (m MapObject) __attr(name string) (any, error) {
    v, err := m.__index(name)
    return v, err
}

func (m MapObject) __index(key any) (any, error) {
    k, ok := key.(string)
    if !ok {
        return nil, NewError(ErrBadIndex, "map key must be string")
    }
    v, ok := m[k]
    if !ok {
        return nil, NewError(ErrBadField, "key not found")
    }
    return v, nil
}

func (m MapObject) __setattr(name string, value any) error {
    return m.__setindex(name, value)
}

func (m MapObject) __setindex(key any, value any) error {
    k, ok := key.(string)
    if !ok {
        return NewError(ErrBadIndex, "map key must be string")
    }
    m[k] = value
    return nil
}

// anyslice is the standard dynamic array container.
type SliceObject []any

func (s SliceObject) __index(key any) (any, error) {
    i, ok := key.(int)
    if !ok {
        return nil, NewError(ErrBadIndex, "slice index must be int")
    }
    if i < 0 || i >= len(s) {
        return nil, NewError(ErrOutOfBounds, "slice index out of bounds")
    }
    return s[i], nil
}

func (s SliceObject) __setindex(key any, value any) error {
    i, ok := key.(int)
    if !ok {
        return NewError(ErrBadIndex, "slice index must be int")
    }
    if i < 0 || i >= len(s) {
        return NewError(ErrOutOfBounds, "slice index out of bounds")
    }
    s[i] = value
    return nil
}

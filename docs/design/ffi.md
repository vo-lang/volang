# Vo FFI Design

This document describes the Foreign Function Interface (FFI) for calling extern (Rust) functions from Vo code.

## 1. Overview

- Extern functions use the same `CALL` instruction as Vo functions (unified calling)
- Wrapper types hide VM internals from extern function developers
- Proc macro enables ergonomic function definition and auto-registration

## 2. Vo-Side Declaration

Declare extern functions without body:

```go
// std/fmt.vo
package fmt

extern func Println(a ...interface{}) (n int, err error)
extern func Printf(format string, a ...interface{}) (n int, err error)
extern func Sprintf(format string, a ...interface{}) string
```

```go
// std/os.vo
package os

type File struct { handle int }

extern func Open(name string) (*File, error)
extern func ReadFile(name string) ([]byte, error)
extern func (f *File) Read(b []byte) (n int, err error)
extern func (f *File) Close() error
```

Usage in Vo code:

```go
import "fmt"
import "os"

func main() {
    data, err := os.ReadFile("hello.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println(string(data))
}
```

## 3. Rust-Side Implementation

### 3.1 Proc Macro

```rust
use vo_ffi::prelude::*;

#[vo_extern("fmt.Println")]
fn println(args: VoVariadic) -> (i64, Option<VoError>) {
    let s = args.format_default();
    println!("{}", s);
    (s.len() as i64, None)
}

#[vo_extern("os.ReadFile")]
fn read_file(path: VoString) -> Result<Vec<u8>, VoError> {
    std::fs::read(path.as_str()).map_err(Into::into)
}

#[vo_extern("os.File.Read")]
fn file_read(file: VoObject, buf: VoSlice<u8>) -> Result<i64, VoError> {
    // ...
}
```

### 3.2 Wrapper Types

Extern function developers use these wrapper types (not raw VM internals):

```rust
/// Generic value type
pub enum VoValue<'a> {
    Nil,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(VoString<'a>),
    Slice(VoSlice<'a>),
    Map(VoMap<'a>),
    Struct(VoStruct<'a>),
    Object(VoObject<'a>),
    Interface(VoInterface<'a>),
}

/// String wrapper
pub struct VoString<'a> { ... }
impl VoString<'_> {
    pub fn as_str(&self) -> &str;
    pub fn len(&self) -> usize;
}

/// Slice wrapper
pub struct VoSlice<'a, T = VoValue<'a>> { ... }
impl<'a, T> VoSlice<'a, T> {
    pub fn len(&self) -> usize;
    pub fn get(&self, idx: usize) -> T;
    pub fn as_slice(&self) -> &[T];  // for primitive T
    pub fn iter(&self) -> impl Iterator<Item = T>;
}

/// Struct wrapper (value type, references stack slots)
pub struct VoStruct<'a> { ... }
impl VoStruct<'_> {
    pub fn field(&self, idx: usize) -> VoValue;
    pub fn field_count(&self) -> usize;
}

/// Object wrapper (reference type)
pub struct VoObject<'a> { ... }

/// Map wrapper
pub struct VoMap<'a> { ... }
impl<'a> VoMap<'a> {
    pub fn get(&self, key: VoValue) -> Option<VoValue<'a>>;
    pub fn len(&self) -> usize;
    pub fn iter(&self) -> impl Iterator<Item = (VoValue<'a>, VoValue<'a>)>;
}

/// Variadic arguments
pub struct VoVariadic<'a> { ... }
impl VoVariadic<'_> {
    pub fn len(&self) -> usize;
    pub fn get(&self, idx: usize) -> VoValue;
    pub fn format_default(&self) -> String;
    pub fn format_with(&self, fmt: &str) -> String;
}
```

### 3.3 Type Conversion

The proc macro automatically handles type conversion:

| Rust Parameter | Extraction |
|----------------|------------|
| `i64`, `i32` | `args.get(n).as_int()` |
| `f64`, `f32` | `args.get(n).as_float()` |
| `bool` | `args.get(n).as_bool()` |
| `VoString` | `args.get(n).as_string()` |
| `VoSlice<T>` | `args.get(n).as_slice()` |
| `VoMap` | `args.get(n).as_map()` |
| `VoStruct` | `args.get(n).as_struct()` |
| `VoObject` | `args.get(n).as_object()` |
| `VoValue` | `args.get(n)` |
| `VoVariadic` | `args.rest(n)` |

| Rust Return | Conversion |
|-------------|------------|
| `()` | `Ok(vec![])` |
| `T` | `Ok(vec![T.into_vo()])` |
| `(T, U)` | `Ok(vec![T.into_vo(), U.into_vo()])` |
| `Result<T, VoError>` | Success → values, Error → panic |
| `Option<VoError>` | `None` → nil, `Some(e)` → error |

### 3.4 Extern Context

For operations that need VM access:

```rust
pub struct ExternCtx<'a> { ... }

impl ExternCtx<'_> {
    // Allocation
    pub fn new_string(&mut self, s: &str) -> VoString;
    pub fn new_slice<T>(&mut self, data: &[T]) -> VoSlice<T>;
    pub fn new_byte_slice(&mut self, data: &[u8]) -> VoSlice<u8>;
    pub fn new_error(&mut self, msg: String) -> VoError;
    
    // Type info
    pub fn type_of(&self, val: &VoValue) -> TypeId;
}

// Usage
#[vo_extern("mypackage.NewThing")]
fn new_thing(ctx: &mut ExternCtx, name: VoString) -> VoObject {
    ctx.new_object(TYPE_THING, &[name.into_vo()])
}
```

## 4. Auto-Registration

The `#[vo_extern]` macro automatically registers functions using the `inventory` crate:

```rust
// Generated by macro
inventory::submit! {
    ExternEntry {
        name: "fmt.Println",
        func: __vo_wrapper_println,
    }
}

// VM initialization
impl ExternRegistry {
    pub fn from_inventory() -> Self {
        let mut registry = Self::new();
        for entry in inventory::iter::<ExternEntry> {
            registry.insert(entry.name.to_string(), entry.func);
        }
        registry
    }
}

// Usage
fn init_vm() -> Vm {
    let registry = ExternRegistry::from_inventory();
    Vm::new(registry)
}
```

## 5. GC Safety

During extern function execution, GC is paused:

```rust
fn exec_extern_call(vm: &mut Vm, extern_fn: ExternFn, args: VoArgs) -> VoResult {
    vm.gc.pause();
    let result = extern_fn(&mut vm.extern_ctx, args);
    vm.gc.resume();
    result
}
```

This ensures all GcRef values remain valid during the call.

## 6. Internal Implementation

### Callable Type

```rust
enum Callable {
    VoFunc { func_id: FuncId },
    ExternFunc { func: fn(&mut ExternCtx, VoArgs) -> VoResult },
    Closure { func_id: FuncId, upvalues: Vec<GcRef> },
}
```

### Arguments Wrapper

```rust
pub struct VoArgs<'a> {
    ctx: &'a ExternCtx,
    raw: &'a [u64],
    offsets: &'a [ArgOffset],  // Start position and type of each arg
}

impl<'a> VoArgs<'a> {
    pub fn get(&self, idx: usize) -> VoValue<'a>;
    pub fn len(&self) -> usize;
    pub fn rest(&self, from: usize) -> VoVariadic<'a>;
}
```

## 7. Summary

| Aspect | Design |
|--------|--------|
| Vo syntax | `extern func Name(params) returns` |
| Rust syntax | `#[vo_extern("pkg.Name")] fn name(...)` |
| Wrapper types | `VoString`, `VoSlice`, `VoStruct`, etc. |
| Type conversion | Automatic via proc macro |
| Registration | Auto via `inventory` crate |
| GC safety | Pause during extern call |

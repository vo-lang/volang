// runner.vo - Parallel test execution engine
package main

import (
	"../../libs/vox"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"
)

const (
	ansiBold   = "\x1b[1m"
	ansiDim    = "\x1b[2m"
	ansiGreen  = "\x1b[0;32m"
	ansiRed    = "\x1b[0;31m"
	ansiCyan   = "\x1b[0;36m"
	ansiYellow = "\x1b[1;33m"
	ansiReset  = "\x1b[0m"
)

var colorEnabled bool


type TestJob struct {
	file string
	mode string
	shouldFail bool
	gcDebug bool
	index int
	skipped bool
}

func writeProgress(s string) {
	_, _ = os.Stderr.WriteString(s)
}

func colorize(s string, color string) string {
	if !colorEnabled {
		return s
	}
	return color + s + ansiReset
}

func statusSymbol(result TestResult) string {
	if result.skipped {
		return colorize("⊘", ansiYellow)
	}
	if result.passed {
		return colorize("✓", ansiGreen)
	}
	return colorize("✗", ansiRed)
}

func displayPath(path string) string {
	if strings.HasPrefix(path, "lang/test_data/") {
		path = path[len("lang/test_data/"):]
	}
	// Project directory tests are printed with trailing slash in d_py.py
	if !strings.HasSuffix(path, ".vo") && !strings.HasSuffix(path, "/") {
		// Keep zip paths like zip/foo.zip:src/ unchanged
		if !strings.Contains(path, ".zip") && !strings.Contains(path, ":") {
			path = path + "/"
		}
	}
	return path
}

func pad3(n int) string {
	s := strconv.Itoa(n)
	if len(s) == 1 {
		return "  " + s
	}
	if len(s) == 2 {
		return " " + s
	}
	return s
}

func formatElapsedSeconds(ms int64) float64 {
	return float64(ms) / 1000.0
}

func timeStyleCode(elapsedSec float64) string {
	if elapsedSec > 1.0 {
		return ansiYellow
	}
	if elapsedSec > 0.1 {
		return ansiDim + ansiYellow
	}
	return ansiDim
}

func printTestLine(result TestResult, verbose bool) {
	file := displayPath(result.file)

	if result.skipped {
		if !verbose {
			return
		}
		fmt.Println("  " + statusSymbol(result) + " " + file + " [" + result.mode + " skipped]")
		return
	}

	elapsed := formatElapsedSeconds(result.elapsedMs)
	timeStr := colorize(fmt.Sprintf("(%.2fs)", elapsed), timeStyleCode(elapsed))
	fmt.Println("  " + statusSymbol(result) + " " + file + " [" + result.mode + "] " + timeStr)

	if verbose && result.output != "" {
		_, _ = os.Stdout.WriteString(result.output)
	}

	if verbose && !result.passed && result.errorMsg != "" {
		fmt.Println(result.errorMsg)
	}
}

func expectedErrorSubstrings(path string) []string {
	data, err := os.ReadFile(path)
	if err != nil {
		return []string{}
	}

	lines := strings.Split(string(data), "\n")
	expected := []string{}
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if !strings.HasPrefix(trimmed, "//") {
			continue
		}
		idx := strings.Index(trimmed, "Expected:")
		if idx < 0 {
			continue
		}
		rest := strings.TrimSpace(trimmed[idx+len("Expected:"):])
		if rest == "" {
			continue
		}
		q1 := strings.Index(rest, "\"")
		q2 := -1
		if q1 >= 0 {
			q2 = strings.LastIndex(rest, "\"")
		}
		if q1 >= 0 && q2 > q1 {
			expected = append(expected, rest[q1+1:q2])
		} else {
			expected = append(expected, rest)
		}
	}
	return expected
}

func matchesAllSubstrings(msg string, expected []string) bool {
	for _, s := range expected {
		if s == "" {
			continue
		}
		if !matchesPattern(msg, s) {
			return false
		}
	}
	return true
}

func matchesPattern(msg string, pattern string) bool {
	// Support a minimal wildcard: 'X' matches any substring.
	// This keeps test comments stable while allowing concrete type names.
	if !strings.Contains(pattern, "X") {
		return strings.Contains(msg, pattern)
	}
	parts := strings.Split(pattern, "X")
	idx := 0
	for _, p := range parts {
		if p == "" {
			continue
		}
		pos := strings.Index(msg[idx:], p)
		if pos < 0 {
			return false
		}
		idx += pos + len(p)
	}
	return true
}

type TestResult struct {
	file string
	mode string
	passed bool
	skipped bool
	elapsedMs int64
	output string
	errorMsg string
	index int
}

type TestStats struct {
	vmPassed int
	vmFailed int
	vmSkipped int
	jitPassed int
	jitFailed int
	jitSkipped int
	nostdPassed int
	nostdFailed int
	nostdSkipped int
	failedTests []string
}

func runTests(mode string, args []string) int {
	// Parse options
	verbose := false
	workers := 4  // default
	singleFile := ""
	colorMode := "auto"

	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "-v" || arg == "--verbose" {
			verbose = true
		} else if strings.HasPrefix(arg, "-j") {
			// Parse -j8 or -j 8
			numStr := arg[2:]
			if numStr == "" && i+1 < len(args) {
				i++
				numStr = args[i]
			}
			if n, err := strconv.Atoi(numStr); err == nil && n > 0 {
				workers = n
			}
		} else if strings.HasPrefix(arg, "--color=") {
			colorMode = strings.TrimPrefix(arg, "--color=")
		} else if !strings.HasPrefix(arg, "-") {
			singleFile = arg
		}
	}

	if colorMode == "always" {
		colorEnabled = true
	} else if colorMode == "never" {
		colorEnabled = false
	} else if colorMode == "auto" {
		colorEnabled = os.IsTerminal(os.Stdout.Fd())
	} else {
		fmt.Println("[VO-TEST] invalid --color mode: " + colorMode)
		return 1
	}

	// JIT threshold to match d_py.py behavior
	if mode == "jit" || mode == "both" || mode == "gc" {
		err := os.Setenv("VO_JIT_CALL_THRESHOLD", "1")
		if err != nil {
			fmt.Println("[VO-TEST] could not set VO_JIT_CALL_THRESHOLD: " + err.Error())
			return 1
		}
	}

	// Load test configuration
	testDataDir := "lang/test_data"
	configPath := testDataDir + "/_config.toml"
	configs, err := loadTestConfig(configPath)
	if err != nil {
		fmt.Println("[VO-TEST] could not load _config.toml: " + err.Error())
		return 1
	}

	// Single file mode
	if singleFile != "" {
		return runSingleFile(singleFile, mode, verbose, configs)
	}

	// Collect test files
	jobs := collectTestJobs(testDataDir, mode, configs)
	
	if len(jobs) == 0 {
		fmt.Println("[VO-TEST] No tests found")
		return 1
	}

	fmt.Println(colorize("Running Vo integration tests...", ansiBold))
	fmt.Println("")

	// Run tests in parallel
	results := runTestsParallel(jobs, workers, verbose)

	// Print results
	stats := calculateStats(results)
	printResults(stats, verbose)

	totalFailed := stats.vmFailed + stats.jitFailed + stats.nostdFailed
	if totalFailed > 0 {
		return 1
	}
	return 0
}

func collectTestJobs(testDir string, mode string, configs map[string]TestConfig) []TestJob {
	jobs := []TestJob{}
	
	runVM := mode == "vm" || mode == "both" || mode == "gc" || mode == "nostd"
	runJIT := mode == "jit" || mode == "both" || mode == "gc"
	isGCMode := mode == "gc"
	isNoStdMode := mode == "nostd"

	// Collect .vo files
	files := findVoFiles(testDir)
	
	for _, file := range files {
		relPath := file
		if strings.HasPrefix(file, testDir + "/") {
			relPath = file[len(testDir)+1:]
		}

		config := configs[relPath]
		fileName := relPath
		if idx := strings.LastIndex(relPath, "/"); idx >= 0 {
			fileName = relPath[idx+1:]
		}
		isGCFile := strings.HasPrefix(fileName, "gc_")

		// gc mode: only gc_* files; other modes: skip gc_* files unless explicitly testing
		if isGCMode && !isGCFile {
			continue
		}
		if !isGCMode && !isNoStdMode && isGCFile {
			continue
		}

		gcDebug := isGCMode && isGCFile

		// should_fail tests run once (not per mode)
		if config.shouldFail {
			jobs = append(jobs, TestJob{
				file: file,
				mode: "compile",
				shouldFail: true,
				gcDebug: false,
				index: 0,
				skipped: false,
			})
			continue
		}

		if runVM {
			testMode := "vm"
			if isNoStdMode {
				testMode = "nostd"
			}
			skipMode := "vm"
			if isNoStdMode {
				skipMode = "nostd"
			}
			if config.shouldSkip(skipMode) {
				jobs = append(jobs, TestJob{
					file: file,
					mode: testMode,
					shouldFail: false,
					gcDebug: false,
					index: 0,
					skipped: true,
				})
			} else {
			jobs = append(jobs, TestJob{
				file: file,
				mode: testMode,
				shouldFail: false,
				gcDebug: gcDebug,
				index: 0,
				skipped: false,
			})
			}
		}

		if runJIT {
			if config.shouldSkip("jit") {
				jobs = append(jobs, TestJob{
					file: file,
					mode: "jit",
					shouldFail: false,
					gcDebug: false,
					index: 0,
					skipped: true,
				})
			} else {
			jobs = append(jobs, TestJob{
				file: file,
				mode: "jit",
				shouldFail: false,
				gcDebug: gcDebug,
				index: 0,
				skipped: false,
			})
			}
		}
	}

	// Collect project directories (proj_*)
	if !isGCMode && !isNoStdMode {
		projDirs := findProjectDirs(testDir)
		for _, dir := range projDirs {
			relPath := dir
			if strings.HasPrefix(dir, testDir + "/") {
				relPath = dir[len(testDir)+1:] + "/"
			}

			config := configs[relPath]
			
			if config.shouldFail {
				jobs = append(jobs, TestJob{
					file: dir,
					mode: "compile",
					shouldFail: true,
					gcDebug: false,
					index: 0,
					skipped: false,
				})
				continue
			}

			if runVM {
				if config.shouldSkip("vm") {
					jobs = append(jobs, TestJob{
						file: dir,
						mode: "vm",
						shouldFail: false,
						gcDebug: false,
						index: 0,
						skipped: true,
					})
				} else {
				jobs = append(jobs, TestJob{
					file: dir,
					mode: "vm",
					shouldFail: false,
					gcDebug: false,
					index: 0,
					skipped: false,
				})
				}
			}

			if runJIT {
				if config.shouldSkip("jit") {
					jobs = append(jobs, TestJob{
						file: dir,
						mode: "jit",
						shouldFail: false,
						gcDebug: false,
						index: 0,
						skipped: true,
					})
				} else {
				jobs = append(jobs, TestJob{
					file: dir,
					mode: "jit",
					shouldFail: false,
					gcDebug: false,
					index: 0,
					skipped: false,
				})
				}
			}
		}

		// Collect zip files
		zipFiles := findZipFiles(testDir)
		for _, zipFile := range zipFiles {
			relPath := zipFile
			if strings.HasPrefix(zipFile, testDir + "/") {
				relPath = zipFile[len(testDir)+1:]
			}

			config := configs[relPath]
			
			// Handle zip_root config
			testPath := zipFile
			if config.zipRoot != "" {
				testPath = zipFile + ":" + config.zipRoot
			}

			if runVM {
				if config.shouldSkip("vm") {
					jobs = append(jobs, TestJob{
						file: testPath,
						mode: "vm",
						shouldFail: false,
						gcDebug: false,
						index: 0,
						skipped: true,
					})
				} else {
				jobs = append(jobs, TestJob{
					file: testPath,
					mode: "vm",
					shouldFail: false,
					gcDebug: false,
					index: 0,
					skipped: false,
				})
				}
			}

			if runJIT {
				if config.shouldSkip("jit") {
					jobs = append(jobs, TestJob{
						file: testPath,
						mode: "jit",
						shouldFail: false,
						gcDebug: false,
						index: 0,
						skipped: true,
					})
				} else {
				jobs = append(jobs, TestJob{
					file: testPath,
					mode: "jit",
					shouldFail: false,
					gcDebug: false,
					index: 0,
					skipped: false,
				})
				}
			}
		}
	}

	return jobs
}

func runTestsParallel(jobs []TestJob, workers int, verbose bool) []TestResult {
	jobChan := make(chan TestJob, len(jobs))
	resultChan := make(chan TestResult, len(jobs))

	for i := 0; i < len(jobs); i++ {
		jobs[i].index = i
	}

	// Start workers
	for i := 0; i < workers; i++ {
		go testWorker(jobChan, resultChan, verbose)
	}

	// Send jobs (in a separate goroutine) so we can start receiving results immediately.
	go func() {
		for _, job := range jobs {
			jobChan <- job
		}
		close(jobChan)
	}()

	results := make([]TestResult, len(jobs))

	// Receive results and print immediately
	for i := 0; i < len(jobs); i++ {
		result := <-resultChan
		results[result.index] = result
		printTestLine(result, verbose)
	}
	return results
}

func testWorker(jobs <-chan TestJob, results chan<- TestResult, verbose bool) {
	for job := range jobs {
		result := runSingleTest(job, verbose)
		results <- result
	}
}

func runSingleTest(job TestJob, verbose bool) TestResult {
	start := time.Now()
	if job.skipped {
		return TestResult{
			file: job.file,
			mode: job.mode,
			passed: true,
			skipped: true,
			elapsedMs: 0,
			output: "",
			errorMsg: "",
			index: job.index,
		}
	}

	if verbose {
		fmt.Println("  [VO-TEST] START " + displayPath(job.file) + " [" + job.mode + "]")
	}

	if job.shouldFail {
		return runShouldFailTest(job, start)
	}

	// Compile
	var module vox.Module
	var err error
	
	if strings.HasSuffix(job.file, ".vo") {
		module, err = vox.CompileFile(job.file)
	} else {
		module, err = vox.CompileDir(job.file)
	}

	if err != nil {
		return TestResult{
			file: job.file,
			mode: job.mode,
			passed: false,
			skipped: false,
			elapsedMs: time.Since(start).Milliseconds(),
			output: "",
			errorMsg: "[COMPILE] " + err.Error(),
			index: job.index,
		}
	}

	// Run
	output := ""
	if job.mode == "nostd" {
		output, err = runWithVoEmbed(module)
	} else if job.mode == "jit" {
		output, err = vox.RunJitCapture(module)
	} else {
		output, err = vox.RunCapture(module)
	}
	vox.Free(module)

	errorMsg := ""
	if err != nil {
		errorMsg = err.Error()
	}

	return TestResult{
		file: job.file,
		mode: job.mode,
		passed: err == nil,
		skipped: false,
		elapsedMs: time.Since(start).Milliseconds(),
		output: output,
		errorMsg: errorMsg,
		index: job.index,
	}
}

func runWithVoEmbed(module vox.Module) (string, error) {
	// Save bytecode to unique temp file
	tempFile := fmt.Sprintf("/tmp/vo_nostd_%d.vob", time.Now().UnixNano())
	err := vox.SaveBytecodeBinary(module, tempFile)
	if err != nil {
		return "", err
	}

	// Run vo-embed with the bytecode
	cmd := exec.Command("target/debug/vo-embed", []string{tempFile})
	output, err := cmd.CombinedOutput()
	outputStr := string(output)

	// Clean up temp file
	_ = os.Remove(tempFile)

	if err != nil {
		return outputStr, err
	}

	// Check for success marker
	if !strings.Contains(outputStr, "[VO:OK]") {
		return outputStr, errors.New("vo-embed did not output [VO:OK]")
	}

	return outputStr, nil
}

func runShouldFailTest(job TestJob, start time.Time) TestResult {
	var err error
	if strings.HasSuffix(job.file, ".vo") {
		_, err = vox.CompileFile(job.file)
	} else {
		_, err = vox.CompileDir(job.file)
	}

	errMsg := ""
	if err != nil {
		errMsg = err.Error()
	}

	passed := err != nil
	if passed && strings.HasSuffix(job.file, ".vo") {
		expected := expectedErrorSubstrings(job.file)
		if len(expected) > 0 {
			passed = matchesAllSubstrings(errMsg, expected)
		}
	}

	return TestResult{
		file: job.file,
		mode: "should_fail",
		passed: passed,
		skipped: false,
		elapsedMs: time.Since(start).Milliseconds(),
		output: "",
		errorMsg: errMsg,
		index: job.index,
	}
}

func runSingleFile(file string, mode string, verbose bool, configs map[string]TestConfig) int {
	fmt.Println("[VO-TEST] Running single file: " + file)
	
	// Determine full path - relative paths are under lang/test_data/
	testPath := file
	if !strings.HasPrefix(file, "/") && !strings.HasPrefix(file, "lang/test_data/") {
		testPath = "lang/test_data/" + file
	}

	// Check if file exists
	if _, err := os.Stat(testPath); err != nil {
		fmt.Println("Error: file not found: " + testPath)
		fmt.Println("Hint: use relative path under lang/test_data/, e.g., net/net_conn.vo")
		return 1
	}

	relPath := file
	if strings.HasPrefix(file, "lang/test_data/") {
		relPath = file[len("lang/test_data/"):]
	}
	config := configs[relPath]
	if config.shouldFail {
		job := TestJob{
			file: testPath,
			mode: "compile",
			shouldFail: true,
			gcDebug: false,
		}
		result := runShouldFailTest(job, time.Now())
		printSingleResult(result, verbose)
		if !result.passed {
			return 1
		}
		return 0
	}

	runVM := mode == "vm" || mode == "both"
	runJIT := mode == "jit" || mode == "both"
	runNoStd := mode == "nostd"

	failed := false

	if runNoStd {
		job := TestJob{
			file: testPath,
			mode: "nostd",
			shouldFail: false,
			gcDebug: false,
		}
		result := runSingleTest(job, verbose)
		printSingleResult(result, verbose)
		if !result.passed {
			failed = true
		}
	}

	if runVM {
		job := TestJob{
			file: testPath,
			mode: "vm",
			shouldFail: false,
			gcDebug: strings.Contains(file, "gc_"),
		}
		result := runSingleTest(job, verbose)
		printSingleResult(result, verbose)
		if !result.passed {
			failed = true
		}
	}

	if runJIT {
		job := TestJob{
			file: testPath,
			mode: "jit",
			shouldFail: false,
			gcDebug: strings.Contains(file, "gc_"),
		}
		result := runSingleTest(job, verbose)
		printSingleResult(result, verbose)
		if !result.passed {
			failed = true
		}
	}

	if failed {
		return 1
	}
	return 0
}


func printSingleResult(result TestResult, verbose bool) {
	status := statusSymbol(result)
	fmt.Println(status + " " + result.file + " ["+result.mode+"] ("+formatDuration(result.elapsedMs)+")")
	
	// Single file test: always show output
	if result.output != "" {
		_, _ = os.Stdout.WriteString(result.output)
	}
	
	if !result.passed && result.errorMsg != "" {
		fmt.Println("  Error: " + result.errorMsg)
	}
}

func printProgress(result TestResult, current int, total int) {
	// Printing carriage-return progress interacts badly with test stdout in logs.
	// Use periodic newline progress instead.
	if current != total && current%50 != 0 {
		return
	}

	status := statusSymbol(result)
	
	// Extract filename only
	file := result.file
	if idx := strings.LastIndex(file, "/"); idx >= 0 {
		file = file[idx+1:]
	}
	
	writeProgress("  " + status + " " + file + " [" + result.mode + "] (" + formatDuration(result.elapsedMs) + ") [" + strconv.Itoa(current) + "/" + strconv.Itoa(total) + "]\n")
}

func formatDuration(ms int64) string {
	if ms < 10 {
		return "<10ms"
	} else if ms < 1000 {
		return strconv.FormatInt(int(ms), 10) + "ms"
	} else {
		sec := ms / 1000
		return strconv.FormatInt(int(sec), 10) + "s"
	}
}

func calculateStats(results []TestResult) TestStats {
	stats := TestStats{
		failedTests: []string{},
	}

	for _, r := range results {
		if r.skipped {
			if r.mode == "vm" {
				stats.vmSkipped++
			} else if r.mode == "jit" {
				stats.jitSkipped++
			} else if r.mode == "nostd" {
				stats.nostdSkipped++
			}
			continue
		}

		if r.passed {
			if r.mode == "vm" || r.mode == "should_fail" {
				stats.vmPassed++
			} else if r.mode == "jit" {
				stats.jitPassed++
			} else if r.mode == "nostd" {
				stats.nostdPassed++
			}
		} else {
			if r.mode == "vm" || r.mode == "should_fail" {
				stats.vmFailed++
			} else if r.mode == "jit" {
				stats.jitFailed++
			} else if r.mode == "nostd" {
				stats.nostdFailed++
			}
			stats.failedTests = append(stats.failedTests, displayPath(r.file)+" ["+r.mode+"]")
		}
	}

	return stats
}

func printResults(stats TestStats, verbose bool) {
	totalPassed := stats.vmPassed + stats.jitPassed + stats.nostdPassed
	totalFailed := stats.vmFailed + stats.jitFailed + stats.nostdFailed

	fmt.Println("")
	if len(stats.failedTests) > 0 {
		fmt.Println(colorize("Failed:", ansiRed+ansiBold))
		for _, msg := range stats.failedTests {
			fmt.Println("  " + colorize("✗", ansiRed) + " " + msg)
		}
		fmt.Println("")
	}

	top := "╔══════════════════════════════════════════════════════════╗"
	title := "║                   Vo Test Results                        ║"
	sep := "╠══════════════════════════════════════════════════════════╣"
	bottom := "╚══════════════════════════════════════════════════════════╝"

	fmt.Println(colorize(top, ansiCyan))
	fmt.Println(colorize("║", ansiCyan) + colorize("                   Vo Test Results                        ", ansiBold) + colorize("║", ansiCyan))
	fmt.Println(colorize(sep, ansiCyan))

	vmLine := colorize("║", ansiCyan) + "  VM:    " + colorize(pad3(stats.vmPassed)+" passed", ansiGreen) + "  " + colorize(pad3(stats.vmFailed)+" failed", ansiRed) + "  " + colorize(pad3(stats.vmSkipped)+" skipped", ansiYellow) + "              " + colorize("║", ansiCyan)
	jitLine := colorize("║", ansiCyan) + "  JIT:   " + colorize(pad3(stats.jitPassed)+" passed", ansiGreen) + "  " + colorize(pad3(stats.jitFailed)+" failed", ansiRed) + "  " + colorize(pad3(stats.jitSkipped)+" skipped", ansiYellow) + "              " + colorize("║", ansiCyan)
	nostdLine := colorize("║", ansiCyan) + "  NOSTD: " + colorize(pad3(stats.nostdPassed)+" passed", ansiGreen) + "  " + colorize(pad3(stats.nostdFailed)+" failed", ansiRed) + "  " + colorize(pad3(stats.nostdSkipped)+" skipped", ansiYellow) + "              " + colorize("║", ansiCyan)
	fmt.Println(vmLine)
	fmt.Println(jitLine)
	fmt.Println(nostdLine)

	fmt.Println(colorize(sep, ansiCyan))
	totalLine := colorize("║", ansiCyan) + "  Total: " + colorize(pad3(totalPassed)+" passed", ansiGreen) + "  " + colorize(pad3(totalFailed)+" failed", ansiRed) + "                           " + colorize("║", ansiCyan)
	fmt.Println(totalLine)
	fmt.Println(colorize(bottom, ansiCyan))
}

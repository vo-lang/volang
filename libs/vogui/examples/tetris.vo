// Tetris Game - demonstrates timers, global key handler, grid rendering
package main

import (
	"fmt"
	"vogui"
)

// ============ Constants ============

const Rows = 20
const Cols = 10
const CellSize = 25

// ============ Types ============

type Point struct {
	X int
	Y int
}

type Piece struct {
	Type  int
	Rot   int
	X     int
	Y     int
	Cells []Point
}

type State struct {
	Grid     []int
	Score    int
	Level    int
	GameOver bool
	Paused   bool
	Current  Piece
	TimerID  int
	RngState int
}

var pieceColors = []string{
	"#1a1a2e", "#00f0f0", "#0000f0", "#f0a000",
	"#f0f000", "#00f000", "#a000f0", "#f00000",
}

var shapeI = []Point{{-1, 0}, {0, 0}, {1, 0}, {2, 0}}
var shapeJ = []Point{{-1, -1}, {-1, 0}, {0, 0}, {1, 0}}
var shapeL = []Point{{1, -1}, {-1, 0}, {0, 0}, {1, 0}}
var shapeO = []Point{{0, 0}, {1, 0}, {0, 1}, {1, 1}}
var shapeS = []Point{{0, 0}, {1, 0}, {-1, 1}, {0, 1}}
var shapeT = []Point{{0, 0}, {-1, 0}, {1, 0}, {0, -1}}
var shapeZ = []Point{{-1, 0}, {0, 0}, {0, 1}, {1, 1}}

// ============ App ============

func main() {
	vogui.SetGlobalKeyHandler(handleKey)
	vogui.Run(vogui.App{
		Init: initGame,
		View: view,
	})
}

func initGame() any {
	s := &State{
		Grid:     make([]int, Rows*Cols),
		Level:    1,
		RngState: 12345,
	}
	spawnPiece(s)
	s.TimerID = vogui.SetInterval(func(state any) {
		tick(state.(*State))
	}, 500)
	return s
}

// ============ Logic ============

func tick(s *State) {
	if s.GameOver || s.Paused {
		return
	}
	if canMove(s, s.Current, 0, 1) {
		s.Current.Y++
	} else {
		lockPiece(s)
		clearLines(s)
		spawnPiece(s)
		if !canMove(s, s.Current, 0, 0) {
			s.GameOver = true
		}
	}
}

func handleKey(state any, key string) {
	s := state.(*State)
	if s.GameOver {
		if key == "Enter" {
			restart(s)
		}
		return
	}
	if key == "p" || key == "P" {
		s.Paused = !s.Paused
		return
	}
	if s.Paused {
		return
	}
	switch key {
	case "ArrowLeft":
		if canMove(s, s.Current, -1, 0) {
			s.Current.X--
		}
	case "ArrowRight":
		if canMove(s, s.Current, 1, 0) {
			s.Current.X++
		}
	case "ArrowDown":
		if canMove(s, s.Current, 0, 1) {
			s.Current.Y++
		}
	case "ArrowUp":
		rotatePiece(s)
	case " ":
		dropPiece(s)
	}
}

func restart(s *State) {
	s.Grid = make([]int, Rows*Cols)
	s.Score = 0
	s.Level = 1
	s.GameOver = false
	s.Paused = false
	spawnPiece(s)
}

func spawnPiece(s *State) {
	t := rand(s) % 7
	s.Current = Piece{Type: t, X: Cols/2 - 1, Cells: getCells(t, 0)}
}

func getCells(t int, rot int) []Point {
	var base []Point
	switch t {
	case 0:
		base = shapeI
	case 1:
		base = shapeJ
	case 2:
		base = shapeL
	case 3:
		base = shapeO
	case 4:
		base = shapeS
	case 5:
		base = shapeT
	case 6:
		base = shapeZ
	}
	cells := make([]Point, 4)
	for i, p := range base {
		x, y := p.X, p.Y
		for r := 0; r < rot; r++ {
			x, y = -y, x
		}
		cells[i] = Point{x, y}
	}
	return cells
}

func rotatePiece(s *State) {
	newRot := (s.Current.Rot + 1) % 4
	p := s.Current
	p.Rot = newRot
	p.Cells = getCells(s.Current.Type, newRot)
	if canMove(s, p, 0, 0) {
		s.Current = p
	} else if canMove(s, p, 1, 0) {
		s.Current = p
		s.Current.X++
	} else if canMove(s, p, -1, 0) {
		s.Current = p
		s.Current.X--
	}
}

func canMove(s *State, p Piece, dx int, dy int) bool {
	for _, cell := range p.Cells {
		nx := p.X + cell.X + dx
		ny := p.Y + cell.Y + dy
		if nx < 0 || nx >= Cols || ny >= Rows {
			return false
		}
		if ny >= 0 && s.Grid[ny*Cols+nx] != 0 {
			return false
		}
	}
	return true
}

func lockPiece(s *State) {
	c := s.Current.Type + 1
	for _, cell := range s.Current.Cells {
		nx := s.Current.X + cell.X
		ny := s.Current.Y + cell.Y
		if ny >= 0 && ny < Rows && nx >= 0 && nx < Cols {
			s.Grid[ny*Cols+nx] = c
		}
	}
}

func clearLines(s *State) {
	lines := 0
	for y := Rows - 1; y >= 0; y-- {
		full := true
		for x := 0; x < Cols; x++ {
			if s.Grid[y*Cols+x] == 0 {
				full = false
				break
			}
		}
		if full {
			lines++
			for ky := y; ky > 0; ky-- {
				for kx := 0; kx < Cols; kx++ {
					s.Grid[ky*Cols+kx] = s.Grid[(ky-1)*Cols+kx]
				}
			}
			for kx := 0; kx < Cols; kx++ {
				s.Grid[kx] = 0
			}
			y++
		}
	}
	if lines > 0 {
		s.Score += lines * 100 * s.Level
	}
}

func dropPiece(s *State) {
	for canMove(s, s.Current, 0, 1) {
		s.Current.Y++
	}
	lockPiece(s)
	clearLines(s)
	spawnPiece(s)
	if !canMove(s, s.Current, 0, 0) {
		s.GameOver = true
	}
}

func rand(s *State) int {
	s.RngState = (s.RngState*1103515245 + 12345) % 2147483648
	if s.RngState < 0 {
		s.RngState = -s.RngState
	}
	return s.RngState
}

// ============ View ============

func view(state any) vogui.Node {
	s := state.(*State)
	return vogui.Center(
		vogui.Column(
			vogui.Row(
				vogui.H2("TETRIS").Fg("#a000f0"),
				vogui.Spacer(),
				vogui.Column(
					vogui.Text("Score: "+fmt.Sprint(s.Score)).Font(16).Bold(),
					vogui.Text("Level: "+fmt.Sprint(s.Level)).Font(12),
				),
			).W(CellSize * Cols),
			renderGrid(s),
			vogui.Text("Arrows: move/rotate | Space: drop | P: pause").Font(12).Fg("#666"),
			vogui.Show(s.GameOver,
				vogui.Center(
					vogui.Column(
						vogui.H2("GAME OVER").Fg("#f00"),
						vogui.Text("Final Score: "+fmt.Sprint(s.Score)),
						vogui.Button("Restart (Enter)", vogui.On(func(s *State) { restart(s) })).
							Bg("#a000f0").Fg("#fff"),
					).P(20).Bg("rgba(0,0,0,0.8)").Rounded(10).Gap(12),
				).Style("position", "absolute").
					Style("top", "0").Style("left", "0").
					Style("right", "0").Style("bottom", "0"),
			),
		).Style("position", "relative").Gap(8),
	).P(24)
}

func renderGrid(s *State) vogui.Node {
	displayGrid := make([]int, Rows*Cols)
	copyGrid(displayGrid, s.Grid)
	if !s.GameOver {
		c := s.Current.Type + 1
		for _, cell := range s.Current.Cells {
			nx := s.Current.X + cell.X
			ny := s.Current.Y + cell.Y
			if ny >= 0 && ny < Rows && nx >= 0 && nx < Cols {
				displayGrid[ny*Cols+nx] = c
			}
		}
	}
	var cells []vogui.Node
	for i := 0; i < Rows*Cols; i++ {
		cells = append(cells, vogui.Div().
			W(CellSize).H(CellSize).
			Bg(pieceColors[displayGrid[i]]).
			Border("1px solid rgba(255,255,255,0.1)"))
	}
	return vogui.Grid(Cols, cells...).Gap(0).Bg("#000").Border("2px solid #333")
}

func copyGrid(dst []int, src []int) {
	for i := 0; i < len(src); i++ {
		dst[i] = src[i]
	}
}

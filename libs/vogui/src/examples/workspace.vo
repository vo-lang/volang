// Personal Workspace - A comprehensive productivity app
// Demonstrates most VoGUI components and features
package main

import "fmt"
import "gui"

// ============ Types ============

type State struct {
	// Navigation
	ActiveTab string // "dashboard", "tasks", "pomodoro", "finance", "notes", "settings"
	
	// Tasks
	Tasks          []Task
	TaskFilter     string // "all", "active", "completed"
	TaskSearch     string
	ShowTaskModal  bool
	EditingTask    *Task
	NewTaskTitle   string
	NewTaskDueDate string
	NewTaskPriority string
	
	// Pomodoro
	PomodoroTime     int  // seconds remaining
	PomodoroRunning  bool
	PomodoroMode     string // "work", "break"
	PomodoroCount    int    // completed pomodoros today
	PomodoroWorkMin  int
	PomodoroBreakMin int
	TimerID          int
	
	// Finance
	Transactions     []Transaction
	ShowAddTxModal   bool
	NewTxAmount      int
	NewTxCategory    string
	NewTxNote        string
	NewTxIsExpense   bool
	FinanceMonth     int
	
	// Notes
	Notes         []Note
	ActiveNoteIdx int
	NoteSearch    string
	ShowNoteModal bool
	NewNoteTitle  string
	
	// Settings
	ShowSettings    bool
	DarkMode        bool
	NotifySound     bool
	AccentColor     string
}

type Task struct {
	ID        int
	Title     string
	Completed bool
	Priority  string // "low", "medium", "high"
	DueDate   string
	Category  string
}

type Transaction struct {
	ID       int
	Amount   int
	Category string
	Note     string
	IsExpense bool
	Date     string
}

type Note struct {
	ID      int
	Title   string
	Content string
	Updated string
}

// ============ Actions ============

// Navigation
func setTab(s *State, tab string) {
	s.ActiveTab = tab
}

// Task Actions
func addTask(s *State) {
	if s.NewTaskTitle == "" {
		return
	}
	task := Task{
		ID:       len(s.Tasks) + 1,
		Title:    s.NewTaskTitle,
		Priority: s.NewTaskPriority,
		DueDate:  s.NewTaskDueDate,
	}
	if task.Priority == "" {
		task.Priority = "medium"
	}
	s.Tasks = append(s.Tasks, task)
	s.NewTaskTitle = ""
	s.NewTaskDueDate = ""
	s.NewTaskPriority = ""
	s.ShowTaskModal = false
}

func toggleTask(s *State, idx int) {
	if idx >= 0 && idx < len(s.Tasks) {
		s.Tasks[idx].Completed = !s.Tasks[idx].Completed
	}
}

func deleteTask(s *State, idx int) {
	if idx >= 0 && idx < len(s.Tasks) {
		s.Tasks = append(s.Tasks[:idx], s.Tasks[idx+1:]...)
	}
}

func setTaskFilter(s *State, filter string) {
	s.TaskFilter = filter
}

func setTaskSearch(s *State, search string) {
	s.TaskSearch = search
}

func openTaskModal(s *State) {
	s.ShowTaskModal = true
}

func closeTaskModal(s *State) {
	s.ShowTaskModal = false
	s.NewTaskTitle = ""
}

func setNewTaskTitle(s *State, title string) {
	s.NewTaskTitle = title
}

func setNewTaskDueDate(s *State, date string) {
	s.NewTaskDueDate = date
}

func setNewTaskPriority(s *State, priority string) {
	s.NewTaskPriority = priority
}

// Pomodoro Actions
func startPomodoro(s *State) {
	if s.PomodoroRunning {
		return
	}
	s.PomodoroRunning = true
	s.TimerID = gui.SetInterval(1000, pomodoroTick)
}

func pausePomodoro(s *State) {
	s.PomodoroRunning = false
	if s.TimerID > 0 {
		gui.ClearInterval(s.TimerID)
		s.TimerID = 0
	}
}

func resetPomodoro(s *State) {
	pausePomodoro(s)
	if s.PomodoroMode == "work" {
		s.PomodoroTime = s.PomodoroWorkMin * 60
	} else {
		s.PomodoroTime = s.PomodoroBreakMin * 60
	}
}

func pomodoroTick(state any) {
	s := state.(*State)
	if s.PomodoroTime > 0 {
		s.PomodoroTime--
	} else {
		pausePomodoro(s)
		if s.PomodoroMode == "work" {
			s.PomodoroCount++
			s.PomodoroMode = "break"
			s.PomodoroTime = s.PomodoroBreakMin * 60
		} else {
			s.PomodoroMode = "work"
			s.PomodoroTime = s.PomodoroWorkMin * 60
		}
	}
}

func setPomodoroWorkMin(s *State, min int) {
	s.PomodoroWorkMin = min
	if s.PomodoroMode == "work" && !s.PomodoroRunning {
		s.PomodoroTime = min * 60
	}
}

func setPomodoroBreakMin(s *State, min int) {
	s.PomodoroBreakMin = min
	if s.PomodoroMode == "break" && !s.PomodoroRunning {
		s.PomodoroTime = min * 60
	}
}

// Finance Actions
func openAddTxModal(s *State) {
	s.ShowAddTxModal = true
	s.NewTxIsExpense = true
	s.NewTxCategory = "food"
}

func closeAddTxModal(s *State) {
	s.ShowAddTxModal = false
	s.NewTxAmount = 0
	s.NewTxNote = ""
}

func addTransaction(s *State) {
	if s.NewTxAmount <= 0 {
		return
	}
	tx := Transaction{
		ID:        len(s.Transactions) + 1,
		Amount:    s.NewTxAmount,
		Category:  s.NewTxCategory,
		Note:      s.NewTxNote,
		IsExpense: s.NewTxIsExpense,
		Date:      "2026-01-21",
	}
	s.Transactions = append(s.Transactions, tx)
	closeAddTxModal(s)
}

func setTxAmount(s *State, amount int) {
	s.NewTxAmount = amount
}

func setTxCategory(s *State, cat string) {
	s.NewTxCategory = cat
}

func setTxNote(s *State, note string) {
	s.NewTxNote = note
}

func setTxIsExpense(s *State, isExpense bool) {
	s.NewTxIsExpense = isExpense
}

func deleteTx(s *State, idx int) {
	if idx >= 0 && idx < len(s.Transactions) {
		s.Transactions = append(s.Transactions[:idx], s.Transactions[idx+1:]...)
	}
}

// Note Actions
func addNote(s *State) {
	if s.NewNoteTitle == "" {
		return
	}
	note := Note{
		ID:      len(s.Notes) + 1,
		Title:   s.NewNoteTitle,
		Content: "",
		Updated: "2026-01-21",
	}
	s.Notes = append(s.Notes, note)
	s.ActiveNoteIdx = len(s.Notes) - 1
	s.NewNoteTitle = ""
	s.ShowNoteModal = false
}

func selectNote(s *State, idx int) {
	s.ActiveNoteIdx = idx
}

func updateNoteContent(s *State, content string) {
	if s.ActiveNoteIdx >= 0 && s.ActiveNoteIdx < len(s.Notes) {
		s.Notes[s.ActiveNoteIdx].Content = content
	}
}

func deleteNote(s *State, idx int) {
	if idx >= 0 && idx < len(s.Notes) {
		s.Notes = append(s.Notes[:idx], s.Notes[idx+1:]...)
		if s.ActiveNoteIdx >= len(s.Notes) {
			s.ActiveNoteIdx = len(s.Notes) - 1
		}
	}
}

func setNoteSearch(s *State, search string) {
	s.NoteSearch = search
}

func openNoteModal(s *State) {
	s.ShowNoteModal = true
}

func closeNoteModal(s *State) {
	s.ShowNoteModal = false
	s.NewNoteTitle = ""
}

func setNewNoteTitle(s *State, title string) {
	s.NewNoteTitle = title
}

// Settings Actions
func openSettings(s *State) {
	s.ShowSettings = true
}

func closeSettings(s *State) {
	s.ShowSettings = false
}

func toggleDarkMode(s *State, on bool) {
	s.DarkMode = on
}

func toggleNotifySound(s *State, on bool) {
	s.NotifySound = on
}

func setAccentColor(s *State, color string) {
	s.AccentColor = color
}

// ============ Views ============

func view(state any) gui.Node {
	s := state.(*State)
	return gui.Column(
		viewNav(s),
		gui.Divider(),
		viewContent(s),
		viewModals(s),
	).Style("height", "100vh")
}

func viewNav(s *State) gui.Node {
	return gui.Row(
		gui.H2("üè† Workspace").Style("margin", "0"),
		gui.Spacer(),
		gui.Nav(
			gui.NavItem("Dashboard", s.ActiveTab == "dashboard", gui.On(func(s *State) { setTab(s, "dashboard") })),
			gui.NavItem("Tasks", s.ActiveTab == "tasks", gui.On(func(s *State) { setTab(s, "tasks") })),
			gui.NavItem("Pomodoro", s.ActiveTab == "pomodoro", gui.On(func(s *State) { setTab(s, "pomodoro") })),
			gui.NavItem("Finance", s.ActiveTab == "finance", gui.On(func(s *State) { setTab(s, "finance") })),
			gui.NavItem("Notes", s.ActiveTab == "notes", gui.On(func(s *State) { setTab(s, "notes") })),
		),
		gui.Spacer(),
		gui.Tooltip("Settings", 
			gui.IconButton("settings", gui.On(openSettings)),
		),
	).Style("padding", "12px 24px").Style("align-items", "center")
}

func viewContent(s *State) gui.Node {
	switch s.ActiveTab {
	case "tasks":
		return viewTasks(s)
	case "pomodoro":
		return viewPomodoro(s)
	case "finance":
		return viewFinance(s)
	case "notes":
		return viewNotes(s)
	default:
		return viewDashboard(s)
	}
}

// ============ Dashboard ============

func viewDashboard(s *State) gui.Node {
	activeTasks := 0
	for _, t := range s.Tasks {
		if !t.Completed {
			activeTasks++
		}
	}
	
	totalExpense := 0
	totalIncome := 0
	for _, tx := range s.Transactions {
		if tx.IsExpense {
			totalExpense += tx.Amount
		} else {
			totalIncome += tx.Amount
		}
	}
	
	return gui.Scroll(gui.Column(
		gui.H1("Dashboard"),
		
		gui.Grid(3,
			gui.Card(
				gui.CardHeader("üìã Tasks"),
				gui.CardBody(
					gui.H2(fmt.Sprint(activeTasks) + " active"),
					gui.Progress(float64(len(s.Tasks)-activeTasks) / float64(max(len(s.Tasks), 1))),
					gui.Text("Completed: ", len(s.Tasks)-activeTasks, "/", len(s.Tasks)),
				),
			),
			gui.Card(
				gui.CardHeader("üçÖ Pomodoro"),
				gui.CardBody(
					gui.H2(fmt.Sprint(s.PomodoroCount) + " today"),
					gui.Text(formatTime(s.PomodoroTime)),
					gui.IfElse(s.PomodoroRunning,
						gui.Badge("Running"),
						gui.Badge("Paused"),
					),
				),
			),
			gui.Card(
				gui.CardHeader("üí∞ Balance"),
				gui.CardBody(
					gui.H2("¬•" + fmt.Sprint(totalIncome-totalExpense)),
					gui.Row(
						gui.Tag("‚Üë ¬•" + fmt.Sprint(totalIncome)),
						gui.Tag("‚Üì ¬•" + fmt.Sprint(totalExpense)),
					).Style("gap", "8px"),
				),
			),
		).Style("gap", "16px"),
		
		gui.Panel("Recent Tasks",
			gui.IfElse(len(s.Tasks) == 0,
				gui.Text("No tasks yet"),
				gui.List(viewRecentTasks(s)...),
			),
		),
		
		gui.Panel("Quick Actions",
			gui.Row(
				gui.Button("+ New Task", gui.On(openTaskModal)),
				gui.Button("Start Focus", gui.On(func(s *State) {
					setTab(s, "pomodoro")
					startPomodoro(s)
				})),
				gui.Button("+ Add Expense", gui.On(openAddTxModal)),
			).Style("gap", "12px"),
		),
	).Style("padding", "24px").Style("gap", "24px"))
}

func viewRecentTasks(s *State) []gui.Node {
	var items []gui.Node
	count := 0
	for i, task := range s.Tasks {
		if count >= 5 {
			break
		}
		if !task.Completed {
			items = append(items, viewTaskItem(s, task, i))
			count++
		}
	}
	return items
}

// ============ Tasks ============

func viewTasks(s *State) gui.Node {
	return gui.Column(
		gui.Row(
			gui.H1("Tasks"),
			gui.Spacer(),
			gui.SearchInput(s.TaskSearch, gui.OnValue(setTaskSearch), gui.On(func(s *State) {})),
			gui.Button("+ Add Task", gui.On(openTaskModal)),
		).Style("align-items", "center").Style("gap", "12px"),
		
		gui.Tabs(
			tabIndex(s.TaskFilter),
			[]gui.TabItem{
				{Label: "All", Content: gui.Empty()},
				{Label: "Active", Content: gui.Empty()},
				{Label: "Completed", Content: gui.Empty()},
			},
			gui.OnSlider(func(s *State, idx int) {
				filters := []string{"all", "active", "completed"}
				s.TaskFilter = filters[idx]
			}),
		),
		
		gui.Scroll(gui.Column(
			viewFilteredTasks(s)...,
		).Style("gap", "8px")),
	).Style("padding", "24px").Style("gap", "16px").Style("height", "calc(100vh - 60px)")
}

func tabIndex(filter string) int {
	switch filter {
	case "active":
		return 1
	case "completed":
		return 2
	default:
		return 0
	}
}

func viewFilteredTasks(s *State) []gui.Node {
	var items []gui.Node
	for i, task := range s.Tasks {
		if s.TaskSearch != "" && !contains(task.Title, s.TaskSearch) {
			continue
		}
		if s.TaskFilter == "active" && task.Completed {
			continue
		}
		if s.TaskFilter == "completed" && !task.Completed {
			continue
		}
		items = append(items, viewTaskItem(s, task, i))
	}
	if len(items) == 0 {
		items = append(items, gui.Center(gui.Text("No tasks found")))
	}
	return items
}

func viewTaskItem(s *State, task Task, idx int) gui.Node {
	color := "#f59e0b"
	if task.Priority == "high" {
		color = "#ef4444"
	} else if task.Priority == "low" {
		color = "#22c55e"
	}
	
	return gui.Card(
		gui.Row(
			gui.Checkbox(task.Completed, gui.OnIntChecked(toggleTaskChecked, idx)),
			gui.Column(
				gui.IfElse(task.Completed,
					gui.Text(task.Title).Style("text-decoration", "line-through").Style("color", "#888"),
					gui.Strong(task.Title),
				),
				gui.Row(
					gui.If(task.DueDate != "", gui.Tag("üìÖ "+task.DueDate)),
					gui.Badge(task.Priority).Style("background", color),
				).Style("gap", "8px"),
			).Style("flex", "1"),
			gui.Dropdown(
				[]gui.DropdownItem{
					{Label: "Delete", OnClick: gui.OnInt(deleteTask, idx), Icon: "trash"},
				},
				gui.IconButton("more-vertical", gui.On(func(s *State) {})),
			),
		).Style("align-items", "center").Style("gap", "12px"),
	)
}

func toggleTaskChecked(s *State, idx int, checked bool) {
	toggleTask(s, idx)
}

// ============ Pomodoro ============

func viewPomodoro(s *State) gui.Node {
	progress := 1.0 - float64(s.PomodoroTime)/float64(s.PomodoroWorkMin*60)
	if s.PomodoroMode == "break" {
		progress = 1.0 - float64(s.PomodoroTime)/float64(s.PomodoroBreakMin*60)
	}
	
	return gui.Center(gui.Column(
		gui.H1("üçÖ Pomodoro Timer"),
		
		gui.Card(
			gui.CardBody(
				gui.Center(gui.Column(
					gui.IfElse(s.PomodoroMode == "work",
						gui.Badge("FOCUS TIME"),
						gui.Badge("BREAK TIME").Style("background", "#22c55e"),
					),
					gui.H1(formatTime(s.PomodoroTime)).Style("font-size", "72px").Style("margin", "24px 0"),
					gui.Progress(progress).Style("width", "300px").Style("height", "8px"),
					gui.Row(
						gui.IfElse(s.PomodoroRunning,
							gui.Button("‚è∏ Pause", gui.On(pausePomodoro)),
							gui.Button("‚ñ∂ Start", gui.On(startPomodoro)),
						),
						gui.Button("‚Ü∫ Reset", gui.On(resetPomodoro)),
					).Style("gap", "12px").Style("margin-top", "24px"),
				).Style("gap", "16px")),
			),
		).Style("width", "400px"),
		
		gui.Row(
			gui.Text("Today's Pomodoros: "),
			gui.Badge(fmt.Sprint(s.PomodoroCount)),
		).Style("margin-top", "24px"),
		
		gui.Accordion(
			[]gui.AccordionItem{
				{
					Title: "‚öôÔ∏è Timer Settings",
					Content: gui.Column(
						gui.FormField("Work Duration (min)",
							gui.Slider(s.PomodoroWorkMin, 5, 60, gui.OnSlider(setPomodoroWorkMin)),
						),
						gui.FormField("Break Duration (min)",
							gui.Slider(s.PomodoroBreakMin, 1, 30, gui.OnSlider(setPomodoroBreakMin)),
						),
					).Style("gap", "16px"),
					Open: false,
				},
			},
			gui.OnSlider(func(s *State, idx int) {}),
		).Style("width", "400px").Style("margin-top", "24px"),
	).Style("gap", "16px"))
}

func formatTime(seconds int) string {
	m := seconds / 60
	s := seconds % 60
	ms := ""
	ss := ""
	if m < 10 {
		ms = "0"
	}
	if s < 10 {
		ss = "0"
	}
	return ms + fmt.Sprint(m) + ":" + ss + fmt.Sprint(s)
}

// ============ Finance ============

func viewFinance(s *State) gui.Node {
	totalExpense := 0
	totalIncome := 0
	for _, tx := range s.Transactions {
		if tx.IsExpense {
			totalExpense += tx.Amount
		} else {
			totalIncome += tx.Amount
		}
	}
	
	return gui.Column(
		gui.Row(
			gui.H1("üí∞ Finance"),
			gui.Spacer(),
			gui.Button("+ Add Transaction", gui.On(openAddTxModal)),
		).Style("align-items", "center"),
		
		gui.Grid(3,
			gui.Card(
				gui.CardBody(
					gui.Text("Income"),
					gui.H2("¬•" + fmt.Sprint(totalIncome)).Style("color", "#22c55e"),
				),
			),
			gui.Card(
				gui.CardBody(
					gui.Text("Expense"),
					gui.H2("¬•" + fmt.Sprint(totalExpense)).Style("color", "#ef4444"),
				),
			),
			gui.Card(
				gui.CardBody(
					gui.Text("Balance"),
					gui.H2("¬•" + fmt.Sprint(totalIncome-totalExpense)),
				),
			),
		).Style("gap", "16px"),
		
		gui.Panel("Transaction History",
			gui.IfElse(len(s.Transactions) == 0,
				gui.Center(gui.Text("No transactions yet")),
				gui.Table(
					gui.TableHead(
						gui.TableRow(
							gui.TableHeaderCell("Type"),
							gui.TableHeaderCell("Category"),
							gui.TableHeaderCell("Amount"),
							gui.TableHeaderCell("Note"),
							gui.TableHeaderCell("Date"),
							gui.TableHeaderCell(""),
						),
					),
					gui.TableBody(viewTxRows(s)...),
				),
			),
		),
	).Style("padding", "24px").Style("gap", "24px")
}

func viewTxRows(s *State) []gui.Node {
	var rows []gui.Node
	for i, tx := range s.Transactions {
		typeIcon := "‚Üë"
		typeColor := "#22c55e"
		if tx.IsExpense {
			typeIcon = "‚Üì"
			typeColor = "#ef4444"
		}
		rows = append(rows, gui.TableRow(
			gui.TableCell(gui.Text(typeIcon).Style("color", typeColor)),
			gui.TableCell(gui.Text(tx.Category)),
			gui.TableCell(gui.Text("¬•" + fmt.Sprint(tx.Amount)).Style("color", typeColor)),
			gui.TableCell(gui.Text(tx.Note)),
			gui.TableCell(gui.Text(tx.Date)),
			gui.TableCell(gui.IconButton("trash", gui.OnInt(deleteTx, i))),
		))
	}
	return rows
}

// ============ Notes ============

func viewNotes(s *State) gui.Node {
	return gui.Row(
		gui.Column(
			gui.Row(
				gui.H3("Notes"),
				gui.Spacer(),
				gui.IconButton("plus", gui.On(openNoteModal)),
			).Style("align-items", "center"),
			gui.SearchInput(s.NoteSearch, gui.OnValue(setNoteSearch), gui.On(func(s *State) {})),
			gui.Scroll(gui.List(viewNoteList(s)...)),
		).Style("width", "250px").Style("padding", "16px").Style("gap", "12px").Style("border-right", "1px solid #eee"),
		
		gui.IfElse(s.ActiveNoteIdx >= 0 && s.ActiveNoteIdx < len(s.Notes),
			viewNoteEditor(s),
			gui.Center(gui.Text("Select a note or create new one")),
		),
	).Style("height", "calc(100vh - 60px)")
}

func viewNoteList(s *State) []gui.Node {
	var items []gui.Node
	for i, note := range s.Notes {
		if s.NoteSearch != "" && !contains(note.Title, s.NoteSearch) {
			continue
		}
		idx := i
		bg := "transparent"
		if s.ActiveNoteIdx == i {
			bg = "#f0f0f0"
		}
		items = append(items, gui.ListItem(
			gui.Row(
				gui.Column(
					gui.Strong(note.Title),
					gui.Text(note.Updated).Style("font-size", "12px").Style("color", "#888"),
				).Style("flex", "1"),
				gui.If(s.ActiveNoteIdx == i, gui.Badge("‚óè")),
			).Style("cursor", "pointer").AddHandler(gui.On(func(s *State) { selectNote(s, idx) })),
		).Style("padding", "8px").Style("background", bg))
	}
	return items
}

func viewNoteEditor(s *State) gui.Node {
	if s.ActiveNoteIdx < 0 || s.ActiveNoteIdx >= len(s.Notes) {
		return gui.Empty()
	}
	note := s.Notes[s.ActiveNoteIdx]
	return gui.Column(
		gui.Row(
			gui.H2(note.Title),
			gui.Spacer(),
			gui.IconButton("trash", gui.OnInt(deleteNote, s.ActiveNoteIdx)),
		).Style("align-items", "center"),
		gui.TextArea(note.Content, gui.OnValue(updateNoteContent)).
			Style("flex", "1").Style("resize", "none").Style("font-family", "monospace"),
	).Style("flex", "1").Style("padding", "24px").Style("gap", "16px")
}

// ============ Modals ============

func viewModals(s *State) gui.Node {
	return gui.Fragment(
		viewTaskModal(s),
		viewAddTxModal(s),
		viewNoteModal(s),
		viewSettingsDrawer(s),
	)
}

func viewTaskModal(s *State) gui.Node {
	return gui.Modal(s.ShowTaskModal, gui.On(closeTaskModal),
		gui.ModalHeader("Add New Task"),
		gui.ModalBody(
			gui.Form(gui.On(addTask),
				gui.FormField("Title",
					gui.Input(s.NewTaskTitle, gui.OnValue(setNewTaskTitle)),
				),
				gui.FormField("Due Date",
					gui.DateInput(s.NewTaskDueDate, gui.OnValue(setNewTaskDueDate)),
				),
				gui.FormField("Priority",
					gui.Select(s.NewTaskPriority, []string{"low", "medium", "high"}, gui.OnValue(setNewTaskPriority)),
				),
			),
		),
		gui.ModalFooter(
			gui.Row(
				gui.Button("Cancel", gui.On(closeTaskModal)),
				gui.Button("Add Task", gui.On(addTask)),
			).Style("gap", "12px"),
		),
	)
}

func viewAddTxModal(s *State) gui.Node {
	return gui.Modal(s.ShowAddTxModal, gui.On(closeAddTxModal),
		gui.ModalHeader("Add Transaction"),
		gui.ModalBody(
			gui.Form(gui.On(addTransaction),
				gui.FormField("Type",
					gui.Row(
						gui.CheckboxLabel("Expense", s.NewTxIsExpense, gui.OnChecked(setTxIsExpense)),
					),
				),
				gui.FormField("Amount",
					gui.NumberInput(s.NewTxAmount, gui.OnSlider(setTxAmount)),
				),
				gui.FormField("Category",
					gui.Select(s.NewTxCategory, []string{"food", "transport", "shopping", "entertainment", "bills", "salary", "other"}, gui.OnValue(setTxCategory)),
				),
				gui.FormField("Note",
					gui.Input(s.NewTxNote, gui.OnValue(setTxNote)),
				),
			),
		),
		gui.ModalFooter(
			gui.Row(
				gui.Button("Cancel", gui.On(closeAddTxModal)),
				gui.Button("Add", gui.On(addTransaction)),
			).Style("gap", "12px"),
		),
	)
}

func viewNoteModal(s *State) gui.Node {
	return gui.Modal(s.ShowNoteModal, gui.On(closeNoteModal),
		gui.ModalHeader("New Note"),
		gui.ModalBody(
			gui.FormField("Title",
				gui.Input(s.NewNoteTitle, gui.OnValue(setNewNoteTitle)),
			),
		),
		gui.ModalFooter(
			gui.Row(
				gui.Button("Cancel", gui.On(closeNoteModal)),
				gui.Button("Create", gui.On(addNote)),
			).Style("gap", "12px"),
		),
	)
}

func viewSettingsDrawer(s *State) gui.Node {
	return gui.Drawer(s.ShowSettings, "right", gui.On(closeSettings),
		gui.Column(
			gui.H2("‚öôÔ∏è Settings"),
			gui.Divider(),
			gui.FormSection("Appearance",
				gui.FormField("Dark Mode",
					gui.Switch(s.DarkMode, gui.OnChecked(toggleDarkMode)),
				),
				gui.FormField("Accent Color",
					gui.ColorInput(s.AccentColor, gui.OnValue(setAccentColor)),
				),
			),
			gui.FormSection("Notifications",
				gui.FormField("Sound",
					gui.Switch(s.NotifySound, gui.OnChecked(toggleNotifySound)),
				),
			),
			gui.Spacer(),
			gui.Button("Close", gui.On(closeSettings)),
		).Style("padding", "24px").Style("gap", "16px").Style("height", "100%"),
	)
}

// ============ Helpers ============

func contains(s string, sub string) bool {
	for i := 0; i <= len(s)-len(sub); i++ {
		if s[i:i+len(sub)] == sub {
			return true
		}
	}
	return false
}

func max(a int, b int) int {
	if a > b {
		return a
	}
	return b
}

// ============ Main ============

func main() {
	gui.Run(gui.App{
		Init: func() any {
			return &State{
				ActiveTab:        "dashboard",
				TaskFilter:       "all",
				PomodoroTime:     25 * 60,
				PomodoroMode:     "work",
				PomodoroWorkMin:  25,
				PomodoroBreakMin: 5,
				ActiveNoteIdx:    -1,
				AccentColor:      "#3b82f6",
				NotifySound:      true,
			}
		},
		View: view,
	})
}

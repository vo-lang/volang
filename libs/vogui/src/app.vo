// Application lifecycle and entry point.
package gui

import "encoding/json"

// App defines the application structure.
type App struct {
	Init   func() any
	View   func(state any) Node
	Routes []Route
}

// Internal state
var currentState any
var currentApp App
var eventChan = make(chan Event, 100)
var doneChan = make(chan struct{})

// Run initializes the application and starts the event loop.
func Run(app App) {
	currentApp = app
	currentState = app.Init()
	render()

	// Register callback that sends events to channel
	registerEventHandler(sendEvent)

	// Start event loop goroutine
	go eventLoop()

	// Block main goroutine forever
	<-doneChan
}

// updatePath is called by Navigate to trigger a re-render.
func updatePath(path string) {
	render()
}

// sendEvent is called by Rust - just sends to channel
func sendEvent(handlerID int, payload string) {
	eventChan <- Event{HandlerID: handlerID, Payload: payload}
}

// eventLoop processes events from channel
func eventLoop() {
	for event := range eventChan {
		switch event.HandlerID {
		case eventIDTimer:
			var p struct{ Id int }
			json.Unmarshal([]byte(event.Payload), &p)
			invokeTimerHandler(p.Id, currentState)
		case eventIDGlobalKey:
			var p struct{ Key string }
			json.Unmarshal([]byte(event.Payload), &p)
			err := invokeGlobalKeyHandler(currentState, p.Key)
			if err != nil {
				println("VoGUI: global key handler error:", err)
			}
		case eventIDNavigation:
			// popstate: just re-render
		default:
			err := invokeHandler(currentState, event.HandlerID, event.Payload)
			if err != nil {
				println("VoGUI: handler error:", err)
			}
		}
		render()
	}
}

func render() {
	resetHandlers()
	
	var tree Node
	if len(currentApp.Routes) > 0 {
		// Routing mode
		path := GetCurrentPath()
		matched := false
		for _, route := range currentApp.Routes {
			params, ok := matchRoute(route.Path, path)
			if ok {
				tree = route.View(currentState, params)
				matched = true
				break
			}
		}
		if !matched {
			tree = Text("404 Not Found: " + path)
		}
	} else {
		// Single view mode
		tree = currentApp.View(currentState)
	}

	output := map[string]any{
		"type":     "render",
		"tree":     tree,
		"handlers": handlerMetas,
	}
	data, err := json.Marshal(output)
	if err != nil {
		println("VoGUI marshal error:", err)
		return
	}
	emitRender(string(data))
}

// ============ Extern Declarations ============
// These functions are implemented in WASM layer.

// registerEventHandler registers the event handler callback.
// Rust will call this callback for each event from JS.
func registerEventHandler(handler func(handlerID int, payload string))

// emitRender sends render output to the JS runtime.
func emitRender(json string)

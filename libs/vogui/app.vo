// Application lifecycle and entry point.
package vogui

import "encoding/json"

// App defines the application structure.
type App struct {
	Init   func() any
	View   func(state any) Node
	Routes []Route
}

// Internal state
var currentState any
var currentApp App

// Run initializes the application and starts the event loop.
// The main fiber blocks on waitForEvent() and processes events inline â€”
// no separate fiber is spawned per event.
func Run(app App) {
	currentApp = app
	currentState = app.Init()
	render()

	for {
		handlerID, payload := waitForEvent()
		processEvent(Event{HandlerID: handlerID, Payload: payload})
	}
}

// updatePath is called by Navigate to trigger a re-render.
func updatePath(path string) {
	render()
}

// timerPayload is the JSON structure for timer events.
type timerPayload struct {
	Id int
}

// keyPayload is the JSON structure for global key events.
type keyPayload struct {
	Key string
}

// animFramePayload is the JSON structure for animation frame events.
type animFramePayload struct {
	Id int
}

// gameLoopPayload is the JSON structure for game loop events.
type gameLoopPayload struct {
	Dt float64
}

func processEvent(event Event) {
	switch event.HandlerID {
	case eventIDTimer:
		var p timerPayload
		json.Unmarshal([]byte(event.Payload), &p)
		invokeTimerHandler(p.Id, currentState)
	case eventIDGlobalKey:
		var p keyPayload
		json.Unmarshal([]byte(event.Payload), &p)
		err := invokeGlobalKeyHandler(currentState, p.Key)
		if err != nil {
			println("VoGUI: global key handler error:", err)
		}
	case eventIDNavigation:
		// popstate: just re-render
	case eventIDAnimFrame:
		var p animFramePayload
		json.Unmarshal([]byte(event.Payload), &p)
		invokeAnimFrameHandler(p.Id, currentState)
	case eventIDGameLoop:
		var p gameLoopPayload
		json.Unmarshal([]byte(event.Payload), &p)
		invokeGameLoopHandler(currentState, p.Dt)
	default:
		err := invokeHandler(currentState, event.HandlerID, event.Payload)
		if err != nil {
			println("VoGUI: handler error:", err)
		}
	}
	render()
}

func render() {
	resetHandlers()

	var tree Node
	if len(currentApp.Routes) > 0 {
		path := GetCurrentPath()
		matched := false
		for _, route := range currentApp.Routes {
			params, ok := matchRoute(route.Path, path)
			if ok {
				tree = route.View(currentState, params)
				matched = true
				break
			}
		}
		if !matched {
			tree = Text("404 Not Found: " + path)
		}
	} else {
		tree = currentApp.View(currentState)
	}

	// Clean up components that are no longer in the tree
	cleanupDestroyedComponents()

	styles := flushPendingStyles()
	canvasCmds := flushPendingCanvasCommands()
	data := encodeRender(renderGen, tree, styles, canvasCmds)
	emitRenderBinary(data)
}

// ============ Extern Declarations ============

// waitForEvent blocks the current fiber until the host sends an event.
// Returns (handlerID, payload) when woken.
func waitForEvent() (int, string)

func emitRenderBinary(data []byte)

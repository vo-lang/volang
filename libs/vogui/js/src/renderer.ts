// VoGUI v2 Renderer - Converts VoNode tree to DOM using morphdom.

import morphdom from 'morphdom';
import { VoNode, VoHandler, RenderMessage, RendererConfig, StylePropertyMap, toCssValue, WidgetFactory, WidgetInstance } from './types';
import { executeCanvasBatch } from './canvas';

// =============================================================================
// State
// =============================================================================

let currentGen = 0;
let currentHandlers: VoHandler[] = [];
let currentConfig: RendererConfig | null = null;

// Event emit helper — guards optional onEvent
function emit(handlerId: number, payload: string): void {
    currentConfig?.onEvent?.(handlerId, payload);
}

// Ref registry: named DOM references
const refRegistry = new Map<string, HTMLElement>();

// Widget registry and instances
const widgetRegistry = new Map<string, WidgetFactory>();
const widgetInstances = new Map<string, WidgetInstance>();

// Portal containers
const portalContainers = new Map<string, HTMLElement>();

// Component subtree cache: componentID → root DOM element
// Used by __comp__/__cached__ optimization to skip morphdom for unchanged trees.
const compSubtrees = new Map<number, HTMLElement>();

// =============================================================================
// Public API
// =============================================================================

/** Register an external widget factory. */
export function registerWidget(name: string, factory: WidgetFactory): void {
    widgetRegistry.set(name, factory);
}

/** Get a ref element by name. */
export function getRef(name: string): HTMLElement | null {
    return refRegistry.get(name) ?? null;
}

/** Destroy all widget instances. */
export function destroyAllWidgets(): void {
    widgetInstances.forEach((instance) => instance.destroy?.());
    widgetInstances.clear();
}

/** Inject dynamic styles generated by Vo Style combinators. */
let dynamicStyleEl: HTMLStyleElement | null = null;

function injectDynamicStyles(styles: string[]): void {
    if (!styles || styles.length === 0) return;
    if (!dynamicStyleEl) {
        dynamicStyleEl = document.createElement('style');
        dynamicStyleEl.id = 'vogui-dynamic-styles';
        document.head.appendChild(dynamicStyleEl);
    }
    // Append CSS text — each string may contain multiple rules
    dynamicStyleEl.textContent += styles.join('\n');
}

/** Main render function. Called with container, parsed RenderMessage, and RendererConfig. */
export function render(
    container: HTMLElement,
    msg: RenderMessage | null,
    config: RendererConfig
): void {
    if (!msg || !msg.tree) {
        container.innerHTML = '';
        return;
    }
    // Apply baseline reset via inline style (highest specificity) so preview
    // content never inherits IDE host app dark-theme variables.
    container.style.color = '#0f172a';
    container.style.fontFamily = 'system-ui, -apple-system, sans-serif';
    container.style.fontSize = '14px';
    container.style.setProperty('--vo-text', '#0f172a');
    container.style.setProperty('--vo-text-muted', '#64748b');
    container.style.setProperty('--vo-bg', '#ffffff');
    container.style.setProperty('--vo-surface', '#f8fafc');
    container.style.setProperty('--vo-border', '#e2e8f0');
    container.dataset.voStyled = '1';
    if (msg.styles) {
        injectDynamicStyles(msg.styles);
    }
    _renderTree(container, msg.tree, msg.gen, msg.handlers || [], config);
    // Execute canvas draw commands after DOM is updated
    if (msg.canvas) {
        for (const batch of msg.canvas) {
            executeCanvasBatch(batch, refRegistry);
        }
    }
}

/** Setup a global keyboard handler that forwards key events to the event callback. */
export function setupKeyHandler(config: RendererConfig): () => void {
    const handler = (event: KeyboardEvent) => {
        const target = event.target as HTMLElement;
        const tag = target.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
        if (!config.onEvent) return;
        // Prevent browser default (scrolling, etc.) for navigation/game keys
        if (event.key === 'ArrowUp' || event.key === 'ArrowDown' ||
            event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
            event.key === ' ' || event.key === 'PageUp' || event.key === 'PageDown') {
            event.preventDefault();
        }
        emit(-2, JSON.stringify({ key: event.key }));
    };
    document.addEventListener('keydown', handler, { capture: true });
    return () => document.removeEventListener('keydown', handler, { capture: true });
}

function _renderTree(
    container: HTMLElement,
    tree: VoNode,
    gen: number,
    handlers: VoHandler[],
    config: RendererConfig
): void {
    currentGen = gen;
    currentHandlers = handlers;
    currentConfig = config;

    const newEl = renderNode(tree);
    if (!newEl) return;

    if (!container.firstElementChild) {
        container.appendChild(newEl);
    } else {
        morphdom(container.firstElementChild, newEl, {
            onBeforeElUpdated(fromEl, toEl) {
                // Cached component subtree: toEl is a same-tag placeholder with
                // data-vo-cached set by renderNode(__cached__).  Keep fromEl intact.
                if (toEl.dataset.voCached) {
                    return false;
                }

                // Preserve external widget containers
                if (fromEl.hasAttribute('data-widget-id')) {
                    const widgetId = fromEl.getAttribute('data-widget-id')!;
                    const instance = widgetInstances.get(widgetId);
                    if (instance?.update) {
                        const propsStr = toEl.getAttribute('data-widget-props');
                        if (propsStr) {
                            try { instance.update(JSON.parse(propsStr)); } catch {}
                        }
                    }
                    return false; // don't touch widget DOM
                }

                // Preserve canvas elements
                if (fromEl.tagName === 'CANVAS' && toEl.tagName === 'CANVAS') {
                    // Update attributes but preserve canvas context
                    const w = toEl.getAttribute('width');
                    const h = toEl.getAttribute('height');
                    if (w) fromEl.setAttribute('width', w);
                    if (h) fromEl.setAttribute('height', h);
                    // Re-point refRegistry to the kept element (fromEl).
                    // applyCommonProps already ran on toEl and set refRegistry to toEl,
                    // but morphdom discards toEl — so we must redirect to the real DOM node.
                    const refName = fromEl.dataset.ref;
                    if (refName) refRegistry.set(refName, fromEl);
                    return false;
                }

                return true;
            },
            onNodeDiscarded(node) {
                if (node instanceof HTMLElement) {
                    // Clean up cached component subtrees
                    const vcid = node.dataset.vcid;
                    if (vcid) compSubtrees.delete(Number(vcid));

                    // Clean up refs
                    const refName = node.dataset.ref;
                    if (refName) refRegistry.delete(refName);

                    // Clean up widgets
                    const widgetId = node.getAttribute('data-widget-id');
                    if (widgetId) {
                        widgetInstances.get(widgetId)?.destroy?.();
                        widgetInstances.delete(widgetId);
                    }
                }
            },
            getNodeKey(node) {
                if (node instanceof HTMLElement) {
                    // data-vcid gives component roots a stable identity across renders;
                    // data-key is the user-supplied list key.
                    return node.dataset.vcid || node.getAttribute('data-key') || undefined;
                }
                return undefined;
            },
        });
    }
}

// =============================================================================
// Node Rendering
// =============================================================================

function renderNode(node: VoNode): HTMLElement | Text | null {
    if (!node || !node.type) return null;

    const type = node.type;
    const props = node.props || {};
    const children = node.children || [];

    // Fragment: render children only
    if (type === 'Fragment') {
        const frag = document.createElement('div');
        frag.style.display = 'contents';
        for (const child of children) {
            const el = renderNode(child);
            if (el) frag.appendChild(el);
        }
        return frag;
    }

    // Portal: render into named container
    if (type === 'vo-portal') {
        const portalName = props['portalName'] as string;
        const container = getOrCreatePortal(portalName);
        // Create a placeholder in the normal tree
        const placeholder = document.createElement('div');
        placeholder.style.display = 'none';
        placeholder.setAttribute('data-portal', portalName);
        // Render children into portal container
        container.innerHTML = '';
        for (const child of children) {
            const el = renderNode(child);
            if (el) container.appendChild(el);
        }
        return placeholder;
    }

    // Component subtree markers
    if (type === '__comp__') {
        // Render the child subtree normally — morphdom diffs this tree on every update.
        // We only tag the root with data-vcid so morphdom can key-match it across renders.
        const cid = props['_cid'] as number;
        const child = children[0];
        const childEl = child ? renderNode(child) : document.createElement('div');
        const wrapper = childEl instanceof HTMLElement ? childEl : document.createElement('div');
        wrapper.dataset.vcid = String(cid);
        delete wrapper.dataset.voCached;  // ensure not marked as skip
        compSubtrees.set(cid, wrapper);
        return wrapper;
    }
    if (type === '__cached__') {
        // Component subtree is unchanged. Return a same-tag placeholder tagged with
        // data-vo-cached so onBeforeElUpdated skips the real element without replacing it.
        const cid = props['_cid'] as number;
        const stored = compSubtrees.get(cid);
        const tag = stored ? stored.tagName.toLowerCase() : 'div';
        const ph = document.createElement(tag);
        ph.dataset.vcid = String(cid);
        ph.dataset.voCached = 'true';
        return ph;
    }

    // UnsafeHTML
    if (type === 'vo-unsafe-html') {
        const div = document.createElement('div');
        div.innerHTML = props['html'] as string || '';
        applyCommonProps(div, props);
        return div;
    }

    // External Widget
    if (type === 'vo-external-widget') {
        return renderExternalWidget(props);
    }

    // Canvas
    if (type === 'Canvas') {
        return renderCanvas(props);
    }

    // Managed components: self-contained DOM builders
    if (type === 'vo-tabs')            return renderTabs(props);
    if (type === 'vo-accordion')       return renderAccordion(props);
    if (type === 'vo-breadcrumb')      return renderBreadcrumb(props);
    if (type === 'vo-pagination')      return renderPagination(props);
    if (type === 'vo-steps')           return renderSteps(props);
    if (type === 'vo-checkbox')        return renderCheckbox(props);
    if (type === 'vo-switch')          return renderSwitch(props);
    if (type === 'vo-radio')           return renderRadio(props);
    if (type === 'vo-slider')          return renderSlider(props);
    if (type === 'vo-tooltip')         return renderTooltip(props, children);
    if (type === 'vo-popover')         return renderPopover(props, children);
    if (type === 'vo-dropdown-menu')   return renderDropdownMenu(props, children);
    if (type === 'vo-hover-card')      return renderHoverCard(props, children);
    if (type === 'vo-collapsible')     return renderCollapsible(props, children);
    if (type === 'vo-combobox')        return renderCombobox(props, children);
    if (type === 'vo-context-menu')    return renderContextMenu(props, children);

    // Create the DOM element
    const el = createElementForType(type, props);
    if (!el) return null;

    // Apply properties
    applyProps(el, type, props);

    // Apply common props (class, style, ref, key, attrs, events)
    applyCommonProps(el, props);

    // Attach event handlers — must be after applyCommonProps so .On() bindings
    // and click/change handlers are both registered before listenersAttached marks el.
    attachHandlers(el, props);

    // Render children
    for (const child of children) {
        const childEl = renderNode(child);
        if (childEl) el.appendChild(childEl);
    }

    return el;
}

// =============================================================================
// Element Creation
// =============================================================================

function createElementForType(type: string, props: Record<string, any>): HTMLElement | null {
    switch (type) {
        // Standard HTML elements
        case 'div': return document.createElement('div');
        case 'button': return document.createElement('button');
        case 'input': return document.createElement('input');
        case 'textarea': return document.createElement('textarea');
        case 'select': return document.createElement('select');
        case 'form': return document.createElement('form');
        case 'a': return document.createElement('a');
        case 'img': return document.createElement('img');
        case 'video': return document.createElement('video');
        case 'h1': return document.createElement('h1');
        case 'h2': return document.createElement('h2');
        case 'h3': return document.createElement('h3');
        case 'h4': return document.createElement('h4');
        case 'h5': return document.createElement('h5');
        case 'h6': return document.createElement('h6');
        case 'p': return document.createElement('p');
        case 'code': return document.createElement('code');
        case 'pre': return document.createElement('pre');
        case 'strong': return document.createElement('strong');
        case 'em': return document.createElement('em');
        case 'ul': return document.createElement('ul');
        case 'ol': return document.createElement('ol');
        case 'li': return document.createElement('li');
        case 'table': return document.createElement('table');
        case 'thead': return document.createElement('thead');
        case 'tbody': return document.createElement('tbody');
        case 'tr': return document.createElement('tr');
        case 'td': return document.createElement('td');
        case 'th': return document.createElement('th');
        case 'nav': return document.createElement('nav');

        // VoGUI components (rendered as div with class)
        case 'vo-text': return createVoElement('span', 'vo-text');
        case 'vo-row': return createVoElement('div', 'vo-row');
        case 'vo-column': return createVoElement('div', 'vo-column');
        case 'vo-center': return createVoElement('div', 'vo-center');
        case 'vo-stack': return createVoElement('div', 'vo-stack');
        case 'vo-grid': return createVoElement('div', 'vo-grid');
        case 'vo-spacer': return createVoElement('div', 'vo-spacer');
        case 'vo-divider': return createVoElement('hr', 'vo-divider');
        case 'vo-scroll': return createVoElement('div', 'vo-scroll');
        case 'vo-wrap': return createVoElement('div', 'vo-wrap');
        case 'vo-badge': return createVoElement('span', 'vo-badge');
        case 'vo-tag': return createVoElement('span', 'vo-tag');
        case 'vo-progress': return createVoElement('div', 'vo-progress');
        case 'vo-spinner': return createVoElement('div', 'vo-spinner');
        case 'vo-alert': return createVoElement('div', 'vo-alert');
        case 'vo-avatar': return createVoElement('div', 'vo-avatar');
        case 'vo-icon': return createVoElement('span', 'vo-icon');
        case 'vo-card': return createVoElement('div', 'vo-card');
        case 'vo-panel': return createVoElement('div', 'vo-panel');
        case 'vo-slider': return createVoElement('div', 'vo-slider');
        case 'vo-checkbox': {
            const label = document.createElement('label');
            label.classList.add('vo-checkbox');
            const chkInput = document.createElement('input');
            chkInput.type = 'checkbox';
            const chkSpan = document.createElement('span');
            label.appendChild(chkInput);
            label.appendChild(chkSpan);
            return label;
        }
        case 'vo-switch': {
            const label = document.createElement('label');
            label.classList.add('vo-switch');
            const swInput = document.createElement('input');
            swInput.type = 'checkbox';
            const swSpan = document.createElement('span');
            label.appendChild(swInput);
            label.appendChild(swSpan);
            return label;
        }
        case 'vo-radio': return createVoElement('label', 'vo-radio');
        case 'vo-form-field': return createVoElement('div', 'vo-form-field');
        case 'vo-form-error': return createVoElement('div', 'vo-form-error');
        case 'vo-form-help': return createVoElement('div', 'vo-form-help');
        case 'vo-form-section': return createVoElement('div', 'vo-form-section');
        case 'vo-nav-item': return createVoElement('a', 'vo-nav-item');
        case 'vo-nav-link': return createVoElement('a', 'vo-nav-link');
        case 'vo-nav-divider': return createVoElement('hr', 'vo-nav-divider');
        case 'vo-nav-group': return createVoElement('div', 'vo-nav-group');
        case 'vo-sidebar': return createVoElement('aside', 'vo-sidebar');
        case 'vo-sidebar-item': return createVoElement('a', 'vo-sidebar-item');
        case 'vo-sidebar-section': return createVoElement('div', 'vo-sidebar-section');

        // Managed components
        case 'vo-dialog': return createVoElement('dialog', 'vo-dialog');
        case 'vo-dialog-title': return createVoElement('h2', 'vo-dialog-title');
        case 'vo-dialog-content': return createVoElement('div', 'vo-dialog-content');
        case 'vo-dialog-actions': return createVoElement('div', 'vo-dialog-actions');
        case 'vo-drawer': return createVoElement('div', 'vo-drawer');
        case 'vo-tooltip': return createVoElement('div', 'vo-tooltip');
        case 'vo-popover': return createVoElement('div', 'vo-popover');
        case 'vo-dropdown-menu': return createVoElement('div', 'vo-dropdown-menu');
        case 'vo-menu-item': return createVoElement('div', 'vo-menu-item');
        case 'vo-menu-divider': return createVoElement('hr', 'vo-menu-divider');
        case 'vo-hover-card': return createVoElement('div', 'vo-hover-card');
        case 'vo-collapsible': return createVoElement('div', 'vo-collapsible');
        case 'vo-combobox': return createVoElement('div', 'vo-combobox');
        case 'vo-combobox-option': return createVoElement('div', 'vo-combobox-option');
        case 'vo-context-menu': return createVoElement('div', 'vo-context-menu');
        case 'vo-tabs': return createVoElement('div', 'vo-tabs');
        case 'vo-accordion': return createVoElement('div', 'vo-accordion');
        case 'vo-breadcrumb': return createVoElement('nav', 'vo-breadcrumb');
        case 'vo-pagination': return createVoElement('nav', 'vo-pagination');
        case 'vo-steps': return createVoElement('div', 'vo-steps');
        case 'vo-transition': return createVoElement('div', 'vo-transition');
        case 'vo-transition-group': return createVoElement('div', 'vo-transition-group');

        default:
            console.warn(`VoGUI: unknown node type "${type}"`);
            return document.createElement('div');
    }
}

function createVoElement(tag: string, className: string): HTMLElement {
    const el = document.createElement(tag);
    el.classList.add(className);
    return el;
}

// =============================================================================
// Property Application
// =============================================================================

function applyProps(el: HTMLElement, type: string, props: Record<string, any>): void {
    // Text content
    if (props['textContent'] != null) {
        if (type === 'vo-checkbox' || type === 'vo-switch') {
            // Setting el.textContent on the label would destroy the inner <input>.
            // Update the <span> child instead.
            const span = el.querySelector('span');
            if (span) span.textContent = String(props['textContent']);
        } else {
            el.textContent = String(props['textContent']);
        }
    }

    // Checkbox / Switch — checked state and onChange on the inner <input>
    if (type === 'vo-checkbox' || type === 'vo-switch') {
        const chkEl = el.querySelector('input') as HTMLInputElement | null;
        if (chkEl) {
            const wantChecked = Boolean(props['checked']);
            chkEl.checked = wantChecked;
            // Keep attribute in sync so morphdom sees the change.
            if (wantChecked) chkEl.setAttribute('checked', ''); else chkEl.removeAttribute('checked');
            if (props['onChange'] != null) {
                chkEl.dataset.voChange = String(props['onChange']);
                if (!listenersAttached.has(chkEl)) {
                    chkEl.addEventListener('change', () => {
                        const id = chkEl.dataset.voChange;
                        if (id != null) emit(Number(id), JSON.stringify({ Checked: chkEl.checked }));
                    });
                    listenersAttached.add(chkEl);
                }
            }
        }
    }

    // Input-specific props
    if (el instanceof HTMLInputElement) {
        if (props['type']) el.type = props['type'];
        if (props['value'] != null) el.value = String(props['value']);
        if (props['placeholder']) el.placeholder = props['placeholder'];
        if (props['disabled']) el.disabled = true;
        if (props['readOnly']) el.readOnly = true;
    }
    if (el instanceof HTMLTextAreaElement) {
        if (props['value'] != null) el.value = String(props['value']);
        if (props['placeholder']) el.placeholder = props['placeholder'];
        if (props['rows']) el.rows = Number(props['rows']);
        if (props['disabled']) el.disabled = true;
    }

    // Select element
    if (el instanceof HTMLSelectElement && props['options']) {
        const options = props['options'] as Array<{label: string, value: string}>;
        const currentValue = String(props['value'] ?? '');
        for (const opt of options) {
            const optEl = document.createElement('option');
            optEl.value = opt.value;
            optEl.textContent = opt.label;
            if (opt.value === currentValue) optEl.selected = true;
            el.appendChild(optEl);
        }
    }

    // Link props
    if (el instanceof HTMLAnchorElement) {
        if (props['href']) el.href = props['href'];
    }

    // Image props
    if (el instanceof HTMLImageElement) {
        if (props['src']) el.src = props['src'];
        if (props['alt']) el.alt = props['alt'];
    }

    // Video props
    if (el instanceof HTMLVideoElement) {
        if (props['src']) el.src = props['src'];
    }

    // Grid cols
    if (type === 'vo-grid' && props['cols']) {
        el.style.gridTemplateColumns = `repeat(${props['cols']}, 1fr)`;
    }

    // Progress bar
    if (type === 'vo-progress') {
        const value = props['value'] || 0;
        const max = props['max'] || 100;
        const pct = Math.round((value / max) * 100);
        el.setAttribute('data-value', String(value));
        el.setAttribute('data-max', String(max));
        const bar = document.createElement('div');
        bar.classList.add('vo-progress-bar');
        bar.style.width = `${pct}%`;
        el.appendChild(bar);
    }

    // Alert type
    if (type === 'vo-alert' && props['alertType']) {
        el.setAttribute('data-type', props['alertType']);
    }

    // Avatar
    if (type === 'vo-avatar' && props['src']) {
        const img = document.createElement('img');
        img.src = props['src'];
        el.appendChild(img);
    }

    // Variant
    if (props['variant']) {
        el.setAttribute('data-variant', props['variant']);
    }

    // Label (form fields)
    if (type === 'vo-form-field' && props['label']) {
        const label = document.createElement('label');
        label.textContent = props['label'];
        el.insertBefore(label, el.firstChild);
    }

    // Title (form section)
    if (type === 'vo-form-section' && props['title']) {
        const h = document.createElement('h3');
        h.textContent = props['title'];
        el.insertBefore(h, el.firstChild);
    }

    // Active state
    if (props['active']) {
        el.classList.add('active');
    }

    // Disabled state
    if (props['disabled'] && !(el instanceof HTMLInputElement) && !(el instanceof HTMLTextAreaElement)) {
        el.classList.add('disabled');
        el.setAttribute('aria-disabled', 'true');
    }

    // Icon
    if (props['icon'] && type !== 'vo-icon') {
        const icon = document.createElement('span');
        icon.classList.add('vo-icon');
        icon.setAttribute('data-icon', props['icon']);
        el.insertBefore(icon, el.firstChild);
    }
    if (type === 'vo-icon' && props['name']) {
        el.setAttribute('data-icon', props['name']);
    }

    // Dialog management (P6: Vo props authoritative)
    if (type === 'vo-dialog' && el instanceof HTMLDialogElement) {
        if (props['open']) {
            if (!el.open) el.showModal();
        } else {
            if (el.open) el.close();
        }
    }

    // Drawer
    if (type === 'vo-drawer') {
        if (props['side']) el.setAttribute('data-side', props['side']);
        if (props['open']) el.classList.add('open');
    }

    // Collapsible
    if (type === 'vo-collapsible' && props['defaultOpen']) {
        el.classList.add('open');
    }

}

// =============================================================================
// Common Props (class, style, ref, key, attrs, events)
// =============================================================================

function applyCommonProps(el: HTMLElement, props: Record<string, any>): void {
    // CSS classes
    if (props['class']) {
        const classes = (props['class'] as string).split(' ').filter(c => c);
        for (const cls of classes) {
            el.classList.add(cls);
        }
    }

    // Inline styles
    if (props['style'] && typeof props['style'] === 'object') {
        const style = props['style'] as Record<string, any>;
        for (const [key, val] of Object.entries(style)) {
            const cssProp = StylePropertyMap[key] || key;
            el.style.setProperty(cssProp, toCssValue(val, cssProp));
        }
    }

    // Ref
    if (props['ref']) {
        const refName = props['ref'] as string;
        el.dataset.ref = refName;
        refRegistry.set(refName, el);
    }

    // Key
    if (props['key']) {
        el.setAttribute('data-key', String(props['key']));
    }

    // HTML attributes (ARIA, data-*, role, etc.)
    if (props['attrs'] && typeof props['attrs'] === 'object') {
        const attrs = props['attrs'] as Record<string, any>;
        for (const [key, val] of Object.entries(attrs)) {
            if (typeof val === 'boolean') {
                if (val) el.setAttribute(key, '');
                else el.removeAttribute(key);
            } else {
                el.setAttribute(key, String(val));
            }
        }
    }

    // Arbitrary DOM events via node.On(event, handler)
    if (props['events'] && typeof props['events'] === 'object') {
        const events = props['events'] as Record<string, any>;
        for (const [eventName, handler] of Object.entries(events)) {
            if (handler && typeof handler === 'object' && 'iD' in handler) {
                const h = handler as VoHandler;
                const attrKey = `data-vo-event-${eventName}`;
                // Store full handler meta as JSON attribute so morphdom updates it.
                el.setAttribute(attrKey, JSON.stringify({ id: h.iD, key: h.keyFilter ?? '', mods: h.modifiers ?? [] }));
                if (!listenersAttached.has(el)) {
                    // Listener reads meta from attribute at fire time, not from closure.
                    el.addEventListener(eventName, (e: Event) => {
                        const raw = el.getAttribute(attrKey);
                        if (!raw) return;
                        const meta = JSON.parse(raw) as { id: number; key: string; mods: string[] };
                        if (meta.key && e instanceof KeyboardEvent && e.key !== meta.key) return;
                        if (meta.mods.includes('prevent')) e.preventDefault();
                        if (meta.mods.includes('stop')) e.stopPropagation();
                        emit(meta.id, '{}');
                    });
                }
            }
        }
    }

    // Transition
    if (props['transition']) {
        el.setAttribute('data-transition', props['transition']);
    }
}

// =============================================================================
// Event Handling
// =============================================================================

// Track which elements have already had listeners attached (first render only).
// morphdom keeps existing DOM elements across renders; we must not add duplicate
// listeners. Instead we store the handler ID in a data-vo-* attribute and make
// each listener read the attribute dynamically so morphdom's attribute updates
// always give us the current render's handler index.
const listenersAttached = new WeakSet<HTMLElement>();

function attachHandlers(el: HTMLElement, props: Record<string, any>): void {
    const config = currentConfig;
    if (!config) return;

    const firstTime = !listenersAttached.has(el);

    // onClick
    if (props['onClick'] != null) {
        el.dataset.voClick = String(props['onClick']);
        if (firstTime) {
            el.addEventListener('click', () => {
                const id = el.dataset.voClick;
                if (id != null) emit(Number(id), '{}');
            });
        }
    }

    // onChange (for inputs/textarea/select)
    if (props['onChange'] != null) {
        el.dataset.voChange = String(props['onChange']);
        if (firstTime) {
            if (el instanceof HTMLInputElement) {
                if (el.type === 'checkbox') {
                    el.addEventListener('change', () => {
                        const id = el.dataset.voChange;
                        if (id != null) emit(Number(id), JSON.stringify({ Checked: el.checked }));
                    });
                } else {
                    el.addEventListener('input', () => {
                        const id = el.dataset.voChange;
                        if (id != null) emit(Number(id), JSON.stringify({ Value: el.value }));
                    });
                }
            } else if (el instanceof HTMLTextAreaElement) {
                el.addEventListener('input', () => {
                    const id = el.dataset.voChange;
                    if (id != null) emit(Number(id), JSON.stringify({ Value: el.value }));
                });
            } else if (el instanceof HTMLSelectElement) {
                el.addEventListener('change', () => {
                    const id = el.dataset.voChange;
                    if (id != null) emit(Number(id), JSON.stringify({ Value: el.value }));
                });
            }
        }
    }

    // onSubmit (for forms)
    if (props['onSubmit'] != null) {
        el.dataset.voSubmit = String(props['onSubmit']);
        if (firstTime) {
            el.addEventListener('submit', (e) => {
                e.preventDefault();
                const id = el.dataset.voSubmit;
                if (id != null) emit(Number(id), '{}');
            });
        }
    }

    // onClose (for dialog) — 'close' doesn't bubble; keep per-element listener.
    // Dialog elements are never reused across renders so stale IDs aren't an issue.
    if (props['onClose'] != null) {
        el.dataset.voClose = String(props['onClose']);
        if (firstTime && el instanceof HTMLDialogElement) {
            el.addEventListener('close', () => {
                const id = el.dataset.voClose;
                if (id != null) emit(Number(id), '{}');
            });
            el.addEventListener('click', (e) => {
                if (e.target === el) {
                    const id = el.dataset.voClose;
                    if (id != null) emit(Number(id), '{}');
                }
            });
        }
    }

    // onFiles
    if (props['onFiles'] != null) {
        el.dataset.voFiles = String(props['onFiles']);
        if (firstTime && el instanceof HTMLInputElement && el.type === 'file') {
            el.addEventListener('change', () => {
                const id = el.dataset.voFiles;
                if (id == null) return;
                const files: any[] = [];
                if (el.files) {
                    for (let i = 0; i < el.files.length; i++) {
                        const f = el.files[i];
                        files.push({ Name: f.name, Size: f.size, Type: f.type, Data: '' });
                    }
                }
                emit(Number(id), JSON.stringify({ Files: files }));
            });
        }
    }

    // onSelect (for combobox etc — not HTMLSelectElement)
    if (props['onSelect'] != null && !(el instanceof HTMLSelectElement)) {
        el.setAttribute('data-on-select', String(props['onSelect']));
    }

    if (firstTime) listenersAttached.add(el);
}

function attachEventListener(el: HTMLElement, eventName: string, handler: VoHandler): void {
    const config = currentConfig;
    if (!config) return;

    let listener = (e: Event) => {
        // Key filter
        if (handler.keyFilter && e instanceof KeyboardEvent) {
            if (e.key !== handler.keyFilter) return;
        }

        // Modifiers
        if (handler.modifiers) {
            for (const mod of handler.modifiers) {
                if (mod === 'prevent') e.preventDefault();
                if (mod === 'stop') e.stopPropagation();
            }
        }

        emit(handler.iD, '{}');
    };

    // Apply debounce/throttle modifiers
    if (handler.modifiers) {
        for (const mod of handler.modifiers) {
            if (mod.startsWith('debounce:')) {
                const ms = parseInt(mod.split(':')[1]);
                listener = debounce(listener, ms);
            }
            if (mod.startsWith('throttle:')) {
                const ms = parseInt(mod.split(':')[1]);
                listener = throttle(listener, ms);
            }
        }
    }

    const options: AddEventListenerOptions = {};
    if (handler.modifiers?.includes('once')) {
        options.once = true;
    }

    el.addEventListener(eventName, listener, options);
}

// =============================================================================
// External Widget Rendering
// =============================================================================

function renderExternalWidget(props: Record<string, any>): HTMLElement {
    const widgetType = props['widgetType'] as string;
    const widgetId = `widget-${widgetType}-${Math.random().toString(36).slice(2, 8)}`;

    const container = document.createElement('div');
    container.classList.add('vo-external-widget');
    container.setAttribute('data-widget-id', widgetId);
    container.setAttribute('data-widget-type', widgetType);
    container.setAttribute('data-widget-props', JSON.stringify(props));
    // Apply style, class, key, etc. from the Vo node (e.g. .Flex(1), .H("100%"))
    applyCommonProps(container, props);

    // Build the onEvent callback the widget can call to emit events back to Vo
    const onWidgetEvent = (payload: string) => {
        if (props['onWidget'] != null) {
            emit(props['onWidget'] as number, payload);
        }
    };
    (container as any).__voWidgetCallback = onWidgetEvent;

    const factory = widgetRegistry.get(widgetType);
    if (factory) {
        const instance = factory.create(container, props, onWidgetEvent);
        widgetInstances.set(widgetId, instance);
    }

    return container;
}

// =============================================================================
// Canvas Rendering
// =============================================================================

function renderCanvas(props: Record<string, any>): HTMLElement {
    const canvas = document.createElement('canvas');
    canvas.classList.add('vo-canvas');
    if (props['width']) canvas.width = props['width'];
    if (props['height']) canvas.height = props['height'];
    if (props['fullscreen']) {
        canvas.style.width = '100%';
        canvas.style.height = '100%';
    }
    applyCommonProps(canvas, props);
    return canvas;
}

// =============================================================================
// Portal Manager
// =============================================================================

function getOrCreatePortal(name: string): HTMLElement {
    let container = portalContainers.get(name);
    if (!container) {
        container = document.createElement('div');
        container.id = `vo-portal-${name}`;
        container.className = `vo-portal vo-portal-${name}`;
        document.body.appendChild(container);
        portalContainers.set(name, container);
    }
    return container;
}

// =============================================================================
// Utility Functions
// =============================================================================

function debounce(fn: Function, ms: number): any {
    let timer: any;
    return (...args: any[]) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), ms);
    };
}

function throttle(fn: Function, ms: number): any {
    let last = 0;
    return (...args: any[]) => {
        const now = Date.now();
        if (now - last >= ms) {
            last = now;
            fn(...args);
        }
    };
}

// =============================================================================
// Managed Component Renderers
// =============================================================================

function renderTabs(props: Record<string, any>): HTMLElement {
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-tabs';
    applyCommonProps(wrapper, props);

    const items = (props['items'] as any[]) || [];
    const activeIndex = (props['activeIndex'] as number) ?? 0;
    const handlerId = props['onChange'] as number | undefined;

    const header = document.createElement('div');
    header.className = 'vo-tabs-header';
    header.setAttribute('role', 'tablist');

    const contentArea = document.createElement('div');
    contentArea.className = 'vo-tabs-content';

    items.forEach((item: any, i: number) => {
        const label = String(item['label'] ?? '');
        const content = item['content'] as VoNode | undefined;
        const isActive = i === activeIndex;

        const btn = document.createElement('button');
        btn.className = 'vo-tab' + (isActive ? ' active' : '');
        btn.textContent = label;
        btn.setAttribute('role', 'tab');
        btn.setAttribute('aria-selected', String(isActive));
        btn.setAttribute('data-index', String(i));
        if (handlerId != null) {
            btn.setAttribute('data-vo-change', String(handlerId));
            btn.setAttribute('data-vo-value', String(i));
            if (!listenersAttached.has(btn)) {
                btn.addEventListener('click', () => {
                    const id = btn.getAttribute('data-vo-change');
                    const v = btn.getAttribute('data-vo-value');
                    if (id != null && v != null) {
                        emit(Number(id), JSON.stringify({ Value: Number(v) }));
                    }
                });
                listenersAttached.add(btn);
            }
        }
        header.appendChild(btn);

        const panel = document.createElement('div');
        panel.className = 'vo-tab-panel' + (isActive ? ' active' : '');
        panel.setAttribute('role', 'tabpanel');
        if (!isActive) panel.hidden = true;
        if (content) {
            const el = renderNode(content);
            if (el) panel.appendChild(el);
        }
        contentArea.appendChild(panel);
    });

    wrapper.appendChild(header);
    wrapper.appendChild(contentArea);
    return wrapper;
}

function renderAccordion(props: Record<string, any>): HTMLElement {
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-accordion';
    applyCommonProps(wrapper, props);

    const items = (props['items'] as any[]) || [];
    const openIndex = (props['openIndex'] as number) ?? -1;
    const handlerId = props['onChange'] as number | undefined;

    items.forEach((item: any, i: number) => {
        const title = String(item['title'] ?? '');
        const content = item['content'] as VoNode | undefined;
        const isOpen = i === openIndex;

        const itemEl = document.createElement('div');
        itemEl.className = 'vo-accordion-item' + (isOpen ? ' open' : '');

        const headerBtn = document.createElement('button');
        headerBtn.className = 'vo-accordion-header';
        headerBtn.setAttribute('aria-expanded', String(isOpen));

        const titleSpan = document.createElement('span');
        titleSpan.textContent = title;
        const chevron = document.createElement('span');
        chevron.className = 'vo-accordion-chevron';
        chevron.textContent = isOpen ? '▾' : '▸';
        headerBtn.appendChild(titleSpan);
        headerBtn.appendChild(chevron);

        const panel = document.createElement('div');
        panel.className = 'vo-accordion-panel';
        panel.hidden = !isOpen;
        if (content) {
            const el = renderNode(content);
            if (el) panel.appendChild(el);
        }

        if (handlerId != null) {
            // Toggle: if already open, emit -1 to close; else emit index to open.
            const nextIndex = openIndex === i ? -1 : i;
            headerBtn.setAttribute('data-vo-change', String(handlerId));
            headerBtn.setAttribute('data-vo-value', String(nextIndex));
            if (!listenersAttached.has(headerBtn)) {
                headerBtn.addEventListener('click', () => {
                    const id = headerBtn.getAttribute('data-vo-change');
                    const v = headerBtn.getAttribute('data-vo-value');
                    if (id != null && v != null) {
                        emit(Number(id), JSON.stringify({ Value: Number(v) }));
                    }
                });
                listenersAttached.add(headerBtn);
            }
        }

        itemEl.appendChild(headerBtn);
        itemEl.appendChild(panel);
        wrapper.appendChild(itemEl);
    });

    return wrapper;
}

function renderBreadcrumb(props: Record<string, any>): HTMLElement {
    const nav = document.createElement('nav');
    nav.className = 'vo-breadcrumb';
    nav.setAttribute('aria-label', 'breadcrumb');
    applyCommonProps(nav, props);

    const items = (props['items'] as any[]) || [];
    const ol = document.createElement('ol');

    items.forEach((item: any, i: number) => {
        const label = String(item['label'] ?? '');
        const href = String(item['href'] ?? '');
        const isLast = i === items.length - 1;

        if (i > 0) {
            const sep = document.createElement('li');
            sep.className = 'vo-breadcrumb-sep';
            sep.setAttribute('aria-hidden', 'true');
            sep.textContent = '/';
            ol.appendChild(sep);
        }

        const li = document.createElement('li');
        li.className = 'vo-breadcrumb-item' + (isLast ? ' current' : '');
        if (isLast) {
            li.textContent = label;
            li.setAttribute('aria-current', 'page');
        } else {
            const a = document.createElement('a');
            a.href = href;
            a.textContent = label;
            li.appendChild(a);
        }
        ol.appendChild(li);
    });

    nav.appendChild(ol);
    return nav;
}

function renderPagination(props: Record<string, any>): HTMLElement {
    const nav = document.createElement('nav');
    nav.className = 'vo-pagination';
    applyCommonProps(nav, props);

    const current = (props['current'] as number) ?? 1;
    const total = (props['total'] as number) ?? 1;
    const handlerId = props['onChange'] as number | undefined;

    const makeBtn = (label: string, page: number, disabled: boolean, active: boolean): HTMLButtonElement => {
        const btn = document.createElement('button');
        btn.className = 'vo-page-btn' + (active ? ' active' : '');
        btn.textContent = label;
        btn.disabled = disabled;
        if (!disabled && handlerId != null) {
            btn.setAttribute('data-vo-change', String(handlerId));
            btn.setAttribute('data-vo-value', String(page));
            if (!listenersAttached.has(btn)) {
                btn.addEventListener('click', () => {
                    const id = btn.getAttribute('data-vo-change');
                    const v = btn.getAttribute('data-vo-value');
                    if (id != null && v != null) {
                        emit(Number(id), JSON.stringify({ Value: Number(v) }));
                    }
                });
                listenersAttached.add(btn);
            }
        }
        return btn;
    };

    nav.appendChild(makeBtn('«', current - 1, current <= 1, false));

    const start = Math.max(1, current - 2);
    const end = Math.min(total, current + 2);
    if (start > 1) {
        nav.appendChild(makeBtn('1', 1, false, false));
        if (start > 2) {
            const ellipsis = document.createElement('span');
            ellipsis.className = 'vo-page-ellipsis';
            ellipsis.textContent = '…';
            nav.appendChild(ellipsis);
        }
    }
    for (let p = start; p <= end; p++) {
        nav.appendChild(makeBtn(String(p), p, false, p === current));
    }
    if (end < total) {
        if (end < total - 1) {
            const ellipsis = document.createElement('span');
            ellipsis.className = 'vo-page-ellipsis';
            ellipsis.textContent = '…';
            nav.appendChild(ellipsis);
        }
        nav.appendChild(makeBtn(String(total), total, false, false));
    }

    nav.appendChild(makeBtn('»', current + 1, current >= total, false));
    return nav;
}

function renderSteps(props: Record<string, any>): HTMLElement {
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-steps';
    applyCommonProps(wrapper, props);

    const current = (props['current'] as number) ?? 0;
    const items = (props['items'] as any[]) || [];

    items.forEach((item: any, i: number) => {
        const label = String(item['label'] ?? '');
        const description = String(item['description'] ?? '');
        const state = i < current ? 'completed' : i === current ? 'active' : 'pending';

        const step = document.createElement('div');
        step.className = `vo-step ${state}`;

        const indicator = document.createElement('div');
        indicator.className = 'vo-step-indicator';
        indicator.textContent = i < current ? '✓' : String(i + 1);

        const labelEl = document.createElement('div');
        labelEl.className = 'vo-step-label';
        labelEl.textContent = label;

        step.appendChild(indicator);
        step.appendChild(labelEl);

        if (description) {
            const desc = document.createElement('div');
            desc.className = 'vo-step-description';
            desc.textContent = description;
            step.appendChild(desc);
        }

        wrapper.appendChild(step);
    });

    return wrapper;
}

function renderCheckbox(props: Record<string, any>): HTMLElement {
    const label = document.createElement('label');
    label.className = 'vo-checkbox';
    applyCommonProps(label, props);

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.checked = Boolean(props['checked']);
    if (props['disabled']) input.disabled = true;

    const handlerId = props['onChange'] as number | undefined;
    if (handlerId != null) {
        input.setAttribute('data-vo-change', String(handlerId));
        if (!listenersAttached.has(input)) {
            input.addEventListener('change', () => {
                const id = input.getAttribute('data-vo-change');
                if (id != null) emit(Number(id), JSON.stringify({ Checked: input.checked }));
            });
            listenersAttached.add(input);
        }
    }

    const span = document.createElement('span');
    span.textContent = String(props['textContent'] ?? '');

    label.appendChild(input);
    label.appendChild(span);
    return label;
}

function renderSwitch(props: Record<string, any>): HTMLElement {
    const label = document.createElement('label');
    label.className = 'vo-switch';
    applyCommonProps(label, props);

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.checked = Boolean(props['checked']);
    if (props['disabled']) input.disabled = true;

    const handlerId = props['onChange'] as number | undefined;
    if (handlerId != null) {
        input.setAttribute('data-vo-change', String(handlerId));
        if (!listenersAttached.has(input)) {
            input.addEventListener('change', () => {
                const id = input.getAttribute('data-vo-change');
                if (id != null) emit(Number(id), JSON.stringify({ Checked: input.checked }));
            });
            listenersAttached.add(input);
        }
    }

    const track = document.createElement('span');
    track.className = 'vo-switch-track';
    const thumb = document.createElement('span');
    thumb.className = 'vo-switch-thumb';
    track.appendChild(thumb);

    const span = document.createElement('span');
    span.className = 'vo-switch-label';
    span.textContent = String(props['textContent'] ?? '');

    label.appendChild(input);
    label.appendChild(track);
    label.appendChild(span);
    return label;
}

function renderRadio(props: Record<string, any>): HTMLElement {
    const label = document.createElement('label');
    label.className = 'vo-radio';
    applyCommonProps(label, props);

    const value = String(props['value'] ?? '');
    const selected = String(props['selected'] ?? '');

    const input = document.createElement('input');
    input.type = 'radio';
    input.value = value;
    input.checked = value === selected;
    if (props['disabled']) input.disabled = true;

    const handlerId = props['onChange'] as number | undefined;
    if (handlerId != null) {
        input.setAttribute('data-vo-change', String(handlerId));
        if (!listenersAttached.has(input)) {
            input.addEventListener('change', () => {
                if (!input.checked) return;
                const id = input.getAttribute('data-vo-change');
                if (id != null) emit(Number(id), JSON.stringify({ Value: value }));
            });
            listenersAttached.add(input);
        }
    }

    const span = document.createElement('span');
    span.textContent = String(props['textContent'] ?? '');

    label.appendChild(input);
    label.appendChild(span);
    return label;
}

function renderSlider(props: Record<string, any>): HTMLElement {
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-slider';
    applyCommonProps(wrapper, props);

    const input = document.createElement('input');
    input.type = 'range';
    input.value = String(props['value'] ?? 0);
    input.min = String(props['min'] ?? 0);
    input.max = String(props['max'] ?? 100);
    if (props['disabled']) input.disabled = true;

    const handlerId = props['onChange'] as number | undefined;
    if (handlerId != null) {
        input.setAttribute('data-vo-change', String(handlerId));
        if (!listenersAttached.has(input)) {
            input.addEventListener('input', () => {
                const id = input.getAttribute('data-vo-change');
                if (id != null) emit(Number(id), JSON.stringify({ Value: Number(input.value) }));
            });
            listenersAttached.add(input);
        }
    }

    wrapper.appendChild(input);
    return wrapper;
}

// =============================================================================
// Overlay Managed Component Renderers
// =============================================================================

// One-time global click-outside handler that closes all open overlays.
let _overlayListenerInstalled = false;
function ensureOverlayClickOutside(): void {
    if (_overlayListenerInstalled) return;
    _overlayListenerInstalled = true;
    document.addEventListener('click', (e) => {
        document.querySelectorAll<HTMLElement>(
            '.vo-popover.open, .vo-dropdown-menu.open, .vo-context-menu.open'
        ).forEach(el => {
            if (!el.contains(e.target as Node)) el.classList.remove('open');
        });
    }, true);
}

function renderTooltip(props: Record<string, any>, children: VoNode[]): HTMLElement {
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-tooltip';
    applyCommonProps(wrapper, props);

    if (children[0]) {
        const triggerEl = renderNode(children[0]);
        if (triggerEl) wrapper.appendChild(triggerEl);
    }

    const tip = document.createElement('div');
    tip.className = 'vo-tooltip-content';
    tip.textContent = String(props['textContent'] ?? '');
    wrapper.appendChild(tip);
    return wrapper;
}

function renderHoverCard(props: Record<string, any>, children: VoNode[]): HTMLElement {
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-hover-card';
    applyCommonProps(wrapper, props);

    if (children[0]) {
        const triggerEl = renderNode(children[0]);
        if (triggerEl) {
            const trigger = document.createElement('div');
            trigger.className = 'vo-hover-card-trigger';
            trigger.appendChild(triggerEl);
            wrapper.appendChild(trigger);
        }
    }
    if (children[1]) {
        const cardEl = renderNode(children[1]);
        if (cardEl) {
            const card = document.createElement('div');
            card.className = 'vo-hover-card-content';
            card.appendChild(cardEl);
            wrapper.appendChild(card);
        }
    }
    return wrapper;
}

function renderPopover(props: Record<string, any>, children: VoNode[]): HTMLElement {
    ensureOverlayClickOutside();
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-popover';
    applyCommonProps(wrapper, props);

    const trigger = document.createElement('div');
    trigger.className = 'vo-popover-trigger';
    if (children[0]) {
        const el = renderNode(children[0]);
        if (el) trigger.appendChild(el);
    }

    const content = document.createElement('div');
    content.className = 'vo-popover-content';
    for (let i = 1; i < children.length; i++) {
        const el = renderNode(children[i]);
        if (el) content.appendChild(el);
    }

    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        const wasOpen = wrapper.classList.contains('open');
        document.querySelectorAll('.vo-popover.open').forEach(el => el.classList.remove('open'));
        if (!wasOpen) wrapper.classList.add('open');
    });

    wrapper.appendChild(trigger);
    wrapper.appendChild(content);
    return wrapper;
}

function renderDropdownMenu(props: Record<string, any>, children: VoNode[]): HTMLElement {
    ensureOverlayClickOutside();
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-dropdown-menu';
    applyCommonProps(wrapper, props);

    const trigger = document.createElement('div');
    trigger.className = 'vo-dropdown-trigger';
    if (children[0]) {
        const el = renderNode(children[0]);
        if (el) trigger.appendChild(el);
    }

    const menu = document.createElement('div');
    menu.className = 'vo-dropdown-list';
    for (let i = 1; i < children.length; i++) {
        const el = renderNode(children[i]);
        if (el) menu.appendChild(el);
    }

    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        const wasOpen = wrapper.classList.contains('open');
        document.querySelectorAll('.vo-dropdown-menu.open').forEach(el => el.classList.remove('open'));
        if (!wasOpen) wrapper.classList.add('open');
    });

    wrapper.appendChild(trigger);
    wrapper.appendChild(menu);
    return wrapper;
}

function renderCollapsible(props: Record<string, any>, children: VoNode[]): HTMLElement {
    const wrapper = document.createElement('div');
    const isOpen = Boolean(props['defaultOpen']);
    wrapper.className = 'vo-collapsible' + (isOpen ? ' open' : '');
    applyCommonProps(wrapper, props);

    const trigger = document.createElement('div');
    trigger.className = 'vo-collapsible-trigger';
    if (children[0]) {
        const el = renderNode(children[0]);
        if (el) trigger.appendChild(el);
    }

    const panel = document.createElement('div');
    panel.className = 'vo-collapsible-panel';
    panel.hidden = !isOpen;
    for (let i = 1; i < children.length; i++) {
        const el = renderNode(children[i]);
        if (el) panel.appendChild(el);
    }

    trigger.addEventListener('click', () => {
        wrapper.classList.toggle('open');
        panel.hidden = !wrapper.classList.contains('open');
    });

    wrapper.appendChild(trigger);
    wrapper.appendChild(panel);
    return wrapper;
}

function renderCombobox(props: Record<string, any>, children: VoNode[]): HTMLElement {
    ensureOverlayClickOutside();
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-combobox';
    applyCommonProps(wrapper, props);

    const handlerId = props['onSelect'] as number | undefined;
    if (handlerId != null) {
        wrapper.setAttribute('data-vo-select', String(handlerId));
    }
    const value = String(props['value'] ?? '');
    const placeholder = String(props['placeholder'] ?? '');

    const input = document.createElement('input');
    input.type = 'text';
    input.value = value;
    input.placeholder = placeholder;
    input.className = 'vo-combobox-input';
    input.setAttribute('autocomplete', 'off');

    const listbox = document.createElement('div');
    listbox.className = 'vo-combobox-listbox';
    listbox.hidden = true;

    // Build option list from children
    const options: Array<{ label: string; value: string; el: HTMLElement }> = [];
    for (const child of children) {
        if (child.type === 'vo-combobox-option') {
            const optEl = document.createElement('div');
            optEl.className = 'vo-combobox-option';
            const label = String(child.props?.['textContent'] ?? '');
            const optValue = String(child.props?.['value'] ?? '');
            optEl.textContent = label;
            options.push({ label, value: optValue, el: optEl });

            optEl.addEventListener('click', (e) => {
                e.stopPropagation();
                input.value = label;
                listbox.hidden = true;
                wrapper.classList.remove('open');
                const id = wrapper.getAttribute('data-vo-select');
                if (id != null) {
                    emit(Number(id), JSON.stringify({ Value: optValue }));
                }
            });
            listbox.appendChild(optEl);
        }
    }

    input.addEventListener('input', () => {
        const q = input.value.toLowerCase();
        let anyVisible = false;
        for (const opt of options) {
            const visible = opt.label.toLowerCase().includes(q);
            opt.el.hidden = !visible;
            if (visible) anyVisible = true;
        }
        listbox.hidden = !anyVisible;
        if (anyVisible) wrapper.classList.add('open');
        else wrapper.classList.remove('open');
    });

    input.addEventListener('focus', () => {
        listbox.hidden = false;
        wrapper.classList.add('open');
    });

    wrapper.appendChild(input);
    wrapper.appendChild(listbox);
    return wrapper;
}

function renderContextMenu(props: Record<string, any>, children: VoNode[]): HTMLElement {
    ensureOverlayClickOutside();
    const wrapper = document.createElement('div');
    wrapper.className = 'vo-context-menu';
    applyCommonProps(wrapper, props);

    const trigger = document.createElement('div');
    trigger.className = 'vo-context-menu-trigger';
    if (children[0]) {
        const el = renderNode(children[0]);
        if (el) trigger.appendChild(el);
    }

    const menu = document.createElement('div');
    menu.className = 'vo-context-menu-list';
    for (let i = 1; i < children.length; i++) {
        const el = renderNode(children[i]);
        if (el) menu.appendChild(el);
    }

    trigger.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        menu.style.left = `${e.clientX}px`;
        menu.style.top = `${e.clientY}px`;
        wrapper.classList.add('open');
    });
    menu.addEventListener('click', (e) => {
        e.stopPropagation();
        wrapper.classList.remove('open');
    });

    wrapper.appendChild(trigger);
    document.body.appendChild(menu); // render at body level for correct positioning
    wrapper.appendChild(document.createElement('template')); // placeholder
    return wrapper;
}

export { renderNode };

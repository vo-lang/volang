// Test: defer modifying named return values in complex scenarios
// Coverage: Interaction between defer, named returns, panic/recover, and closures
package main


import "fmt"
// Test 1: defer modifies named return after panic/recover
func recoverModify() (result int) {
	defer func() {
		if r := recover(); r != nil {
			result = 999  // modify named return in recover
		}
	}()
	result = 1
	panic("test panic")
	return 2  // never reached
}

// Test 2: Multiple defers modifying same named return
func multiDefer() (n int) {
	defer func() { n += 1 }()
	defer func() { n += 10 }()
	defer func() { n += 100 }()
	n = 1000
	return  // bare return
}

// Test 3: defer with closure capturing named return variable
func closureCapture() (count int) {
	inc := func() {
		count++  // captures named return
	}
	defer inc()
	defer inc()
	defer inc()
	count = 10
	return  // should return 10 + 3 = 13
}

// Test 4: defer modifies after explicit return value
func explicitReturn() (x int) {
	defer func() { x *= 2 }()
	return 5  // x = 5, then defer makes x = 10
}

// Test 5: defer with multiple named returns
func multiReturn() (a int, b string, c bool) {
	defer func() {
		a = a * 2
		b = b + "!"
		c = !c
	}()
	return 10, "hello", false
	// Result: 20, "hello!", true
}

// Test 6: nested defer modification
// BUG: Vo doesn't execute defer inside defer functions
// func nestedDefer() (val int) {
// 	defer func() {
// 		defer func() {
// 			val += 1  // inner defer - NEVER EXECUTES
// 		}()
// 		val += 10  // outer defer
// 	}()
// 	val = 100
// 	return
// 	// Expected: val=100, return, outer defer (val=110), inner defer (val=111)
// 	// Actual: inner defer never runs, returns 110
// }

// Test 7: defer in loop with named return
func loopDefer() (sum int) {
	for i := 0; i < 3; i++ {
		defer func(x int) {
			sum += x
		}(i)
	}
	sum = 100
	return  // defers run in reverse: i=2, i=1, i=0
	// sum = 100 + 2 + 1 + 0 = 103
}

func main() {
	// Test 1
	r1 := recoverModify()
	assert(r1 == 999, "recoverModify should return 999, got ", r1)
	
	// Test 2: defers execute in LIFO order
	r2 := multiDefer()
	// n=1000, return, defer +100 (1100), defer +10 (1110), defer +1 (1111)
	assert(r2 == 1111, "multiDefer should return 1111, got ", r2)
	
	// Test 3
	r3 := closureCapture()
	assert(r3 == 13, "closureCapture should return 13, got ", r3)
	
	// Test 4
	r4 := explicitReturn()
	assert(r4 == 10, "explicitReturn should return 10, got ", r4)
	
	// Test 5
	a5, b5, c5 := multiReturn()
	assert(a5 == 20, "multiReturn a should be 20, got ", a5)
	assert(b5 == "hello!", "multiReturn b should be 'hello!'")
	assert(c5 == true, "multiReturn c should be true")
	
	// Test 6: SKIPPED - Vo bug: defer inside defer doesn't execute
	// r6 := nestedDefer()
	// assert(r6 == 111, "nestedDefer should return 111, got ", r6)
	
	// Test 7
	r7 := loopDefer()
	assert(r7 == 103, "loopDefer should return 103, got ", r7)
	
	fmt.Println("defer_return_modify_complex: ok")
}

// Test: Packed array/slice storage for primitive types
// Tests []bool, []int8, []uint8, []int16, []uint16, []int32, []uint32, []float32
package main


import "fmt"
func main() {
	testBoolSlice()
	testInt8Slice()
	testUint8Slice()
	testInt16Slice()
	testUint16Slice()
	testInt32Slice()
	testUint32Slice()
	testFloat32Slice()
	testSliceOperations()
	testForRange()
	testAppendAndCopy()
	fmt.Println("packed array tests passed")
}

func testBoolSlice() {
	// []bool: elem_bytes = 1
	s := []bool{true, false, true, true, false}
	assert(s[0] == true, "bool[0]")
	assert(s[1] == false, "bool[1]")
	assert(s[2] == true, "bool[2]")
	assert(s[3] == true, "bool[3]")
	assert(s[4] == false, "bool[4]")
	assert(len(s) == 5, "bool len")
	
	// Modify
	s[1] = true
	assert(s[1] == true, "bool set")
}

func testInt8Slice() {
	// []int8: elem_bytes = 1
	s := []int8{-128, -1, 0, 1, 127}
	assert(s[0] == -128, "int8 min")
	assert(s[1] == -1, "int8 -1")
	assert(s[2] == 0, "int8 0")
	assert(s[3] == 1, "int8 1")
	assert(s[4] == 127, "int8 max")
	
	s[2] = 42
	assert(s[2] == 42, "int8 set")
}

func testUint8Slice() {
	// []uint8 (byte): elem_bytes = 1
	s := []uint8{0, 1, 127, 128, 255}
	assert(s[0] == 0, "uint8 0")
	assert(s[1] == 1, "uint8 1")
	assert(s[2] == 127, "uint8 127")
	assert(s[3] == 128, "uint8 128")
	assert(s[4] == 255, "uint8 max")
}

func testInt16Slice() {
	// []int16: elem_bytes = 2
	s := []int16{-32768, -1, 0, 1, 32767}
	assert(s[0] == -32768, "int16 min")
	assert(s[1] == -1, "int16 -1")
	assert(s[2] == 0, "int16 0")
	assert(s[3] == 1, "int16 1")
	assert(s[4] == 32767, "int16 max")
	
	s[2] = 1000
	assert(s[2] == 1000, "int16 set")
}

func testUint16Slice() {
	// []uint16: elem_bytes = 2
	s := []uint16{0, 1, 32767, 32768, 65535}
	assert(s[0] == 0, "uint16 0")
	assert(s[4] == 65535, "uint16 max")
}

func testInt32Slice() {
	// []int32: elem_bytes = 4
	s := []int32{-2147483648, -1, 0, 1, 2147483647}
	assert(s[0] == -2147483648, "int32 min")
	assert(s[1] == -1, "int32 -1")
	assert(s[2] == 0, "int32 0")
	assert(s[3] == 1, "int32 1")
	assert(s[4] == 2147483647, "int32 max")
	
	s[2] = 123456
	assert(s[2] == 123456, "int32 set")
}

func testUint32Slice() {
	// []uint32: elem_bytes = 4
	s := []uint32{0, 1, 2147483647, 2147483648, 4294967295}
	assert(s[0] == 0, "uint32 0")
	assert(s[4] == 4294967295, "uint32 max")
}

func testFloat32Slice() {
	// []float32: elem_bytes = 4
	s := []float32{0.0, 1.5, -1.5, 3.14159}
	assert(s[0] == 0.0, "float32 0")
	assert(s[1] == 1.5, "float32 1.5")
	assert(s[2] == -1.5, "float32 -1.5")
	// Float comparison with tolerance
	diff := s[3] - 3.14159
	if diff < 0 {
		diff = -diff
	}
	assert(diff < 0.0001, "float32 pi")
}

func testSliceOperations() {
	// Slice of slice (sub-slicing)
	s := []int32{10, 20, 30, 40, 50}
	sub := s[1:4]
	assert(len(sub) == 3, "sub len")
	assert(sub[0] == 20, "sub[0]")
	assert(sub[1] == 30, "sub[1]")
	assert(sub[2] == 40, "sub[2]")
	
	// Modify through sub-slice
	sub[1] = 300
	assert(s[2] == 300, "modify through sub")
	
	// Three-index slice
	sub2 := s[1:3:4]
	assert(len(sub2) == 2, "sub2 len")
	assert(cap(sub2) == 3, "sub2 cap")
}

func testForRange() {
	// for-range []int8
	s8 := []int8{1, 2, 3, 4, 5}
	sum8 := int8(0)
	for _, v := range s8 {
		sum8 += v
	}
	assert(sum8 == 15, "for-range int8")
	
	// for-range []int32
	s32 := []int32{100, 200, 300}
	sum32 := int32(0)
	for i, v := range s32 {
		sum32 += int32(i) * 100 + v
	}
	// 0*100+100 + 1*100+200 + 2*100+300 = 100 + 300 + 500 = 900
	assert(sum32 == 900, "for-range int32")
	
	// for-range []bool
	bools := []bool{true, true, false, true}
	count := 0
	for _, b := range bools {
		if b {
			count += 1
		}
	}
	assert(count == 3, "for-range bool")
}

func testAppendAndCopy() {
	// append []int8
	s := []int8{1, 2, 3}
	s = append(s, 4)
	assert(len(s) == 4, "append len")
	assert(s[3] == 4, "append val")
	
	// append to nil
	var ns []int16
	ns = append(ns, 100)
	assert(len(ns) == 1, "append nil len")
	assert(ns[0] == 100, "append nil val")
	
	// copy
	src := []int32{10, 20, 30}
	dst := make([]int32, 5)
	n := copy(dst, src)
	assert(n == 3, "copy n")
	assert(dst[0] == 10, "copy dst[0]")
	assert(dst[1] == 20, "copy dst[1]")
	assert(dst[2] == 30, "copy dst[2]")
	assert(dst[3] == 0, "copy dst[3] zero")
	
	// append causing growth
	s2 := make([]uint8, 0, 2)
	s2 = append(s2, 1)
	s2 = append(s2, 2)
	s2 = append(s2, 3) // triggers growth
	assert(len(s2) == 3, "grow len")
	assert(s2[0] == 1, "grow[0]")
	assert(s2[1] == 2, "grow[1]")
	assert(s2[2] == 3, "grow[2]")
}

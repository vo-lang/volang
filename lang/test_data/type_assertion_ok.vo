// Test: type assertion comma-ok form: v, ok := x.(T)
package main


import "fmt"
type Speaker interface {
    Speak() string
}

type Walker interface {
    Walk() int
}

type Dog struct {
    name string
}

func (d Dog) Speak() string {
    return "woof"
}

type Cat struct {
    name string
}

func (c Cat) Speak() string {
    return "meow"
}

func (c Cat) Walk() int {
    return 4
}

// Test 1: empty interface to primitive - success cases
func testPrimitiveSuccess() {
    var e interface{}
    
    // int
    e = 42
    v, ok := e.(int)
    assert(ok, "int assertion should succeed")
    assert(v == 42, "v should be 42")
    
    // string
    e = "hello"
    s, ok := e.(string)
    assert(ok, "string assertion should succeed")
    assert(s == "hello", "s should be hello")
    
    // float64
    e = 3.14
    f, ok := e.(float64)
    assert(ok, "float64 assertion should succeed")
    assert(f == 3.14, "f should be 3.14")
    
    // bool
    e = true
    b, ok := e.(bool)
    assert(ok, "bool assertion should succeed")
    assert(b, "b should be true")
    
    fmt.Println("Test 1 PASSED: primitive success")
}

// Test 2: empty interface to primitive - failure cases
func testPrimitiveFailure() {
    var e interface{}
    
    // int stored, assert string
    e = 42
    s, ok := e.(string)
    assert(!ok, "string assertion should fail for int")
    assert(s == "", "s should be zero value on failure")
    
    // string stored, assert int
    e = "hello"
    v, ok := e.(int)
    assert(!ok, "int assertion should fail for string")
    assert(v == 0, "v should be zero value on failure")
    
    // float64 stored, assert bool
    e = 3.14
    b, ok := e.(bool)
    assert(!ok, "bool assertion should fail for float64")
    assert(!b, "b should be false on failure")
    
    // bool stored, assert float64
    e = true
    f, ok := e.(float64)
    assert(!ok, "float64 assertion should fail for bool")
    assert(f == 0.0, "f should be 0.0 on failure")
    
    fmt.Println("Test 2 PASSED: primitive failure")
}

// Test 3: empty interface to struct - success
func testStructSuccess() {
    var e interface{}
    
    d := Dog{name: "Buddy"}
    e = d
    
    dog, ok := e.(Dog)
    assert(ok, "Dog assertion should succeed")
    assert(dog.name == "Buddy", "dog.name should be Buddy")
    
    fmt.Println("Test 3 PASSED: struct success")
}

// Test 4: empty interface to struct - failure
func testStructFailure() {
    var e interface{}
    
    d := Dog{name: "Buddy"}
    e = d
    
    cat, ok := e.(Cat)
    assert(!ok, "Cat assertion should fail for Dog")
    assert(cat.name == "", "cat.name should be empty on failure")
    
    fmt.Println("Test 4 PASSED: struct failure")
}

// Test 5: named interface to concrete type - success
func testNamedInterfaceSuccess() {
    var s Speaker
    
    d := Dog{name: "Rex"}
    s = d
    
    dog, ok := s.(Dog)
    assert(ok, "Dog assertion should succeed")
    assert(dog.name == "Rex", "dog.name should be Rex")
    
    fmt.Println("Test 5 PASSED: named interface success")
}

// Test 6: named interface to concrete type - failure
func testNamedInterfaceFailure() {
    var s Speaker
    
    d := Dog{name: "Rex"}
    s = d
    
    cat, ok := s.(Cat)
    assert(!ok, "Cat assertion should fail for Dog")
    assert(cat.name == "", "cat.name should be empty")
    
    fmt.Println("Test 6 PASSED: named interface failure")
}

// Test 7: empty interface to interface - success
func testIfaceToIfaceSuccess() {
    var e interface{}
    
    c := Cat{name: "Whiskers"}
    e = c
    
    // Cat implements both Speaker and Walker
    speaker, ok := e.(Speaker)
    assert(ok, "Speaker assertion should succeed for Cat")
    assert(speaker.Speak() == "meow", "speaker.Speak() should be meow")
    
    walker, ok := e.(Walker)
    assert(ok, "Walker assertion should succeed for Cat")
    assert(walker.Walk() == 4, "walker.Walk() should be 4")
    
    fmt.Println("Test 7 PASSED: interface to interface success")
}

// Test 8: empty interface to interface - failure
func testIfaceToIfaceFailure() {
    var e interface{}
    
    d := Dog{name: "Buddy"}
    e = d
    
    // Dog only implements Speaker, not Walker
    _, ok := e.(Walker)
    assert(!ok, "Walker assertion should fail for Dog")
    
    fmt.Println("Test 8 PASSED: interface to interface failure")
}

// Test 9: nil interface - failure
func testNilInterface() {
    var e interface{}
    
    // nil interface assertion always fails
    v, ok := e.(int)
    assert(!ok, "assertion on nil interface should fail")
    assert(v == 0, "v should be zero")
    
    s, ok := e.(string)
    assert(!ok, "assertion on nil interface should fail")
    assert(s == "", "s should be empty")
    
    dog, ok := e.(Dog)
    assert(!ok, "assertion on nil interface should fail")
    assert(dog.name == "", "dog.name should be empty")
    
    fmt.Println("Test 9 PASSED: nil interface")
}

// Test 10: typed nil (interface containing nil pointer)
func testTypedNil() {
    var e interface{}
    var dp *Dog = nil
    e = dp
    
    // Typed nil: e is NOT nil, but contains nil pointer
    ptr, ok := e.(*Dog)
    assert(ok, "typed nil assertion should succeed")
    assert(ptr == nil, "ptr should be nil")
    
    // Wrong type assertion should fail
    cp, ok := e.(*Cat)
    assert(!ok, "wrong pointer type should fail")
    assert(cp == nil, "cp should be nil on failure")
    
    fmt.Println("Test 10 PASSED: typed nil")
}

// Test 11: multiple assertions in sequence
func testSequentialAssertions() {
    var e interface{}
    
    e = 100
    v1, ok1 := e.(int)
    assert(ok1 && v1 == 100, "first assertion")
    
    e = "world"
    v2, ok2 := e.(string)
    assert(ok2 && v2 == "world", "second assertion")
    
    e = Dog{name: "Max"}
    v3, ok3 := e.(Dog)
    assert(ok3 && v3.name == "Max", "third assertion")
    
    fmt.Println("Test 11 PASSED: sequential assertions")
}

// Test 12: assertion in conditional
func testConditionalAssertion() {
    var e interface{}
    e = 42
    
    if v, ok := e.(int); ok {
        assert(v == 42, "v should be 42 in if")
    }
    
    _, ok := e.(string)
    assert(!ok, "string assertion should fail for int")
    
    fmt.Println("Test 12 PASSED: conditional assertion")
}

// Test 13: assertion result used in expression
func testAssertionInExpression() {
    var e interface{}
    e = 10
    
    v, ok := e.(int)
    result := v * 2
    assert(ok, "assertion should succeed")
    assert(result == 20, "result should be 20")
    
    fmt.Println("Test 13 PASSED: assertion in expression")
}

func main() {
    testPrimitiveSuccess()
    testPrimitiveFailure()
    testStructSuccess()
    testStructFailure()
    testNamedInterfaceSuccess()
    testNamedInterfaceFailure()
    testIfaceToIfaceSuccess()
    testIfaceToIfaceFailure()
    testNilInterface()
    testTypedNil()
    testSequentialAssertions()
    testConditionalAssertion()
    testAssertionInExpression()
    
    fmt.Println("type_assertion_ok: ALL PASSED")
}

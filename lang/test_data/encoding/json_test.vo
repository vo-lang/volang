package main

import (
	"bytes"
	"dyn"
	"encoding/json"
	"strings"
)

func main() {
	testUnmarshal()
	testMarshal()
	testMarshalIndent()
	testValid()
	testDecoder()
	testEncoder()
	testNumber()
	testCompact()
	testIndent()
	testEdgeCases()
}

func testUnmarshal() {
	// Simple values
	v, err := json.Unmarshal([]byte(`"hello"`))
	assert(err == nil, "unmarshal string")
	assert(v.(string) == "hello", "string value")

	v, err = json.Unmarshal([]byte(`123`))
	assert(err == nil, "unmarshal number")
	f := v.(float64)
	assert(f == 123.0, "number value")

	v, err = json.Unmarshal([]byte(`true`))
	assert(err == nil, "unmarshal bool")
	assert(v.(bool) == true, "bool value")

	v, err = json.Unmarshal([]byte(`false`))
	assert(err == nil, "unmarshal false")
	assert(v.(bool) == false, "false value")

	v, err = json.Unmarshal([]byte(`null`))
	assert(err == nil, "unmarshal null")
	assert(v == nil, "null value")

	// Object
	v, err = json.Unmarshal([]byte(`{"name": "test", "value": 42}`))
	assert(err == nil, "unmarshal object")
	obj := v.(dyn.MapObject)
	assert(obj["name"].(string) == "test", "object name")
	assert(obj["value"].(float64) == 42.0, "object value")

	// Array
	v, err = json.Unmarshal([]byte(`[1, 2, 3]`))
	assert(err == nil, "unmarshal array")
	arr := v.(dyn.SliceObject)
	assert(len(arr) == 3, "array length")
	assert(arr[0].(float64) == 1.0, "array[0]")

	// Nested
	v, err = json.Unmarshal([]byte(`{"items": [{"id": 1}, {"id": 2}]}`))
	assert(err == nil, "unmarshal nested")
	obj = v.(dyn.MapObject)
	items := obj["items"].(dyn.SliceObject)
	assert(len(items) == 2, "nested array length")
	assert(items[0].(dyn.MapObject)["id"].(float64) == 1.0, "nested id")

	// Unicode escape
	v, err = json.Unmarshal([]byte(`"hello\u0020world"`))
	assert(err == nil, "unmarshal unicode")
	assert(v.(string) == "hello world", "unicode value")

	// Escape sequences
	v, err = json.Unmarshal([]byte(`"line1\nline2\ttab"`))
	assert(err == nil, "unmarshal escapes")
	assert(v.(string) == "line1\nline2\ttab", "escape value")

	// Empty object/array
	v, err = json.Unmarshal([]byte(`{}`))
	assert(err == nil, "unmarshal empty object")
	assert(len(v.(dyn.MapObject)) == 0, "empty object")

	v, err = json.Unmarshal([]byte(`[]`))
	assert(err == nil, "unmarshal empty array")
	assert(len(v.(dyn.SliceObject)) == 0, "empty array")

	// Errors
	_, err = json.Unmarshal([]byte(`{invalid}`))
	assert(err != nil, "error on invalid json")

	_, err = json.Unmarshal([]byte(`{"key": }`))
	assert(err != nil, "error on missing value")
}

func testMarshal() {
	// Simple values
	b, err := json.Marshal("hello")
	assert(err == nil, "marshal string")
	assert(string(b) == `"hello"`, "string json")

	b, err = json.Marshal(42)
	assert(err == nil, "marshal int")
	assert(string(b) == "42", "int json")

	b, err = json.Marshal(3.14)
	assert(err == nil, "marshal float")
	assert(bytes.HasPrefix(b, []byte("3.14")), "float json")

	b, err = json.Marshal(true)
	assert(err == nil, "marshal bool")
	assert(string(b) == "true", "bool json")

	b, err = json.Marshal(nil)
	assert(err == nil, "marshal nil")
	assert(string(b) == "null", "nil json")

	// Object
	obj := map[string]any{"name": "test"}
	b, err = json.Marshal(obj)
	assert(err == nil, "marshal object")
	assert(bytes.Contains(b, []byte(`"name"`)), "object contains key")
	assert(bytes.Contains(b, []byte(`"test"`)), "object contains value")

	// Array
	arr := []any{1, 2, 3}
	b, err = json.Marshal(arr)
	assert(err == nil, "marshal array")
	assert(string(b) == "[1,2,3]", "array json")

	// Escape characters
	b, err = json.Marshal("line1\nline2")
	assert(err == nil, "marshal newline")
	assert(string(b) == `"line1\nline2"`, "newline escaped")

	// Number type
	b, err = json.Marshal(json.Number("12345678901234567890"))
	assert(err == nil, "marshal Number")
	assert(string(b) == "12345678901234567890", "Number preserved")

	// RawMessage
	b, err = json.Marshal(json.RawMessage(`{"pre":"encoded"}`))
	assert(err == nil, "marshal RawMessage")
	assert(string(b) == `{"pre":"encoded"}`, "RawMessage preserved")
}

func testMarshalIndent() {
	obj := map[string]any{"a": 1, "b": 2}
	b, err := json.MarshalIndent(obj, "", "  ")
	assert(err == nil, "marshal indent")
	assert(bytes.Contains(b, []byte("\n")), "has newlines")
	assert(bytes.Contains(b, []byte("  ")), "has indent")
}

func testValid() {
	assert(json.Valid([]byte(`{"a": 1}`)) == true, "valid object")
	assert(json.Valid([]byte(`[1,2,3]`)) == true, "valid array")
	assert(json.Valid([]byte(`"string"`)) == true, "valid string")
	assert(json.Valid([]byte(`123`)) == true, "valid number")
	assert(json.Valid([]byte(`true`)) == true, "valid bool")
	assert(json.Valid([]byte(`null`)) == true, "valid null")

	assert(json.Valid([]byte(`{invalid}`)) == false, "invalid object")
	assert(json.Valid([]byte(`[1,2,]`)) == false, "trailing comma")
	assert(json.Valid([]byte(`"`)) == false, "unclosed string")
}

func testDecoder() {
	r := strings.NewReader(`{"a":1}{"b":2}`)
	dec := json.NewDecoder(r)

	v, err := dec.Decode()
	assert(err == nil, "decode first")
	assert(v.(dyn.MapObject)["a"].(float64) == 1.0, "first value")

	v, err = dec.Decode()
	assert(err == nil, "decode second")
	assert(v.(dyn.MapObject)["b"].(float64) == 2.0, "second value")

	// UseNumber
	r = strings.NewReader(`{"n": 12345678901234567890}`)
	dec = json.NewDecoder(r)
	dec.UseNumber()
	v, err = dec.Decode()
	assert(err == nil, "decode with UseNumber")
	n := v.(dyn.MapObject)["n"].(json.Number)
	assert(string(n) == "12345678901234567890", "number preserved")

	// Token API
	r = strings.NewReader(`{"key": [1, 2]}`)
	dec = json.NewDecoder(r)
	tok, err := dec.Token()
	assert(err == nil, "token 1")
	assert(tok.(json.Delim) == '{', "token is {")

	tok, err = dec.Token()
	assert(err == nil, "token 2")
	assert(tok.(string) == "key", "token is key")

	tok, err = dec.Token()
	assert(err == nil, "token 3")
	assert(tok.(json.Delim) == '[', "token is [")

	// More()
	assert(dec.More() == true, "more elements")
}

func testEncoder() {
	buf := &bytes.Buffer{}
	enc := json.NewEncoder(buf)

	err := enc.Encode(map[string]any{"a": 1})
	assert(err == nil, "encode")
	assert(bytes.Contains(buf.Bytes(), []byte(`"a"`)), "encoded has key")

	buf.Reset()
	enc.SetIndent("", "  ")
	err = enc.Encode(map[string]any{"b": 2})
	assert(err == nil, "encode with indent")
	assert(bytes.Contains(buf.Bytes(), []byte("\n")), "indented has newlines")
}

func testNumber() {
	n := json.Number("123")
	assert(n.String() == "123", "Number.String")

	i, err := n.Int64()
	assert(err == nil, "Number.Int64")
	assert(i == 123, "Int64 value")

	f, err := n.Float64()
	assert(err == nil, "Number.Float64")
	assert(f == 123.0, "Float64 value")

	// Large number - Float64 handles it
	n = json.Number("12345678901234567890")
	f, err = n.Float64()
	assert(err == nil, "large number Float64")
}

func testCompact() {
	src := []byte(`{  "a" : 1 , "b" : [ 1 , 2 ] }`)
	dst := &bytes.Buffer{}
	err := json.Compact(dst, src)
	assert(err == nil, "compact")
	assert(dst.String() == `{"a":1,"b":[1,2]}`, "compact result")
}

func testIndent() {
	src := []byte(`{"a":1,"b":[1,2]}`)
	dst := &bytes.Buffer{}
	err := json.Indent(dst, src, "", "  ")
	assert(err == nil, "indent")
	s := dst.String()
	assert(bytes.Contains([]byte(s), []byte("\n")), "indent has newlines")
	assert(bytes.Contains([]byte(s), []byte("  ")), "indent has spaces")
}

func testEdgeCases() {
	// Deeply nested
	v, err := json.Unmarshal([]byte(`[[[[1]]]]`))
	assert(err == nil, "deep array")
	assert(v.(dyn.SliceObject)[0].(dyn.SliceObject)[0].(dyn.SliceObject)[0].(dyn.SliceObject)[0].(float64) == 1.0, "deep value")

	// Negative number
	v, err = json.Unmarshal([]byte(`-123`))
	assert(err == nil, "negative")
	assert(v.(float64) == -123.0, "negative value")

	// Exponent
	v, err = json.Unmarshal([]byte(`1.5e10`))
	assert(err == nil, "exponent")
	assert(v.(float64) == 1.5e10, "exponent value")

	// Negative exponent
	v, err = json.Unmarshal([]byte(`1.5e-3`))
	assert(err == nil, "neg exponent")

	// Unicode in key
	v, err = json.Unmarshal([]byte(`{"中文": "value"}`))
	assert(err == nil, "unicode key")
	assert(v.(dyn.MapObject)["中文"].(string) == "value", "unicode key value")

	// Empty string
	v, err = json.Unmarshal([]byte(`""`))
	assert(err == nil, "empty string")
	assert(v.(string) == "", "empty string value")

	// Whitespace handling
	v, err = json.Unmarshal([]byte("  \n\t { \"a\" : 1 }  \n"))
	assert(err == nil, "whitespace")
	assert(v.(dyn.MapObject)["a"].(float64) == 1.0, "whitespace value")
}

func assert(cond bool, msg string) {
	if !cond {
		panic("assertion failed: " + msg)
	}
}

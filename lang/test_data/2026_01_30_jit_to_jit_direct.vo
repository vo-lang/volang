// Test JIT-to-JIT direct calls.
// warmup() ensures both caller and callee are JIT compiled before the actual test call.

package main

import "fmt"

var callCount int

// caller will be JIT compiled after warmup
func caller(x int) int {
	callCount++
	return callee(x * 2)
}

// callee will be JIT compiled after warmup
func callee(x int) int {
	callCount++
	return x + 100
}

func warmup() {
	// Call each function twice to ensure JIT compilation (threshold=1 means compile after 1st call)
	// 1st call: increment count, trigger compilation
	// 2nd call: should use JIT version
	_ = caller(1)  // This also calls callee
	_ = caller(1)  // Now both caller and callee should be JIT compiled
	_ = callee(1)  // Extra callee call for certainty
	_ = callee(1)
}

func main() {
	callCount = 0
	
	// Warmup phase - get both functions JIT compiled
	warmup()
	warmupCalls := callCount
	
	// Reset counter for actual test
	callCount = 0
	
	// This should be a JIT-to-JIT call:
	// JIT(caller) -> JIT(callee)
	result := caller(5)
	
	// caller(5) -> callee(10) -> 110
	assert(result == 110, fmt.Sprintf("expected 110, got %d", result))
	assert(callCount == 2, fmt.Sprintf("expected 2 calls, got %d", callCount))
	
	// Test multiple JIT-to-JIT calls
	callCount = 0
	sum := 0
	for i := 0; i < 10; i++ {
		sum += caller(i)
	}
	// sum = caller(0)+caller(1)+...+caller(9)
	//     = callee(0)+callee(2)+...+callee(18)
	//     = (0+100)+(2+100)+...+(18+100)
	//     = (0+2+4+6+8+10+12+14+16+18) + 1000
	//     = 90 + 1000 = 1090
	assert(sum == 1090, fmt.Sprintf("expected 1090, got %d", sum))
	assert(callCount == 20, fmt.Sprintf("expected 20 calls, got %d", callCount))
	
	println("PASS: JIT-to-JIT direct calls")
}

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

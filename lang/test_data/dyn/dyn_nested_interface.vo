// Test dynamic access through nested interface layers
// Coverage: interface containing interface, deep dynamic dispatch
package main


import "fmt"
type Inner interface {
	Value() int
}

type Outer interface {
	GetInner() Inner
}

type InnerImpl struct {
	val int
}

func (i *InnerImpl) Value() int {
	return i.val
}

type OuterImpl struct {
	inner Inner
}

func (o *OuterImpl) GetInner() Inner {
	return o.inner
}

func (o *OuterImpl) Double() int {
	return o.inner.Value() * 2
}

type Wrapper struct {
	outer Outer
	name  string
}

func (w *Wrapper) GetOuter() Outer {
	return w.outer
}

func main() {
	inner := &InnerImpl{val: 42}
	outer := &OuterImpl{inner: inner}
	wrapper := &Wrapper{outer: outer, name: "test"}

	var obj any = wrapper

	// Test 1: Access field through any
	nameVal, err := obj~>name
	assert(err == nil, "name error")
	assert(nameVal.(string) == "test", "name mismatch")
	fmt.Println("Test 1: name =", nameVal.(string))

	// Test 2: Get outer via dyn call
	outerVal, err := obj~>GetOuter()
	assert(err == nil, "GetOuter error")
	fmt.Println("Test 2: GetOuter ok")

	// Test 3: Chain through interface - get inner from outer
	innerVal, err := outerVal~>GetInner()
	assert(err == nil, "GetInner error")
	fmt.Println("Test 3: GetInner ok")

	// Test 4: Call Value on inner
	valResult, err := innerVal~>Value()
	assert(err == nil, "Value error")
	assert(valResult.(int) == 42, "Value mismatch")
	fmt.Println("Test 4: Value() =", valResult.(int))

	// Test 5: Chained call - obj~>GetOuter()~>GetInner()~>Value()
	v1, err := obj~>GetOuter()
	assert(err == nil, "chain step 1 error")
	v2, err := v1~>GetInner()
	assert(err == nil, "chain step 2 error")
	v3, err := v2~>Value()
	assert(err == nil, "chain step 3 error")
	assert(v3.(int) == 42, "chain value mismatch")
	fmt.Println("Test 5: chained call =", v3.(int))

	// Test 6: Call method on outer that uses inner
	doubleVal, err := outerVal~>Double()
	assert(err == nil, "Double error")
	assert(doubleVal.(int) == 84, "Double mismatch")
	fmt.Println("Test 6: Double() =", doubleVal.(int))

	// Test 7: interface -> interface field access
	var outerIface any = outer
	innerFromOuter, err := outerIface~>inner
	assert(err == nil, "inner field error")
	vFromField, err := innerFromOuter~>Value()
	assert(err == nil, "Value from field error")
	assert(vFromField.(int) == 42, "Value from field mismatch")
	fmt.Println("Test 7: inner field Value() =", vFromField.(int))

	fmt.Println("dyn_nested_interface: ok")
}

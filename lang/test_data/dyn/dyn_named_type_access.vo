// Test dynamic access on named types (type alias on slice/map/primitive)
// Verifies that ~> works correctly on named types like type MySlice []int.
package main


import "fmt"
type IntSlice []int
type StringMap map[string]int
type IntArray [5]int

func (s IntSlice) Sum() int {
    total := 0
    for _, v := range s {
        total += v
    }
    return total
}

func (s IntSlice) First() int {
    if len(s) == 0 {
        return 0
    }
    return s[0]
}

func (m StringMap) Get(key string) int {
    return m[key]
}

func (m StringMap) Keys() []string {
    var keys []string
    for k := range m {
        keys = append(keys, k)
    }
    return keys
}

func main() {
    // Test 1: Named slice type - index access
    s := IntSlice{10, 20, 30, 40, 50}
    var obj any = s
    
    v1, err := obj~>[0]
    assert(err == nil, "index 0 should succeed")
    assert(v1.(int) == 10, "s[0] should be 10")
    fmt.Println("Test 1: s[0] =", v1.(int))
    
    v2, err := obj~>[4]
    assert(err == nil, "index 4 should succeed")
    assert(v2.(int) == 50, "s[4] should be 50")
    fmt.Println("Test 2: s[4] =", v2.(int))
    
    // Test 3: Named slice type - method call
    sum, err := obj~>Sum()
    assert(err == nil, "Sum should succeed")
    assert(sum.(int) == 150, "Sum should be 150")
    fmt.Println("Test 3: Sum() =", sum.(int))
    
    first, err := obj~>First()
    assert(err == nil, "First should succeed")
    assert(first.(int) == 10, "First should be 10")
    fmt.Println("Test 4: First() =", first.(int))
    
    // Test 5: Named map type - index access
    m := StringMap{"a": 1, "b": 2, "c": 3}
    var mapObj any = m
    
    va, err := mapObj~>["a"]
    assert(err == nil, "map[a] should succeed")
    assert(va.(int) == 1, "map[a] should be 1")
    fmt.Println("Test 5: m[a] =", va.(int))
    
    // Test 6: Named map type - method call
    got, err := mapObj~>Get("b")
    assert(err == nil, "Get should succeed")
    assert(got.(int) == 2, "Get(b) should be 2")
    fmt.Println("Test 6: Get(b) =", got.(int))
    
    // Test 7: Named array type - index access
    arr := IntArray{100, 200, 300, 400, 500}
    var arrObj any = arr
    
    arrV, err := arrObj~>[2]
    assert(err == nil, "arr[2] should succeed")
    assert(arrV.(int) == 300, "arr[2] should be 300")
    fmt.Println("Test 7: arr[2] =", arrV.(int))
    
    // Test 8: Named slice - out of bounds
    _, err = obj~>[10]
    assert(err != nil, "index 10 should error")
    fmt.Println("Test 8: s[10] error (expected)")
    
    // Test 9: Named map - missing key returns zero
    missing, err := mapObj~>["missing"]
    assert(err == nil, "missing key should not error")
    assert(missing.(int) == 0, "missing key should return zero")
    fmt.Println("Test 9: m[missing] =", missing.(int))
    
    // Test 10: Named slice - modify via slice (slices are reference types)
    sp := IntSlice{1, 2, 3}
    var spObj any = sp
    spObj~>[1] = 99
    assert(sp[1] == 99, "sp[1] should be 99")
    fmt.Println("Test 10: sp[1] =", sp[1])
    
    fmt.Println("dyn_named_type_access: ok")
}

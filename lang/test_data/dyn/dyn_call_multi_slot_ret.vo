// Test dyn_call with multi-slot return values (struct returns)
// This tests the bug where return value source offset is incorrectly calculated
// when previous return values take more than 1 slot.
package main


import "fmt"
type Point struct {
	X, Y, Z, W int
}

type Caller struct {
	val int
}

// Returns (struct[4 slots], int[1 slot])
// Bug: second return value would be read from wrong offset
func (c *Caller) RetStructThenInt() (Point, int) {
	return Point{X: 10, Y: 20, Z: 30, W: 40}, 42
}

// Returns (int[1 slot], struct[4 slots])
func (c *Caller) RetIntThenStruct() (int, Point) {
	return 99, Point{X: 30, Y: 40, Z: 50, W: 60}
}

func main() {
	fmt.Println("=== Testing multi-slot return value offset ===")

	caller := &Caller{val: 1}
	var obj interface{} = caller

	// Test 1: (struct, int) - struct is 4 slots, int should be at offset 4
	p1, n1, err := obj~>RetStructThenInt()
	assert(err == nil, "RetStructThenInt error")
	pt1 := p1.(Point)
	num1 := n1.(int)
	assert(pt1.X == 10 && pt1.Y == 20 && pt1.Z == 30 && pt1.W == 40, "RetStructThenInt Point wrong")
	assert(num1 == 42, "RetStructThenInt int wrong")
	fmt.Println("RetStructThenInt: Point{", pt1.X, ",", pt1.Y, ",", pt1.Z, ",", pt1.W, "}, int:", num1)

	// Test 2: (int, struct) - int is 1 slot, struct is 4 slots
	n2, p2, err := obj~>RetIntThenStruct()
	assert(err == nil, "RetIntThenStruct error")
	num2 := n2.(int)
	pt2 := p2.(Point)
	assert(num2 == 99, "RetIntThenStruct int wrong")
	assert(pt2.X == 30 && pt2.Y == 40 && pt2.Z == 50 && pt2.W == 60, "RetIntThenStruct Point wrong")
	fmt.Println("RetIntThenStruct: int:", num2, ", Point{", pt2.X, ",", pt2.Y, ",", pt2.Z, ",", pt2.W, "}")

	fmt.Println("=== All multi-slot return tests passed! ===")
}

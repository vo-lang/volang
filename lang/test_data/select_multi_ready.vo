// Test: select with multiple ready cases
// When multiple cases are ready, Go selects one randomly
// We test that all cases CAN be selected (statistical test)
package main


import "fmt"
func main() {
    // Test 1: Two buffered channels both ready
    ch1 := make(chan int, 1)
    ch2 := make(chan int, 1)
    
    ch1 <- 1
    ch2 <- 2
    
    // At least one should succeed
    var val int
    select {
    case val = <-ch1:
        assert(val == 1, "ch1 value should be 1")
    case val = <-ch2:
        assert(val == 2, "ch2 value should be 2")
    }
    
    // Test 2: Three channels all ready - run multiple times
    count1 := 0
    count2 := 0
    count3 := 0
    
    for i := 0; i < 100; i += 1 {
        a := make(chan int, 1)
        b := make(chan int, 1)
        c := make(chan int, 1)
        
        a <- 1
        b <- 2
        c <- 3
        
        select {
        case <-a:
            count1 += 1
        case <-b:
            count2 += 1
        case <-c:
            count3 += 1
        }
    }
    
    // All channels should be selected at least once if random
    // With 100 iterations and 3 choices, each should be picked ~33 times
    // We just check they're all picked at least once (very high probability)
    total := count1 + count2 + count3
    assert(total == 100, "total should be 100")
    // Note: Random selection means all three SHOULD be selected
    // but we can't strictly require it (extremely unlikely to fail)
    fmt.Println("select distribution: a=", count1, " b=", count2, " c=", count3)
    
    // Test 3: Send and receive both ready
    sendCh := make(chan int, 1)
    recvCh := make(chan int, 1)
    recvCh <- 42
    
    sendCount := 0
    recvCount := 0
    
    for i := 0; i < 50; i += 1 {
        // Reset channels
        sendCh = make(chan int, 1)
        recvCh = make(chan int, 1)
        recvCh <- 99
        
        select {
        case sendCh <- 1:
            sendCount += 1
        case <-recvCh:
            recvCount += 1
        }
    }
    
    totalOps := sendCount + recvCount
    assert(totalOps == 50, "total ops should be 50")
    fmt.Println("send/recv distribution: send=", sendCount, " recv=", recvCount)
    
    // Test 4: Default case not taken when other cases are ready
    ready := make(chan int, 1)
    ready <- 123
    
    defaultTaken := false
    select {
    case v := <-ready:
        assert(v == 123, "ready channel value")
    default:
        defaultTaken = true
    }
    assert(defaultTaken == false, "default should not be taken when channel is ready")
    
    fmt.Println("select_multi_ready: ok")
}

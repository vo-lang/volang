// Test: method values as first-class functions
// Go spec: t.M is a method value, a function that calls M with t as receiver
package main


import "fmt"
type Counter struct {
    value int
}

func (c *Counter) Inc() {
    c.value += 1
}

func (c *Counter) Add(n int) {
    c.value += n
}

func (c Counter) Get() int {
    return c.value
}

func (c Counter) Double() int {
    return c.value * 2
}

type Calculator struct {
    result int
}

func (c *Calculator) Apply(op func(int, int) int, a, b int) {
    c.result = op(a, b)
}

func add(a, b int) int { return a + b }
func mul(a, b int) int { return a * b }

func main() {
    // Test 1: Direct method call
    c := &Counter{value: 0}
    c.Inc()
    assert(c.value == 1, "direct method call works")
    
    // Test 2: Method value with pointer receiver
    var inc func() = c.Inc
    inc()
    assert(c.value == 2, "method value Inc")
    
    // Test 3: Multiple calls through method value
    inc()
    inc()
    assert(c.value == 4, "multiple method value calls")
    
    // Test 4: Method value with parameters
    addFn := c.Add
    addFn(10)
    assert(c.value == 14, "method value with params")
    
    // Test 5: Value receiver method value
    c2 := Counter{value: 100}
    getVal := c2.Get
    assert(getVal() == 100, "value receiver method value")
    
    // Test 6: Value receiver captures copy
    c2.value = 200
    assert(getVal() == 100, "value receiver captures copy at creation time")
    
    // Test 7: Interface method value
    var iface interface {
        Get() int
    } = Counter{value: 42}
    getFn := iface.Get
    assert(getFn() == 42, "interface method value")
    
    fmt.Println("method_value: ok")
}

// Test: Compound assignment with map and slice indexing
// Coverage: m[k] += v, s[i] *= v, etc.
package main


import "fmt"
func main() {
    // Test 1: Map compound assignment with +=
    m := map[string]int{"a": 10, "b": 20}
    m["a"] += 5
    assert(m["a"] == 15, "m[a] += 5 should give 15")
    
    // Test 2: Map compound assignment with -=
    m["b"] -= 3
    assert(m["b"] == 17, "m[b] -= 3 should give 17")
    
    // Test 3: Map compound assignment with *=
    m["a"] *= 2
    assert(m["a"] == 30, "m[a] *= 2 should give 30")
    
    // Test 4: Map compound assignment with new key
    m["c"] = 100
    m["c"] /= 4
    assert(m["c"] == 25, "m[c] /= 4 should give 25")
    
    // Test 5: Slice compound assignment with +=
    s := []int{1, 2, 3, 4, 5}
    s[0] += 10
    assert(s[0] == 11, "s[0] += 10 should give 11")
    
    // Test 6: Slice compound assignment with *=
    s[2] *= 3
    assert(s[2] == 9, "s[2] *= 3 should give 9")
    
    // Test 7: Array compound assignment
    arr := [3]int{10, 20, 30}
    arr[1] += 5
    assert(arr[1] == 25, "arr[1] += 5 should give 25")
    
    // Test 8: Nested map compound assignment
    nested := map[string]map[string]int{
        "outer": {"inner": 100},
    }
    nested["outer"]["inner"] += 50
    assert(nested["outer"]["inner"] == 150, "nested map += should work")
    
    // Test 9: Bitwise compound on map
    bits := map[string]int{"flags": 0x0F}
    bits["flags"] |= 0xF0
    assert(bits["flags"] == 0xFF, "bits |= should give 0xFF")
    bits["flags"] &= 0x55
    assert(bits["flags"] == 0x55, "bits &= should give 0x55")
    
    // Test 10: Shift compound on slice
    shifts := []int{1, 2, 4}
    shifts[0] <<= 3
    assert(shifts[0] == 8, "shifts[0] <<= 3 should give 8")
    shifts[2] >>= 1
    assert(shifts[2] == 2, "shifts[2] >>= 1 should give 2")
    
    fmt.Println("compound_assign_map: ok")
}

// Test: complex iota usage patterns
// Coverage: iota in various expressions
package main


import "fmt"
const (
    A0 = iota      // 0
    A1             // 1
    A2             // 2
)

const (
    B0 = iota * 10 // 0
    B1             // 10
    B2             // 20
)

const (
    _  = iota             // 0, skip
    KB = 1 << (10 * iota) // 1 << 10 = 1024
    MB                    // 1 << 20 = 1048576
    GB                    // 1 << 30 = 1073741824
)

const (
    C0 = 1 << iota // 1
    C1             // 2
    C2             // 4
    C3             // 8
)

const (
    D0, D1 = iota, iota + 10 // 0, 10
    D2, D3                   // 1, 11
    D4, D5                   // 2, 12
)

const (
    E0 = iota + 100 // 100
    _               // skip 101
    E2              // 102
    _               // skip 103
    E4              // 104
)

func main() {
    // Test 1: basic iota sequence
    assert(A0 == 0 && A1 == 1 && A2 == 2, "basic iota")
    
    // Test 2: iota with multiplication
    assert(B0 == 0 && B1 == 10 && B2 == 20, "iota * 10")
    
    // Test 3: bit shifting with iota (KB/MB/GB)
    assert(KB == 1024, "KB")
    assert(MB == 1048576, "MB")
    assert(GB == 1073741824, "GB")
    
    // Test 4: power of 2 with iota
    assert(C0 == 1 && C1 == 2 && C2 == 4 && C3 == 8, "1 << iota")
    
    // Test 5: multiple constants per line
    assert(D0 == 0 && D1 == 10, "D0, D1")
    assert(D2 == 1 && D3 == 11, "D2, D3")
    assert(D4 == 2 && D5 == 12, "D4, D5")
    
    // Test 6: skipping with blank identifier
    assert(E0 == 100 && E2 == 102 && E4 == 104, "skip with _")
    
    fmt.Println("const_iota_complex: ok")
}

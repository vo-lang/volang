package main


import "fmt"
// ============ Test 1: Empty interface ============
func testEmptyInterface() {
    var a interface{}
    
    // Assign int
    a = 42
    fmt.Println("empty interface int:", a)
    
    // Assign float
    a = 3.14
    fmt.Println("empty interface float:", a)
    
    // Assign string
    a = "hello"
    fmt.Println("empty interface string:", a)
    
    fmt.Println("Test 1 PASSED: empty interface")
}

// ============ Test 2: Named interface with struct ============
type Adder interface {
    Add() int
}

type MyNum struct {
    value int
}

func (m MyNum) Add() int {
    return m.value + 100
}

func testStructInterface() {
    var a Adder
    n := MyNum{value: 42}
    a = n
    
    result := a.Add()
    fmt.Println("struct interface Add():", result)
    assert(result == 142, "struct Add() should return 142")
    
    fmt.Println("Test 2 PASSED: struct implements interface")
}

// ============ Test 3: Named interface with object ============
type Counter struct {
    count int
}

func (c Counter) Add() int {
    c.count = c.count + 1
    return c.count
}

func testObjectInterface() {
    var a Adder
    c := Counter{count: 10}
    a = c
    
    result := a.Add()
    fmt.Println("object interface Add():", result)
    assert(result == 11, "object Add() should return 11")
    
    // Value semantics: each call operates on a copy, so count stays at 10
    // and Add() always returns 11 (10 + 1)
    result2 := a.Add()
    fmt.Println("object interface Add() again:", result2)
    assert(result2 == 11, "object Add() again should return 11 (value semantics)")
    
    fmt.Println("Test 3 PASSED: object implements interface")
}

// ============ Test 4: Multiple types same interface ============
type Doubler struct {
    value int
}

func (d Doubler) Add() int {
    return d.value * 2
}

func testMultipleTypes() {
    var a Adder
    
    // First assign MyNum
    n := MyNum{value: 10}
    a = n
    r1 := a.Add()
    fmt.Println("MyNum.Add():", r1)
    assert(r1 == 110, "MyNum.Add() should be 110")
    
    // Then assign Doubler
    d := Doubler{value: 10}
    a = d
    r2 := a.Add()
    fmt.Println("Doubler.Add():", r2)
    assert(r2 == 20, "Doubler.Add() should be 20")
    
    fmt.Println("Test 4 PASSED: multiple types implement same interface")
}

// ============ Test 5: Interface to interface assignment ============
type Reader interface {
    Read() int
}

type ReadWriter interface {
    Read() int
    Write(x int)
}

type File struct {
    data int
}

func (f File) Read() int {
    return f.data
}

func (f File) Write(x int) {
    f.data = x
}

func testInterfaceToInterface() {
    var r Reader
    var rw ReadWriter
    
    // File implements both interfaces
    f := File{data: 100}
    rw = f
    
    // ReadWriter -> Reader (superset to subset): OK
    r = rw
    result := r.Read()
    fmt.Println("Reader.Read():", result)
    assert(result == 100, "Reader.Read() should be 100")
    
    fmt.Println("Test 5 PASSED: interface to interface assignment")
}

// ============ Test 6: Named interface to empty interface ============
func testNamedToEmpty() {
    var e interface{}
    var a Adder
    
    n := MyNum{value: 50}
    a = n
    
    // Named interface -> empty interface: always OK
    e = a
    fmt.Println("empty interface from Adder:", e)
    
    fmt.Println("Test 6 PASSED: named interface to empty interface")
}

// ============ Main ============
func main() {
    testEmptyInterface()
    testStructInterface()
    testObjectInterface()
    testMultipleTypes()
    testInterfaceToInterface()
    testNamedToEmpty()
    
    fmt.Println("interface_test: ALL PASSED")
}

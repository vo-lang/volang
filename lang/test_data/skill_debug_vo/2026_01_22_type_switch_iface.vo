// Test: Type switch with interface cases and complex scenarios
// Focus: type switch ordering, interface cases, concrete vs interface
package main

import "fmt"

// ============================================
// Part 1: Basic Type Switch with Interfaces
// ============================================

type Reader interface {
    Read() string
}

type Writer interface {
    Write(s string)
}

type ReadWriter interface {
    Read() string
    Write(s string)
}

type Buffer struct {
    data string
}

func (b *Buffer) Read() string { return b.data }
func (b *Buffer) Write(s string) { b.data = s }

type OnlyReader struct {
    data string
}

func (r *OnlyReader) Read() string { return r.data }

// Test 1: Type switch matches concrete type first
func classifyType(x any) string {
    switch x.(type) {
    case *Buffer:
        return "Buffer"
    case *OnlyReader:
        return "OnlyReader"
    case Reader:
        return "Reader"
    default:
        return "unknown"
    }
}

func test1() {
    buf := &Buffer{data: "test"}
    result := classifyType(buf)
    assert(result == "Buffer", "test1: should match *Buffer first")
    fmt.Println("Test 1 PASSED: concrete type matched first")
}

// Test 2: Interface case when concrete not listed
type AnotherReader struct {
    content string
}

func (a *AnotherReader) Read() string { return a.content }

func test2() {
    ar := &AnotherReader{content: "another"}
    result := classifyType(ar)
    assert(result == "Reader", "test2: should match Reader interface")
    fmt.Println("Test 2 PASSED: interface case matched")
}

// ============================================
// Part 2: Type Switch with Interface Hierarchy
// ============================================

func classifyHierarchy(x any) string {
    switch x.(type) {
    case ReadWriter:
        return "ReadWriter"
    case Reader:
        return "Reader"
    case Writer:
        return "Writer"
    default:
        return "unknown"
    }
}

// Test 3: ReadWriter matches ReadWriter case (not Reader)
func test3() {
    buf := &Buffer{data: "test"}
    result := classifyHierarchy(buf)
    // Buffer implements ReadWriter, so should match ReadWriter case
    assert(result == "ReadWriter", "test3: should match ReadWriter")
    fmt.Println("Test 3 PASSED: ReadWriter matched for Buffer")
}

// Test 4: Reader-only type matches Reader case
func test4() {
    or := &OnlyReader{data: "only"}
    result := classifyHierarchy(or)
    assert(result == "Reader", "test4: should match Reader")
    fmt.Println("Test 4 PASSED: Reader matched for OnlyReader")
}

// ============================================
// Part 3: Type Switch with Value Capture
// ============================================

func processReader(x any) string {
    switch v := x.(type) {
    case *Buffer:
        return "Buffer:" + v.Read()
    case Reader:
        return "Reader:" + v.Read()
    default:
        return "unknown"
    }
}

// Test 5: Captured value in concrete case
func test5() {
    buf := &Buffer{data: "captured"}
    result := processReader(buf)
    assert(result == "Buffer:captured", "test5: captured buffer value")
    fmt.Println("Test 5 PASSED: captured concrete value")
}

// Test 6: Captured value in interface case
func test6() {
    or := &OnlyReader{data: "interface"}
    result := processReader(or)
    assert(result == "Reader:interface", "test6: captured interface value")
    fmt.Println("Test 6 PASSED: captured interface value")
}

// ============================================
// Part 4: Type Switch with Multiple Types per Case
// ============================================

func classifyMulti(x any) string {
    switch x.(type) {
    case int, int8, int16, int32, int64:
        return "signed int"
    case uint, uint8, uint16, uint32, uint64:
        return "unsigned int"
    case float32, float64:
        return "float"
    case string:
        return "string"
    case bool:
        return "bool"
    default:
        return "other"
    }
}

// Test 7: Multiple types per case - int
func test7() {
    assert(classifyMulti(42) == "signed int", "test7: int")
    assert(classifyMulti(int64(100)) == "signed int", "test7: int64")
    fmt.Println("Test 7 PASSED: multiple types case - signed int")
}

// Test 8: Multiple types per case - uint
func test8() {
    assert(classifyMulti(uint(10)) == "unsigned int", "test8: uint")
    assert(classifyMulti(uint32(20)) == "unsigned int", "test8: uint32")
    fmt.Println("Test 8 PASSED: multiple types case - unsigned int")
}

// Test 9: Multiple types per case - float
func test9() {
    assert(classifyMulti(3.14) == "float", "test9: float64")
    assert(classifyMulti(float32(2.5)) == "float", "test9: float32")
    fmt.Println("Test 9 PASSED: multiple types case - float")
}

// ============================================
// Part 5: Type Switch with nil
// ============================================

func classifyNil(x any) string {
    switch x.(type) {
    case nil:
        return "nil"
    case int:
        return "int"
    default:
        return "other"
    }
}

// Test 10: nil case matches nil interface
func test10() {
    var a any = nil
    result := classifyNil(a)
    assert(result == "nil", "test10: nil should match nil case")
    fmt.Println("Test 10 PASSED: nil case matched")
}

// Test 11: non-nil doesn't match nil case
func test11() {
    var a any = 42
    result := classifyNil(a)
    assert(result == "int", "test11: int should not match nil case")
    fmt.Println("Test 11 PASSED: non-nil doesn't match nil")
}

// ============================================
// Part 6: Type Switch Fallthrough-like Behavior
// ============================================

type Stringer interface {
    String() string
}

type Named struct {
    name string
}

func (n Named) String() string { return n.name }

func describeAny(x any) string {
    switch v := x.(type) {
    case Stringer:
        return "Stringer: " + v.String()
    case int:
        return fmt.Sprintf("int: %d", v)
    case string:
        return "string: " + v
    default:
        return "unknown"
    }
}

// Test 12: Stringer interface matched
func test12() {
    n := Named{name: "Bob"}
    result := describeAny(n)
    assert(result == "Stringer: Bob", "test12: Named implements Stringer")
    fmt.Println("Test 12 PASSED: Stringer interface in type switch")
}

// ============================================
// Part 7: Type Switch in Loop
// ============================================

func countTypes(items []any) (ints, strings, others int) {
    for _, item := range items {
        switch item.(type) {
        case int:
            ints++
        case string:
            strings++
        default:
            others++
        }
    }
    return
}

// Test 13: Type switch in loop
func test13() {
    items := []any{1, "a", 2, "b", 3.14, true}
    ints, strings, others := countTypes(items)
    assert(ints == 2, "test13: should have 2 ints")
    assert(strings == 2, "test13: should have 2 strings")
    assert(others == 2, "test13: should have 2 others")
    fmt.Println("Test 13 PASSED: type switch in loop")
}

// ============================================
// Part 8: Nested Type Switch
// ============================================

func nestedSwitch(x, y any) string {
    switch x.(type) {
    case int:
        switch y.(type) {
        case int:
            return "int,int"
        case string:
            return "int,string"
        default:
            return "int,other"
        }
    case string:
        switch y.(type) {
        case int:
            return "string,int"
        default:
            return "string,other"
        }
    default:
        return "other,any"
    }
}

// Test 14: Nested type switch
func test14() {
    assert(nestedSwitch(1, 2) == "int,int", "test14: int,int")
    assert(nestedSwitch(1, "a") == "int,string", "test14: int,string")
    assert(nestedSwitch("a", 1) == "string,int", "test14: string,int")
    assert(nestedSwitch(3.14, true) == "other,any", "test14: other,any")
    fmt.Println("Test 14 PASSED: nested type switch")
}

// ============================================
// Part 9: Type Switch with Pointer and Value
// ============================================

type Point struct {
    x, y int
}

func classifyPoint(x any) string {
    switch x.(type) {
    case *Point:
        return "pointer"
    case Point:
        return "value"
    default:
        return "other"
    }
}

// Test 15: Pointer vs value in type switch
func test15() {
    p := Point{1, 2}
    pp := &Point{3, 4}
    
    assert(classifyPoint(p) == "value", "test15: Point value")
    assert(classifyPoint(pp) == "pointer", "test15: *Point pointer")
    fmt.Println("Test 15 PASSED: pointer vs value in type switch")
}

func main() {
    test1()
    test2()
    test3()
    test4()
    test5()
    test6()
    test7()
    test8()
    test9()
    test10()
    test11()
    test12()
    test13()
    test14()
    test15()
    
    fmt.Println("")
    fmt.Println("=== type_switch_iface: ALL 15 TESTS PASSED ===")
}

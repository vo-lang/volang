package main

import "fmt"

type Stringer interface {
	String() string
}

type Named interface {
	Name() string
}

type Both interface {
	String() string
	Name() string
}

type MyVal struct {
	msg string
}

func (v MyVal) String() string {
	return v.msg
}

func (v MyVal) Name() string {
	return "MyVal:" + v.msg
}

// Test 1: Return concrete, assign to different interfaces
func getVal() MyVal {
	return MyVal{msg: "test1"}
}

func test1() {
	fmt.Println("Test 1: Concrete to multiple interface types")
	var s Stringer = getVal()
	var n Named = getVal()
	var b Both = getVal()
	assert(s.String() == "test1", "test1: s wrong")
	assert(n.Name() == "MyVal:test1", "test1: n wrong")
	assert(b.String() == "test1", "test1: b.String wrong")
	assert(b.Name() == "MyVal:test1", "test1: b.Name wrong")
	fmt.Println("Test 1 PASSED")
}

// Test 2: Multi-return with interface-to-interface conversion
func getBothAndInt() (Both, int) {
	return MyVal{msg: "test2"}, 42
}

func test2() {
	fmt.Println("Test 2: Multi-return (Both, int) to (Stringer, int)")
	var s Stringer
	var n int
	s, n = getBothAndInt()
	assert(s != nil, "test2: s is nil")
	assert(n == 42, "test2: n wrong")
	assert(s.String() == "test2", "test2: s.String wrong")
	fmt.Println("Test 2 PASSED")
}

// Test 3: any to Stringer conversion
func getAnyVal() any {
	return MyVal{msg: "test3"}
}

func test3() {
	fmt.Println("Test 3: any to Stringer via type assertion")
	a := getAnyVal()
	s := a.(Stringer)
	assert(s.String() == "test3", "test3: wrong value")
	fmt.Println("Test 3 PASSED")
}

// Test 4: Multi-return with type assertion
func getAnyAndInt() (any, int) {
	return MyVal{msg: "test4"}, 100
}

func test4() {
	fmt.Println("Test 4: Multi-return (any, int) with type assertion on first")
	a, n := getAnyAndInt()
	s := a.(Stringer)
	assert(s.String() == "test4", "test4: s wrong")
	assert(n == 100, "test4: n wrong")
	fmt.Println("Test 4 PASSED")
}

// Test 5: Comma-ok type assertion
func test5() {
	fmt.Println("Test 5: Comma-ok type assertion")
	a, _ := getAnyAndInt()
	s, ok := a.(Stringer)
	assert(ok, "test5: type assertion failed")
	assert(s.String() == "test4", "test5: s wrong")
	
	// Negative case
	_, ok2 := a.(int)
	assert(!ok2, "test5: should not be int")
	fmt.Println("Test 5 PASSED")
}

// Test 6: Interface method returns interface
type Factory interface {
	Make() Stringer
}

type MyFactory struct{}

func (f MyFactory) Make() Stringer {
	return MyVal{msg: "factory"}
}

func test6() {
	fmt.Println("Test 6: Interface method returns interface")
	var f Factory = MyFactory{}
	s := f.Make()
	assert(s.String() == "factory", "test6: wrong value")
	fmt.Println("Test 6 PASSED")
}

// Test 7: Chained interface conversions
func passStringer(s Stringer) Stringer {
	return s
}

func test7() {
	fmt.Println("Test 7: Chained interface pass-through")
	var a any = MyVal{msg: "chain"}
	s1 := a.(Stringer)
	s2 := passStringer(s1)
	var a2 any = s2
	s3 := a2.(Stringer)
	assert(s3.String() == "chain", "test7: wrong value")
	fmt.Println("Test 7 PASSED")
}

func main() {
	test1()
	fmt.Println("")
	test2()
	fmt.Println("")
	test3()
	fmt.Println("")
	test4()
	fmt.Println("")
	test5()
	fmt.Println("")
	test6()
	fmt.Println("")
	test7()
	fmt.Println("")
	fmt.Println("=== ALL TESTS PASSED ===")
}

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

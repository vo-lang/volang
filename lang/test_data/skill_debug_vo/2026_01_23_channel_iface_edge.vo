package main

// Test channels with interface types

func main() {
	// Test 1: Channel of any
	ch1 := make(chan any, 3)
	ch1 <- 1
	ch1 <- "hello"
	ch1 <- true
	
	v1 := <-ch1
	assert(v1.(int) == 1, "test1: recv int from any chan")
	v2 := <-ch1
	assert(v2.(string) == "hello", "test1: recv string from any chan")
	v3 := <-ch1
	assert(v3.(bool) == true, "test1: recv bool from any chan")
	
	// Test 2: Select with any channel
	ch2 := make(chan any, 1)
	ch2 <- 42
	
	select {
	case v := <-ch2:
		assert(v.(int) == 42, "test2: select recv any")
	default:
		panic("test2: should not reach default")
	}
	
	// Test 3: Send interface to channel
	type Counter struct {
		val int
	}
	ch3 := make(chan any, 1)
	c := &Counter{val: 100}
	ch3 <- c
	
	recv := <-ch3
	counter := recv.(*Counter)
	assert(counter.val == 100, "test3: recv struct pointer from any chan")
	
	// Test 4: Range over buffered any channel
	ch4 := make(chan any, 3)
	ch4 <- 10
	ch4 <- 20
	ch4 <- 30
	close(ch4)
	
	sum := 0
	for v := range ch4 {
		sum += v.(int)
	}
	assert(sum == 60, "test4: range over any chan")
	
	// Test 5: Channel in slice
	chans := []chan any{make(chan any, 1), make(chan any, 1)}
	chans[0] <- "first"
	chans[1] <- "second"
	
	assert((<-chans[0]).(string) == "first", "test5: chan slice first")
	assert((<-chans[1]).(string) == "second", "test5: chan slice second")
}

func assert(cond bool, msg string) {
	if !cond {
		panic("assertion failed: " + msg)
	}
}

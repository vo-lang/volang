package main

import "errors"

// Test closure returning interface with type conversion

type Stringer interface {
	String() string
}

type MyInt int

func (m MyInt) String() string {
	return "MyInt"
}

type MyString string

func (m MyString) String() string {
	return string(m)
}

func testClosureReturningInterface() {
	// Closure that returns interface from concrete type
	makeStringer := func(useInt bool) Stringer {
		if useInt {
			return MyInt(42)
		}
		return MyString("hello")
	}
	
	s1 := makeStringer(true)
	assert(s1.String() == "MyInt", "should be MyInt")
	
	s2 := makeStringer(false)
	assert(s2.String() == "hello", "should be hello")
}

func testClosureCapturingInterface() {
	var s Stringer = MyInt(10)
	
	getStr := func() string {
		return s.String()
	}
	
	assert(getStr() == "MyInt", "captured interface should work")
	
	// Modify the captured interface
	s = MyString("changed")
	assert(getStr() == "changed", "should see updated interface")
}

func testClosureModifyingInterface() {
	var s Stringer = MyInt(1)
	
	toggle := func() {
		if _, ok := s.(MyInt); ok {
			s = MyString("string now")
		} else {
			s = MyInt(999)
		}
	}
	
	assert(s.String() == "MyInt", "initial")
	toggle()
	assert(s.String() == "string now", "after first toggle")
	toggle()
	assert(s.String() == "MyInt", "after second toggle")
}

func testNestedClosureWithInterface() {
	var s Stringer = MyInt(1)
	
	outer := func() func() string {
		return func() string {
			return s.String()
		}
	}
	
	inner := outer()
	assert(inner() == "MyInt", "nested closure should work")
	
	s = MyString("nested")
	assert(inner() == "nested", "nested closure should see update")
}

func testClosureReturningConcreteAsInterface() (Stringer, error) {
	f := func() (Stringer, error) {
		return MyInt(42), nil
	}
	return f()
}

func testDirectReturnOfClosureCall() {
	s, err := testClosureReturningConcreteAsInterface()
	assert(err == nil, "no error")
	assert(s.String() == "MyInt", "should work")
}

func testClosureWithInterfaceSlice() {
	var items []Stringer
	items = append(items, MyInt(1))
	items = append(items, MyString("two"))
	items = append(items, MyInt(3))
	
	getAll := func() []string {
		var result []string
		for _, item := range items {
			result = append(result, item.String())
		}
		return result
	}
	
	strs := getAll()
	assert(len(strs) == 3, "should have 3 items")
	assert(strs[0] == "MyInt", "first")
	assert(strs[1] == "two", "second")
	assert(strs[2] == "MyInt", "third")
}

func testClosureReturningInterfaceFromMap() {
	m := make(map[string]Stringer)
	m["int"] = MyInt(100)
	m["str"] = MyString("mapped")
	
	getter := func(key string) Stringer {
		return m[key]
	}
	
	assert(getter("int").String() == "MyInt", "map int")
	assert(getter("str").String() == "mapped", "map str")
	
	// Test nil return
	nilVal := getter("nonexistent")
	assert(nilVal == nil, "nonexistent key should return nil")
}

func testClosureInterfaceInDefer() {
	var result string
	
	f := func() {
		var s Stringer = MyInt(1)
		defer func() {
			result = s.String()
		}()
		s = MyString("deferred")
		// defer should see the updated value
	}
	
	f()
	assert(result == "deferred", "defer should see updated interface, got %s", result)
}

func testClosureInterfaceReturnError() (result Stringer, err error) {
	f := func() (Stringer, error) {
		return nil, errors.New("test error")
	}
	
	return f()
}

func testClosureErrorReturn() {
	s, err := testClosureInterfaceReturnError()
	assert(s == nil, "should be nil")
	assert(err != nil, "should have error")
}

func main() {
	testClosureReturningInterface()
	testClosureCapturingInterface()
	testClosureModifyingInterface()
	testNestedClosureWithInterface()
	testDirectReturnOfClosureCall()
	testClosureWithInterfaceSlice()
	testClosureReturningInterfaceFromMap()
	testClosureInterfaceInDefer()
	testClosureErrorReturn()
	
	println("All closure interface return convert tests passed!")
}

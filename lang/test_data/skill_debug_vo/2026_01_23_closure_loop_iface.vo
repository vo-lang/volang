// Test: Closure capturing loop variables with interface conversion
// Coverage: Loop variable capture, interface boxing in closures
package main

import "fmt"

// Test 1: Closure capturing loop variable as interface
func testLoopCaptureAny() {
	var funcs []func() any
	
	for i := 0; i < 3; i++ {
		i := i // shadow to capture copy
		funcs = append(funcs, func() any {
			return i
		})
	}
	
	assert(funcs[0]().(int) == 0, "test1: func[0] should return 0")
	assert(funcs[1]().(int) == 1, "test1: func[1] should return 1")
	assert(funcs[2]().(int) == 2, "test1: func[2] should return 2")
}

// Test 2: Closure capturing without shadow (should capture last value)
func testLoopCaptureNoShadow() {
	var funcs []func() int
	
	for i := 0; i < 3; i++ {
		funcs = append(funcs, func() int {
			return i
		})
	}
	
	// All should return 3 (loop end value)
	assert(funcs[0]() == 3, "test2: func[0] should return 3")
	assert(funcs[1]() == 3, "test2: func[1] should return 3")
	assert(funcs[2]() == 3, "test2: func[2] should return 3")
}

// Test 3: Closure modifying captured loop variable
func testLoopCaptureModify() {
	results := make([]int, 3)
	
	for i := 0; i < 3; i++ {
		i := i
		func() {
			i = i * 10
			results[i/10] = i
		}()
	}
	
	assert(results[0] == 0, "test3: results[0]")
	assert(results[1] == 10, "test3: results[1]")
	assert(results[2] == 20, "test3: results[2]")
}

// Test 4: Nested closure with loop variable
func testNestedClosureLoop() {
	var funcs []func() func() int
	
	for i := 0; i < 3; i++ {
		i := i
		funcs = append(funcs, func() func() int {
			return func() int {
				return i * i
			}
		})
	}
	
	assert(funcs[0]()() == 0, "test4: 0*0")
	assert(funcs[1]()() == 1, "test4: 1*1")
	assert(funcs[2]()() == 4, "test4: 2*2")
}

// Test 5: For-range with closure capture
func testRangeClosureCapture() {
	slice := []string{"a", "b", "c"}
	var funcs []func() string
	
	for _, s := range slice {
		s := s
		funcs = append(funcs, func() string {
			return s
		})
	}
	
	assert(funcs[0]() == "a", "test5: func[0]")
	assert(funcs[1]() == "b", "test5: func[1]")
	assert(funcs[2]() == "c", "test5: func[2]")
}

// Test 6: Closure with struct loop variable
func testLoopStructCapture() {
	type Item struct {
		id   int
		name string
	}
	
	items := []Item{{1, "one"}, {2, "two"}, {3, "three"}}
	var funcs []func() Item
	
	for _, item := range items {
		item := item
		funcs = append(funcs, func() Item {
			return item
		})
	}
	
	assert(funcs[0]().id == 1, "test6: item 1")
	assert(funcs[1]().id == 2, "test6: item 2")
	assert(funcs[2]().id == 3, "test6: item 3")
}

// Test 7: Closure capturing index and value
func testLoopIndexValueCapture() {
	slice := []int{10, 20, 30}
	var funcs []func() (int, int)
	
	for i, v := range slice {
		i, v := i, v
		funcs = append(funcs, func() (int, int) {
			return i, v
		})
	}
	
	i0, v0 := funcs[0]()
	assert(i0 == 0 && v0 == 10, "test7: index 0")
	i1, v1 := funcs[1]()
	assert(i1 == 1 && v1 == 20, "test7: index 1")
	i2, v2 := funcs[2]()
	assert(i2 == 2 && v2 == 30, "test7: index 2")
}

// Test 8: Closure returning interface from loop
func testLoopClosureReturnIface() {
	var funcs []func() any
	
	for i := 0; i < 3; i++ {
		i := i
		funcs = append(funcs, func() any {
			if i%2 == 0 {
				return "even"
			}
			return i
		})
	}
	
	assert(funcs[0]().(string) == "even", "test8: 0 is even")
	assert(funcs[1]().(int) == 1, "test8: 1 is odd")
	assert(funcs[2]().(string) == "even", "test8: 2 is even")
}

// Test 9: Defer in loop with closure (using named return)
func testDeferLoopClosure() (results []int) {
	results = []int{}
	
	for i := 0; i < 3; i++ {
		i := i
		defer func() {
			results = append(results, i)
		}()
	}
	
	return // defers modify named return
}

// Test 10: Map iteration with closure capture
func testMapClosureCapture() {
	m := map[string]int{"a": 1, "b": 2, "c": 3}
	var funcs []func() int
	keys := []string{}
	
	for k, v := range m {
		k, v := k, v
		keys = append(keys, k)
		funcs = append(funcs, func() int {
			return v
		})
	}
	
	// Map iteration order is not guaranteed, but captured values should match
	for i, k := range keys {
		expected := m[k]
		actual := funcs[i]()
		assert(actual == expected, "test10: map capture mismatch")
	}
}

func main() {
	testLoopCaptureAny()
	fmt.Println("Test 1: PASSED")
	
	testLoopCaptureNoShadow()
	fmt.Println("Test 2: PASSED")
	
	testLoopCaptureModify()
	fmt.Println("Test 3: PASSED")
	
	testNestedClosureLoop()
	fmt.Println("Test 4: PASSED")
	
	testRangeClosureCapture()
	fmt.Println("Test 5: PASSED")
	
	testLoopStructCapture()
	fmt.Println("Test 6: PASSED")
	
	testLoopIndexValueCapture()
	fmt.Println("Test 7: PASSED")
	
	testLoopClosureReturnIface()
	fmt.Println("Test 8: PASSED")
	
	results := testDeferLoopClosure()
	// Defers run in reverse order: 2, 1, 0
	assert(len(results) == 3, "test9: should have 3 results")
	assert(results[0] == 2, "test9: first defer is 2")
	assert(results[1] == 1, "test9: second defer is 1")
	assert(results[2] == 0, "test9: third defer is 0")
	fmt.Println("Test 9: PASSED")
	
	testMapClosureCapture()
	fmt.Println("Test 10: PASSED")
	
	fmt.Println("closure_loop_iface: ALL PASSED")
}

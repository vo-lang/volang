package main

// Test: Dynamic access (~>) and variadic function edge cases

type Data struct {
	Name  string
	Value int
	Items []int
}

type Container struct {
	Data
	extra string
}

func variadicSum(nums ...int) int {
	sum := 0
	for _, n := range nums {
		sum += n
	}
	return sum
}

func variadicWithPrefix(prefix string, vals ...int) string {
	result := prefix
	for _, v := range vals {
		result += string(rune('0' + v))
	}
	return result
}

func variadicAny(items ...any) int {
	return len(items)
}

func spreadSlice(s []int) int {
	return variadicSum(s...)
}

func main() {
	// Test 1: Basic variadic call
	assert(variadicSum(1, 2, 3) == 6)
	assert(variadicSum() == 0)
	assert(variadicSum(10) == 10)

	// Test 2: Variadic with spread
	nums := []int{1, 2, 3, 4, 5}
	assert(variadicSum(nums...) == 15)

	// Test 3: Variadic with prefix and spread
	vals := []int{1, 2, 3}
	result := variadicWithPrefix("X", vals...)
	assert(result == "X123")

	// Test 4: Variadic any
	assert(variadicAny(1, "two", 3.0) == 3)
	assert(variadicAny() == 0)

	// Test 5: Spread through function
	assert(spreadSlice([]int{10, 20, 30}) == 60)

	// Test 6: Dynamic access on struct
	d := Data{Name: "test", Value: 42, Items: []int{1, 2, 3}}
	var a any = d
	
	name, err := a~>Name
	assert(err == nil)
	assert(name.(string) == "test")

	val, err := a~>Value
	assert(err == nil)
	assert(val.(int) == 42)

	// Test 7: Dynamic access on pointer to struct
	dp := &Data{Name: "ptr", Value: 100}
	var ap any = dp
	
	pname, err := ap~>Name
	assert(err == nil)
	assert(pname.(string) == "ptr")

	// Test 8: Dynamic access on embedded field
	c := Container{Data: Data{Name: "inner", Value: 50}, extra: "ext"}
	var ac any = c
	
	// Access embedded field
	ename, err := ac~>Name
	assert(err == nil)
	assert(ename.(string) == "inner")

	// Test 9: Dynamic access non-existent field
	_, err = ac~>NotExist
	assert(err != nil)

	// Test 10: Dynamic access with question mark operator
	d2 := Data{Name: "test2", Value: 99}
	var a2 any = d2
	
	checkDyn := func() (result string, err error) {
		var name string
		name = a2~>Name?
		return name, nil
	}
	r, e := checkDyn()
	assert(e == nil)
	assert(r == "test2")

	// Test 11: Variadic closure
	varClosure := func(xs ...int) int {
		total := 0
		for _, x := range xs {
			total += x
		}
		return total
	}
	assert(varClosure(1, 2, 3, 4) == 10)

	// Test 12: Variadic with single element slice
	single := []int{42}
	assert(variadicSum(single...) == 42)

	// Test 13: Variadic with empty slice
	empty := []int{}
	assert(variadicSum(empty...) == 0)

	// Test 14: Nested struct dynamic access
	type Outer struct {
		Inner Data
	}
	o := Outer{Inner: Data{Name: "nested", Value: 123}}
	var ao any = o
	
	inner, err := ao~>Inner
	assert(err == nil)
	
	// Access field of inner
	innerName, err := inner~>Name
	assert(err == nil)
	assert(innerName.(string) == "nested")

	// Test 15: Map dynamic access
	m := map[string]int{"a": 1, "b": 2}
	var am any = m
	
	aVal, err := am~>["a"]
	assert(err == nil)
	assert(aVal.(int) == 1)

	// Test 16: Slice dynamic access
	s := []int{10, 20, 30}
	var as any = s
	
	elem, err := as~>[1]
	assert(err == nil)
	assert(elem.(int) == 20)

	// Test 17: Variadic with mixed types via any
	mixedVar := func(items ...any) string {
		result := ""
		for _, item := range items {
			switch v := item.(type) {
			case int:
				result += "i"
			case string:
				result += "s"
			default:
				_ = v
				result += "?"
			}
		}
		return result
	}
	assert(mixedVar(1, "a", 2, "b") == "isis")

	// Test 18: Variadic in defer
	collected := make([]int, 0)
	func() {
		defer func() {
			collected = append(collected, variadicSum(1, 2, 3))
		}()
	}()
	assert(len(collected) == 1)
	assert(collected[0] == 6)

	// Test 19: Spread in method call context
	type Collector struct {
		sum int
	}
	collect := func(c *Collector, nums ...int) {
		for _, n := range nums {
			c.sum += n
		}
	}
	col := &Collector{sum: 0}
	toAdd := []int{5, 10, 15}
	collect(col, toAdd...)
	assert(col.sum == 30)

	// Test 20: Dynamic method call
	type Greeter struct {
		greeting string
	}
	greet := func(g *Greeter) string {
		return g.greeting
	}
	gr := &Greeter{greeting: "Hello"}
	var ag any = gr
	
	// Can't directly call method via ~>, but can access field
	gfield, err := ag~>greeting
	assert(err == nil)
	assert(gfield.(string) == "Hello")
	_ = greet

	println("PASS")
}

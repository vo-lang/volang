package main

import "fmt"

// Test numeric and slice edge cases

// Test 1: Integer overflow behavior
func test1() {
	fmt.Println("Test 1: integer overflow")
	
	var maxInt int = 9223372036854775807  // max int64
	overflow := maxInt + 1
	assert(overflow < 0, "overflow should wrap to negative")
}

// Test 2: Integer underflow behavior
func test2() {
	fmt.Println("Test 2: integer underflow")
	
	var minInt int = -9223372036854775808  // min int64
	underflow := minInt - 1
	assert(underflow > 0, "underflow should wrap to positive")
}

// Test 3: Slice capacity edge cases
func test3() {
	fmt.Println("Test 3: slice capacity")
	
	s := make([]int, 0, 10)
	assert(len(s) == 0, "len should be 0")
	assert(cap(s) == 10, "cap should be 10")
	
	s = append(s, 1, 2, 3)
	assert(len(s) == 3, "len should be 3")
	assert(cap(s) == 10, "cap should still be 10")
	
	// Reslice to capacity
	s = s[:cap(s)]
	assert(len(s) == 10, "len should be 10 after reslice")
}

// Test 4: Slice bounds at exact capacity
func test4() {
	fmt.Println("Test 4: slice bounds at capacity")
	
	s := []int{1, 2, 3, 4, 5}
	sub := s[2:5]  // exactly to end
	
	assert(len(sub) == 3, "sub len should be 3")
	assert(sub[0] == 3, "sub[0] should be 3")
	assert(sub[2] == 5, "sub[2] should be 5")
}

// Test 5: Empty slice operations
func test5() {
	fmt.Println("Test 5: empty slice operations")
	
	var s []int
	assert(len(s) == 0, "nil slice len should be 0")
	assert(cap(s) == 0, "nil slice cap should be 0")
	
	s = append(s, 1)
	assert(len(s) == 1, "after append len should be 1")
}

// Test 6: Slice aliasing
func test6() {
	fmt.Println("Test 6: slice aliasing")
	
	original := []int{1, 2, 3, 4, 5}
	alias := original[1:4]
	
	alias[0] = 100
	assert(original[1] == 100, "original should see modification")
}

// Test 7: Append growing slice
func test7() {
	fmt.Println("Test 7: append growing slice")
	
	s := []int{1}
	originalCap := cap(s)
	
	for i := 0; i < 100; i++ {
		s = append(s, i)
	}
	
	assert(len(s) == 101, "len should be 101")
	assert(cap(s) > originalCap, "cap should have grown")
}

// Test 8: Three-index slice
func test8() {
	fmt.Println("Test 8: three-index slice")
	
	s := []int{1, 2, 3, 4, 5}
	sub := s[1:3:4]  // start:end:max
	
	assert(len(sub) == 2, "len should be 2")
	assert(cap(sub) == 3, "cap should be 3 (4-1)")
}

// Test 9: Copy with overlap prevention
func test9() {
	fmt.Println("Test 9: copy builtin")
	
	src := []int{1, 2, 3}
	dst := make([]int, 5)
	
	n := copy(dst, src)
	assert(n == 3, "should copy 3 elements")
	assert(dst[0] == 1, "dst[0] should be 1")
	assert(dst[2] == 3, "dst[2] should be 3")
	assert(dst[3] == 0, "dst[3] should be 0")
}

// Test 10: Bitwise operations on large numbers
func test10() {
	fmt.Println("Test 10: bitwise operations")
	
	a := int64(0x7FFFFFFFFFFFFFFF)  // max int64
	b := int64(0x0000000000000001)
	
	and := a & b
	assert(and == 1, "AND should be 1")
	
	xor := a ^ b
	assert(xor == int64(0x7FFFFFFFFFFFFFFE), "XOR should flip last bit")
}

// Test 11: Shift operations
func test11() {
	fmt.Println("Test 11: shift operations")
	
	x := 1
	
	left := x << 10
	assert(left == 1024, "1 << 10 should be 1024")
	
	right := left >> 5
	assert(right == 32, "1024 >> 5 should be 32")
}

// Test 12: Division and modulo
func test12() {
	fmt.Println("Test 12: division and modulo")
	
	a := 17
	b := 5
	
	div := a / b
	mod := a % b
	
	assert(div == 3, "17 / 5 should be 3")
	assert(mod == 2, "17 % 5 should be 2")
	
	// Negative numbers
	negDiv := -17 / 5
	negMod := -17 % 5
	
	assert(negDiv == -3, "-17 / 5 should be -3")
	assert(negMod == -2, "-17 % 5 should be -2")
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	test11()
	test12()
	
	fmt.Println("numeric_slice_edge: ALL TESTS PASSED")
}

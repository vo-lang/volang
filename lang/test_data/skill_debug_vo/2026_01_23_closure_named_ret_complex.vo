package main

// Test: Complex interactions between closures, named returns, and defer

func simpleNamedRet() (result int) {
	result = 10
	return
}

func namedRetWithDefer() (result int) {
	defer func() {
		result += 5
	}()
	result = 10
	return
}

func namedRetWithDeferModify() (result int) {
	result = 10
	defer func() {
		result *= 2
	}()
	return result // explicit return
}

func closureModifiesNamedRet() (result int) {
	modify := func() {
		result = 42
	}
	modify()
	return
}

func closureReadsNamedRet() (result int) {
	result = 100
	read := func() int {
		return result
	}
	result = 200
	return read()
}

func deferClosureModifiesNamedRet() (result int) {
	result = 10
	defer func() {
		result = result * 2
	}()
	return 5 // returns 10 (5 assigned to result, then doubled by defer)
}

func multiNamedRet() (a, b int) {
	a = 1
	b = 2
	return
}

func multiNamedRetWithDefer() (a, b int) {
	defer func() {
		a += 10
		b += 20
	}()
	a = 1
	b = 2
	return
}

func namedRetWithEarlyReturn() (result int) {
	defer func() {
		result += 1
	}()
	
	if true {
		result = 5
		return
	}
	result = 10
	return
}

func nestedClosure() (result int) {
	outer := func() {
		inner := func() {
			result = 999
		}
		inner()
	}
	outer()
	return
}

func closureCaptureThenModify() (result int) {
	capture := func() int {
		return result
	}
	result = 50
	captured := capture()
	result = 100
	return captured + result
}

func deferWithMultipleLevels() (result int) {
	result = 1
	defer func() {
		result *= 10 // runs last
	}()
	defer func() {
		result += 5 // runs second
	}()
	defer func() {
		result *= 2 // runs first
	}()
	return // result = ((1 * 2) + 5) * 10 = 70
}

func namedReturnInLoop() (result int) {
	for i := 0; i < 5; i++ {
		result += i
	}
	return
}

func closureInLoop() (result int) {
	var closures []func()
	for i := 0; i < 3; i++ {
		i := i // capture loop var
		closures = append(closures, func() {
			result += i
		})
	}
	for _, c := range closures {
		c()
	}
	return
}

func panicRecoverNamedRet() (result int) {
	defer func() {
		if r := recover(); r != nil {
			result = -1
		}
	}()
	result = 100
	panic("test")
	return
}

func conditionalDefer() (result int) {
	result = 10
	cond := true
	if cond {
		defer func() {
			result += 5
		}()
	}
	return
}

func main() {
	// Test 1: Simple named return
	assert(simpleNamedRet() == 10)

	// Test 2: Named return with defer modification
	assert(namedRetWithDefer() == 15)

	// Test 3: Named return with defer and explicit return
	assert(namedRetWithDeferModify() == 20)

	// Test 4: Closure modifies named return
	assert(closureModifiesNamedRet() == 42)

	// Test 5: Closure reads named return
	assert(closureReadsNamedRet() == 200)

	// Test 6: Defer closure modifies explicit return value
	assert(deferClosureModifiesNamedRet() == 10)

	// Test 7: Multiple named returns
	a, b := multiNamedRet()
	assert(a == 1)
	assert(b == 2)

	// Test 8: Multiple named returns with defer
	c, d := multiNamedRetWithDefer()
	assert(c == 11)
	assert(d == 22)

	// Test 9: Early return with defer
	assert(namedRetWithEarlyReturn() == 6)

	// Test 10: Nested closure modifying named return
	assert(nestedClosure() == 999)

	// Test 11: Closure capture timing
	assert(closureCaptureThenModify() == 150)

	// Test 12: Multiple defers with named return (LIFO order)
	assert(deferWithMultipleLevels() == 70)

	// Test 13: Named return in loop
	assert(namedReturnInLoop() == 10) // 0+1+2+3+4

	// Test 14: Closures in loop modifying named return
	assert(closureInLoop() == 3) // 0+1+2

	// Test 15: Panic/recover with named return
	assert(panicRecoverNamedRet() == -1)

	// Test 16: Conditional defer
	assert(conditionalDefer() == 15)

	println("PASS")
}

// Test: Switch with interface tag expression
package main

type Comparer interface {
	Compare(other int) int
}

type MyInt int

func (m MyInt) Compare(other int) int {
	if int(m) < other {
		return -1
	} else if int(m) > other {
		return 1
	}
	return 0
}

func main() {
	// Switch on interface method call result
	var c Comparer = MyInt(5)
	
	switch c.Compare(5) {
	case -1:
		panic("should not be -1")
	case 0:
		// expected
	case 1:
		panic("should not be 1")
	default:
		panic("unexpected default 1")
	}
	
	switch c.Compare(3) {
	case -1:
		panic("should not be -1")
	case 0:
		panic("should not be 0")
	case 1:
		// expected
	default:
		panic("unexpected default 2")
	}
	
	switch c.Compare(10) {
	case -1:
		// expected
	case 0:
		panic("switch 3: should not be 0")
	case 1:
		panic("switch 3: should not be 1")
	default:
		panic("switch 3: unexpected default 3")
	}
	
	// Switch on type assertion result
	var a any = 42
	switch a.(int) {
	case 41:
		panic("switch 4: wrong case 41")
	case 42:
		// expected
	case 43:
		panic("wrong case 43")
	}
	
	// Switch on interface value directly
	var b any = "hello"
	switch b {
	case "world":
		panic("wrong case world")
	case "hello":
		// expected
	default:
		panic("unexpected default in string switch")
	}
	
	// Switch with init statement and interface
	switch v := c.Compare(7); v {
	case -1:
		// expected
	case 0, 1:
		panic("wrong case")
	}
	
	// Tagless switch with interface conditions
	switch {
	case c.Compare(100) == -1:
		// expected
	case c.Compare(1) == 1:
		panic("wrong condition")
	default:
		panic("unexpected default 5")
	}
	
	// Switch on nil interface
	var nilIface Comparer
	switch nilIface {
	case nil:
		// expected
	default:
		panic("nil interface should match nil case 6")
	}
	
	// Switch with multiple interface method calls
	c2 := MyInt(10)
	switch {
	case c.Compare(5) == 0 && c2.Compare(10) == 0:
		// expected
	default:
		panic("compound condition failed 7")
	}
	
	println("PASSED")
}

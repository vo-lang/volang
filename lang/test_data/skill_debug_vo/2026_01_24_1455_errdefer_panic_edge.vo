package main

import "errors"

// Test 1: panic inside errdefer - should this propagate?
// In Go, panic in defer propagates. errdefer should behave similarly.
var panicInErrdeferCalled = false

func panicInErrdefer() (result int, err error) {
	result = 0
	
	defer func() {
		if r := recover(); r != nil {
			result = 999
			panicInErrdeferCalled = true
		}
	}()
	
	errdefer func() {
		result = 100
		panic("errdefer panic")
	}()
	
	fail errors.New("trigger errdefer")
}

func testPanicInErrdefer() {
	r, err := panicInErrdefer()
	println("result:", r, "err:", err, "panicCalled:", panicInErrdeferCalled)
	// The errdefer runs (sets result to 100), then panics
	// The outer defer catches the panic (sets result to 999)
	assert(panicInErrdeferCalled, "panic should have been caught")
	assert(r == 999, "recover should have set result to 999")
}

// Test 2: fail should NOT be caught by recover
// fail is a normal return, not a panic
func failNotRecoverable() (result int, err error) {
	result = 0
	
	defer func() {
		if r := recover(); r != nil {
			result = 999  // This should NOT happen
		}
	}()
	
	result = 42
	fail errors.New("this is fail not panic")
}

func testFailNotRecoverable() {
	r, err := failNotRecoverable()
	println("result:", r, "err:", err)
	assert(err != nil, "should have error")
	assert(r == 42, "fail is not recoverable, result should be 42")
}

// Test 3: nested errdefer - errdefer calls function that has errdefer
func innerWithErrdefer() (int, error) {
	errdefer func() {
		println("inner errdefer ran")
	}()
	fail errors.New("inner fail")
}

func outerWithNestedErrdefer() (result int, err error) {
	result = 0
	
	errdefer func() {
		result += 1000
		println("outer errdefer ran")
	}()
	
	// Call inner function that has its own errdefer
	v, err := innerWithErrdefer()
	if err != nil {
		result = v + 100
		return result, err  // return with error triggers outer errdefer
	}
	
	return v, nil
}

func testNestedErrdefer() {
	r, err := outerWithNestedErrdefer()
	println("result:", r, "err:", err)
	assert(err != nil, "should have error")
	// inner errdefer runs, returns (0, error)
	// outer: result = 0 + 100 = 100, then outer errdefer adds 1000
	assert(r == 1100, "expected 1100")
}

// Test 4: errdefer with multiple named returns and partial modification
func errdeferPartialModify() (a int, b int, c int, err error) {
	a, b, c = 1, 2, 3
	
	errdefer func() {
		// Only modify 'b'
		b = 200
	}()
	
	a = 10
	fail errors.New("partial modify")
}

func testErrdeferPartialModify() {
	a, b, c, err := errdeferPartialModify()
	println("a:", a, "b:", b, "c:", c, "err:", err)
	assert(err != nil, "should have error")
	assert(a == 10, "a should be 10")
	assert(b == 200, "b should be 200 (modified by errdefer)")
	assert(c == 3, "c should be 3")
}

// Test 5: errdefer registered in loop
func errdeferInLoop() (result int, err error) {
	result = 0
	
	for i := 0; i < 3; i++ {
		errdefer func() {
			result += 1
		}()
	}
	
	fail errors.New("after loop")
}

func testErrdeferInLoop() {
	r, err := errdeferInLoop()
	println("result:", r, "err:", err)
	assert(err != nil, "should have error")
	// 3 errdefers registered, each adds 1
	assert(r == 3, "expected 3 errdefers to run")
}

// Test 6: errdefer with closure capturing loop variable
func errdeferCaptureLooVar() (result int, err error) {
	result = 0
	
	for i := 0; i < 3; i++ {
		j := i  // capture by copy
		errdefer func() {
			result += j
		}()
	}
	
	fail errors.New("after loop")
}

func testErrdeferCaptureLoopVar() {
	r, err := errdeferCaptureLooVar()
	println("result:", r, "err:", err)
	assert(err != nil, "should have error")
	// errdefers run in LIFO order: j=2, j=1, j=0
	// result = 0 + 2 + 1 + 0 = 3
	assert(r == 3, "expected sum of 0+1+2 = 3")
}

// Test 7: errdefer and defer interleaved, error return
func errdeferDeferInterleaved() (result int, err error) {
	result = 0
	
	defer func() {
		result += 1  // always runs
	}()
	
	errdefer func() {
		result += 10  // only on error
	}()
	
	defer func() {
		result += 100  // always runs
	}()
	
	errdefer func() {
		result += 1000  // only on error
	}()
	
	fail errors.New("test")
}

func testErrdeferDeferInterleaved() {
	r, err := errdeferDeferInterleaved()
	println("result:", r, "err:", err)
	assert(err != nil, "should have error")
	// LIFO order: errdefer(+1000), defer(+100), errdefer(+10), defer(+1)
	// All should run because we're returning with error
	assert(r == 1111, "expected 1111")
}

// Test 8: errdefer and defer interleaved, success return
func errdeferDeferInterleavedSuccess() (result int, err error) {
	result = 0
	
	defer func() {
		result += 1  // always runs
	}()
	
	errdefer func() {
		result += 10  // only on error - should NOT run
	}()
	
	defer func() {
		result += 100  // always runs
	}()
	
	errdefer func() {
		result += 1000  // only on error - should NOT run
	}()
	
	return 0, nil
}

func testErrdeferDeferInterleavedSuccess() {
	r, err := errdeferDeferInterleavedSuccess()
	println("result:", r, "err:", err)
	assert(err == nil, "should succeed")
	// Only regular defers run: defer(+100), defer(+1)
	assert(r == 101, "expected 101")
}

func main() {
	testPanicInErrdefer()
	println("Test 1: PASSED - panic in errdefer")
	
	testFailNotRecoverable()
	println("Test 2: PASSED - fail not recoverable")
	
	testNestedErrdefer()
	println("Test 3: PASSED - nested errdefer")
	
	testErrdeferPartialModify()
	println("Test 4: PASSED - errdefer partial modify")
	
	testErrdeferInLoop()
	println("Test 5: PASSED - errdefer in loop")
	
	testErrdeferCaptureLoopVar()
	println("Test 6: PASSED - errdefer capture loop var")
	
	testErrdeferDeferInterleaved()
	println("Test 7: PASSED - errdefer defer interleaved error")
	
	testErrdeferDeferInterleavedSuccess()
	println("Test 8: PASSED - errdefer defer interleaved success")
	
	println("ALL PASSED")
}

package main

// Test for-range with closures edge cases

// Test 1: For-range capture by copy in slice
func testForRangeCaptureSlice() {
	var funcs []func() int
	nums := []int{1, 2, 3}
	
	for _, n := range nums {
		n := n  // capture by copy
		funcs = append(funcs, func() int {
			return n
		})
	}
	
	sum := 0
	for _, f := range funcs {
		sum += f()
	}
	println("sum:", sum)
	assert(sum == 6, "capture by copy: 1+2+3=6")
}

// Test 2: For-range capture index
func testForRangeCaptureIndex() {
	var funcs []func() int
	nums := []int{10, 20, 30}
	
	for i := range nums {
		i := i  // capture by copy
		funcs = append(funcs, func() int {
			return i
		})
	}
	
	sum := 0
	for _, f := range funcs {
		sum += f()
	}
	println("sum:", sum)
	assert(sum == 3, "capture index: 0+1+2=3")
}

// Test 3: For-range over map with closure
func testForRangeMapClosure() {
	m := map[string]int{"a": 1, "b": 2, "c": 3}
	var funcs []func() int
	
	for _, v := range m {
		v := v
		funcs = append(funcs, func() int {
			return v
		})
	}
	
	sum := 0
	for _, f := range funcs {
		sum += f()
	}
	println("sum:", sum)
	assert(sum == 6, "map closure: 1+2+3=6")
}

// Test 4: For-range nested with closure
func testForRangeNestedClosure() {
	var funcs []func() int
	
	for i := 0; i < 2; i++ {
		for j := 0; j < 2; j++ {
			i, j := i, j
			funcs = append(funcs, func() int {
				return i*10 + j
			})
		}
	}
	
	results := make([]int, 0)
	for _, f := range funcs {
		results = append(results, f())
	}
	println("results:", results[0], results[1], results[2], results[3])
	// Expected: 0, 1, 10, 11
	assert(results[0] == 0, "nested 0")
	assert(results[1] == 1, "nested 1")
	assert(results[2] == 10, "nested 10")
	assert(results[3] == 11, "nested 11")
}

// Test 5: For-range with break and closure
func testForRangeBreakClosure() {
	var f func() int
	
	for i := 0; i < 10; i++ {
		i := i
		f = func() int {
			return i
		}
		if i == 3 {
			break
		}
	}
	
	result := f()
	println("result:", result)
	assert(result == 3, "break at 3")
}

// Test 6: For-range with continue and closure
func testForRangeContinueClosure() {
	var funcs []func() int
	
	for i := 0; i < 5; i++ {
		if i%2 == 0 {
			continue
		}
		i := i
		funcs = append(funcs, func() int {
			return i
		})
	}
	
	sum := 0
	for _, f := range funcs {
		sum += f()
	}
	println("sum:", sum)
	// Only odd: 1 + 3 = 4
	assert(sum == 4, "continue odd sum")
}

// Test 7: For-range with defer in loop body
func testForRangeDeferInLoop() (result int) {
	result = 0
	
	for i := 0; i < 3; i++ {
		i := i
		defer func() {
			result += i
		}()
	}
	
	return result
}

func testForRangeDefer() {
	r := testForRangeDeferInLoop()
	println("result:", r)
	// Defers run in LIFO: 2+1+0 = 3
	assert(r == 3, "defer in loop: 0+1+2=3")
}

// Test 8: For-range string with closure
func testForRangeStringClosure() {
	var funcs []func() rune
	s := "abc"
	
	for _, r := range s {
		r := r
		funcs = append(funcs, func() rune {
			return r
		})
	}
	
	result := ""
	for _, f := range funcs {
		result += string(f())
	}
	println("result:", result)
	assert(result == "abc", "string closure")
}

// Test 9: For-range with closure modifying outer variable
func testForRangeModifyOuter() {
	counter := 0
	var funcs []func()
	
	for i := 0; i < 3; i++ {
		funcs = append(funcs, func() {
			counter++
		})
	}
	
	for _, f := range funcs {
		f()
	}
	
	println("counter:", counter)
	assert(counter == 3, "modify outer")
}

// Test 10: For-range with immediate closure call
func testForRangeImmediateClosure() {
	sum := 0
	
	for i := 0; i < 3; i++ {
		sum += func(x int) int {
			return x * 2
		}(i)
	}
	
	println("sum:", sum)
	// 0*2 + 1*2 + 2*2 = 0 + 2 + 4 = 6
	assert(sum == 6, "immediate closure")
}

// Test 11: For-range array with closure
func testForRangeArrayClosure() {
	arr := [3]int{100, 200, 300}
	var funcs []func() int
	
	for _, v := range arr {
		v := v
		funcs = append(funcs, func() int {
			return v
		})
	}
	
	sum := 0
	for _, f := range funcs {
		sum += f()
	}
	println("sum:", sum)
	assert(sum == 600, "array closure")
}

// Test 12: For-range with closure returning closure
func testForRangeClosureReturningClosure() {
	var makers []func() func() int
	
	for i := 0; i < 3; i++ {
		i := i
		makers = append(makers, func() func() int {
			return func() int {
				return i * 10
			}
		})
	}
	
	sum := 0
	for _, maker := range makers {
		f := maker()
		sum += f()
	}
	println("sum:", sum)
	// 0*10 + 1*10 + 2*10 = 30
	assert(sum == 30, "closure returning closure")
}

func main() {
	testForRangeCaptureSlice()
	println("Test 1: PASSED - capture slice")
	
	testForRangeCaptureIndex()
	println("Test 2: PASSED - capture index")
	
	testForRangeMapClosure()
	println("Test 3: PASSED - map closure")
	
	testForRangeNestedClosure()
	println("Test 4: PASSED - nested closure")
	
	testForRangeBreakClosure()
	println("Test 5: PASSED - break closure")
	
	testForRangeContinueClosure()
	println("Test 6: PASSED - continue closure")
	
	testForRangeDefer()
	println("Test 7: PASSED - defer in loop")
	
	testForRangeStringClosure()
	println("Test 8: PASSED - string closure")
	
	testForRangeModifyOuter()
	println("Test 9: PASSED - modify outer")
	
	testForRangeImmediateClosure()
	println("Test 10: PASSED - immediate closure")
	
	testForRangeArrayClosure()
	println("Test 11: PASSED - array closure")
	
	testForRangeClosureReturningClosure()
	println("Test 12: PASSED - closure returning closure")
	
	println("ALL PASSED")
}

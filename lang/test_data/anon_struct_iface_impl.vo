// Test: Anonymous struct types implementing interfaces
// Tests that anonymous struct literals can be used with interfaces
package main


import "fmt"
type Stringer interface {
    String() string
}

type Adder interface {
    Add(x int) int
}

type StringAdder interface {
    Stringer
    Adder
}

// Named type for comparison
type Counter struct {
    value int
    name  string
}

func (c Counter) String() string {
    return c.name
}

func (c Counter) Add(x int) int {
    return c.value + x
}

// Test 1: Named struct implements interface
func testNamedStruct() {
    c := Counter{value: 10, name: "counter"}
    var s Stringer = c
    assert(s.String() == "counter", "named struct String() should work")
    
    var a Adder = c
    assert(a.Add(5) == 15, "named struct Add() should work")
}

// Test 2: Anonymous struct stored in any and type asserted
func testAnonStructInAny() {
    // Anonymous struct literal
    anon := struct {
        x int
        y int
    }{x: 10, y: 20}
    
    var a any = anon
    
    // Type assertion back to same anonymous type
    v, ok := a.(struct{ x int; y int })
    assert(ok, "type assertion should succeed")
    assert(v.x == 10 && v.y == 20, "values should match")
}

// Test 3: Anonymous struct in slice
func testAnonStructSlice() {
    points := []struct{ x, y int }{
        {1, 2},
        {3, 4},
        {5, 6},
    }
    
    assert(len(points) == 3, "should have 3 points")
    assert(points[0].x == 1 && points[0].y == 2, "first point correct")
    assert(points[2].x == 5 && points[2].y == 6, "third point correct")
}

// Test 4: Anonymous struct as map value
func testAnonStructMapValue() {
    m := map[string]struct{ count int; name string }{
        "a": {count: 1, name: "first"},
        "b": {count: 2, name: "second"},
    }
    
    assert(m["a"].count == 1, "a.count should be 1")
    assert(m["b"].name == "second", "b.name should be second")
}

// Test 5: Nested anonymous structs
func testNestedAnonStruct() {
    data := struct {
        meta struct {
            version int
            name    string
        }
        value int
    }{
        meta: struct {
            version int
            name    string
        }{version: 1, name: "test"},
        value: 42,
    }
    
    assert(data.meta.version == 1, "nested version should be 1")
    assert(data.meta.name == "test", "nested name should be test")
    assert(data.value == 42, "value should be 42")
}

// Test 6: Empty anonymous struct
func testEmptyAnonStruct() {
    empty := struct{}{}
    var a any = empty
    
    _, ok := a.(struct{})
    assert(ok, "empty struct type assertion should work")
}

// Test 7: Anonymous struct comparison
func testAnonStructCompare() {
    s1 := struct{ x, y int }{1, 2}
    s2 := struct{ x, y int }{1, 2}
    s3 := struct{ x, y int }{1, 3}
    
    assert(s1 == s2, "identical structs should be equal")
    assert(s1 != s3, "different structs should not be equal")
}

// Test 8: Function returning anonymous struct
func returnAnonStruct() struct{ a, b int } {
    return struct{ a, b int }{10, 20}
}

func testFuncReturnAnonStruct() {
    result := returnAnonStruct()
    assert(result.a == 10, "a should be 10")
    assert(result.b == 20, "b should be 20")
}

// Test 9: Anonymous struct as function parameter
func takeAnonStruct(s struct{ x int }) int {
    return s.x * 2
}

func testFuncParamAnonStruct() {
    result := takeAnonStruct(struct{ x int }{x: 21})
    assert(result == 42, "should return 42")
}

func main() int {
    fmt.Println("Test 1: Named struct implements interface")
    testNamedStruct()
    fmt.Println("PASSED")
    
    fmt.Println("Test 2: Anonymous struct in any")
    testAnonStructInAny()
    fmt.Println("PASSED")
    
    fmt.Println("Test 3: Anonymous struct slice")
    testAnonStructSlice()
    fmt.Println("PASSED")
    
    fmt.Println("Test 4: Anonymous struct map value")
    testAnonStructMapValue()
    fmt.Println("PASSED")
    
    fmt.Println("Test 5: Nested anonymous structs")
    testNestedAnonStruct()
    fmt.Println("PASSED")
    
    fmt.Println("Test 6: Empty anonymous struct")
    testEmptyAnonStruct()
    fmt.Println("PASSED")
    
    fmt.Println("Test 7: Anonymous struct comparison")
    testAnonStructCompare()
    fmt.Println("PASSED")
    
    fmt.Println("Test 8: Function returning anonymous struct")
    testFuncReturnAnonStruct()
    fmt.Println("PASSED")
    
    fmt.Println("Test 9: Anonymous struct as function parameter")
    testFuncParamAnonStruct()
    fmt.Println("PASSED")
    
    fmt.Println("anon_struct_iface_impl: ALL PASSED")
    return 0
}

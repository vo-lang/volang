package main


import "fmt"
// Comprehensive test for pointer semantics in GoX

// ============================================
// Part 1: Basic Pointer Types and Operations
// ============================================

type Point struct {
    x int
    y int
}

func main() {
    testBasicPointer()
    testPointerFieldAccess()
    testPointerMethods()
    testValueReceiverOnPointer()
    testNestedStructPointer()
    
    fmt.Println("pointer_comprehensive: ALL PASSED")
}

// Test 1: Basic pointer creation and dereferencing
func testBasicPointer() {
    // Create pointer to struct literal
    p := &Point{10, 20}
    
    // Verify field access through pointer (auto-deref)
    assert(p.x == 10, "testBasicPointer: p.x should be 10")
    assert(p.y == 20, "testBasicPointer: p.y should be 20")
    
    // Modify through pointer
    p.x = 100
    p.y = 200
    assert(p.x == 100, "testBasicPointer: after modify p.x should be 100")
    assert(p.y == 200, "testBasicPointer: after modify p.y should be 200")
}

// Test 2: Pointer field access with named type
func testPointerFieldAccess() {
    pt := Point{1, 2}
    ptr := &pt
    
    // Access field through pointer
    assert(ptr.x == 1, "testPointerFieldAccess: ptr.x should be 1")
    assert(ptr.y == 2, "testPointerFieldAccess: ptr.y should be 2")
    
    // Modify original through pointer
    ptr.x = 10
    assert(pt.x == 10, "testPointerFieldAccess: pt.x should be 10 after ptr.x = 10")
}

// ============================================
// Part 2: Pointer Receiver Methods
// ============================================

// Pointer receiver - can modify the struct
func (p *Point) Move(dx, dy int) {
    p.x = p.x + dx
    p.y = p.y + dy
}

// Pointer receiver - can modify the struct
func (p *Point) Scale(factor int) {
    p.x = p.x * factor
    p.y = p.y * factor
}

// Value receiver - returns value, doesn't modify
func (p Point) Sum() int {
    return p.x + p.y
}

// Value receiver - returns new Point
func (p Point) Add(other Point) Point {
    return Point{p.x + other.x, p.y + other.y}
}

// Test 3: Pointer receiver methods
func testPointerMethods() {
    p := &Point{10, 20}
    
    // Call pointer receiver method
    p.Move(5, 10)
    assert(p.x == 15, "testPointerMethods: after Move p.x should be 15")
    assert(p.y == 30, "testPointerMethods: after Move p.y should be 30")
    
    // Call another pointer receiver method
    p.Scale(2)
    assert(p.x == 30, "testPointerMethods: after Scale p.x should be 30")
    assert(p.y == 60, "testPointerMethods: after Scale p.y should be 60")
}

// Test 4: Value receiver methods on pointer
func testValueReceiverOnPointer() {
    p := &Point{10, 20}
    
    // Call value receiver method on pointer (auto-deref)
    sum := p.Sum()
    assert(sum == 30, "testValueReceiverOnPointer: sum should be 30")
    
    // Value receiver doesn't modify original
    other := Point{5, 5}
    result := p.Add(other)
    assert(result.x == 15, "testValueReceiverOnPointer: result.x should be 15")
    assert(result.y == 25, "testValueReceiverOnPointer: result.y should be 25")
    
    // Original unchanged
    assert(p.x == 10, "testValueReceiverOnPointer: p.x should still be 10")
}

// ============================================
// Part 3: Nested Struct with Pointers
// ============================================

type Rectangle struct {
    topLeft     Point
    bottomRight Point
}

func testNestedStructPointer() {
    rect := &Rectangle{
        topLeft:     Point{0, 0},
        bottomRight: Point{100, 100},
    }
    
    // Access nested struct fields through pointer
    assert(rect.topLeft.x == 0, "testNestedStructPointer: topLeft.x should be 0")
    assert(rect.bottomRight.x == 100, "testNestedStructPointer: bottomRight.x should be 100")
    
    // Modify nested struct through pointer
    rect.topLeft.x = 10
    rect.topLeft.y = 10
    assert(rect.topLeft.x == 10, "testNestedStructPointer: after modify topLeft.x should be 10")
}

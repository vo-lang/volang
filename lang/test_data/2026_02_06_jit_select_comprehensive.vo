// Test: Comprehensive JIT Select support
// This tests all select opcodes (SelectBegin, SelectSend, SelectRecv, SelectExec) in JIT mode
package main

import "fmt"

// =============================================================================
// Test 1: Basic select with default (non-blocking)
// =============================================================================

func testSelectDefault() {
	ch := make(chan int, 1)
	
	// Empty channel with default
	result := -1
	select {
	case v := <-ch:
		result = v
	default:
		result = 0
	}
	assert(result == 0, "empty channel should hit default")
	
	// Ready channel - should not hit default
	ch <- 42
	select {
	case v := <-ch:
		result = v
	default:
		result = 0
	}
	assert(result == 42, "ready channel should receive value")
}

// =============================================================================
// Test 2: Select send cases
// =============================================================================

func testSelectSend() {
	ch := make(chan int, 2)
	
	// Send to buffered channel
	sent := false
	select {
	case ch <- 100:
		sent = true
	default:
		sent = false
	}
	assert(sent, "should send to buffered channel")
	
	// Send second value
	select {
	case ch <- 200:
		sent = true
	default:
		sent = false
	}
	assert(sent, "should send second value")
	
	// Buffer full - should hit default
	select {
	case ch <- 300:
		sent = true
	default:
		sent = false
	}
	assert(!sent, "full buffer should hit default")
	
	// Verify values
	v1 := <-ch
	v2 := <-ch
	assert(v1 == 100, "first value should be 100")
	assert(v2 == 200, "second value should be 200")
}

// =============================================================================
// Test 3: Select recv with ok flag
// =============================================================================

func testSelectRecvOk() {
	ch := make(chan int, 1)
	
	// Receive from open channel
	ch <- 42
	var v int
	var ok bool
	select {
	case v, ok = <-ch:
	default:
		panic("should receive")
	}
	assert(v == 42, "value should be 42")
	assert(ok, "ok should be true for open channel")
	
	// Receive from closed channel
	close(ch)
	select {
	case v, ok = <-ch:
	default:
		panic("should receive from closed")
	}
	assert(v == 0, "value should be zero for closed channel")
	assert(!ok, "ok should be false for closed channel")
}

// =============================================================================
// Test 4: Multiple ready cases (randomness test)
// =============================================================================

func testSelectMultiReady() {
	ch1 := make(chan int, 1)
	ch2 := make(chan int, 1)
	
	ch1 <- 1
	ch2 <- 2
	
	count1 := 0
	count2 := 0
	
	// Run multiple times to verify both cases can be selected
	for i := 0; i < 100; i++ {
		// Refill channels
		if len(ch1) == 0 {
			ch1 <- 1
		}
		if len(ch2) == 0 {
			ch2 <- 2
		}
		
		select {
		case <-ch1:
			count1++
		case <-ch2:
			count2++
		}
	}
	
	// Both should be selected at least once (probabilistic but highly likely)
	assert(count1 > 0, "ch1 should be selected at least once")
	assert(count2 > 0, "ch2 should be selected at least once")
	assert(count1+count2 == 100, "total should be 100")
}

// =============================================================================
// Test 5: Select with struct values (multi-slot)
// =============================================================================

type Point struct {
	X, Y int
}

func testSelectStructValue() {
	ch := make(chan Point, 1)
	
	// Send struct
	select {
	case ch <- Point{10, 20}:
	default:
		panic("should send")
	}
	
	// Receive struct
	var p Point
	select {
	case p = <-ch:
	default:
		panic("should receive")
	}
	assert(p.X == 10, "X should be 10")
	assert(p.Y == 20, "Y should be 20")
}

// =============================================================================
// Test 6: Select in loop
// =============================================================================

func testSelectInLoop() {
	ch := make(chan int, 10)
	
	// Fill channel
	for i := 0; i < 10; i++ {
		ch <- i
	}
	
	// Drain with select
	sum := 0
	for i := 0; i < 10; i++ {
		select {
		case v := <-ch:
			sum += v
		default:
			panic("should receive")
		}
	}
	assert(sum == 45, "sum should be 45 (0+1+...+9)")
}

// =============================================================================
// Test 7: Nested select
// =============================================================================

func testNestedSelect() {
	ch1 := make(chan int, 1)
	ch2 := make(chan int, 1)
	
	ch1 <- 1
	
	result := 0
	select {
	case v := <-ch1:
		// Nested select
		ch2 <- v * 10
		select {
		case v2 := <-ch2:
			result = v2
		default:
			panic("inner select should receive")
		}
	default:
		panic("outer select should receive")
	}
	assert(result == 10, "result should be 10")
}

// =============================================================================
// Test 8: Select with nil channel (should skip)
// =============================================================================

func testSelectNilChannel() {
	var nilCh chan int
	ch := make(chan int, 1)
	ch <- 42
	
	result := 0
	select {
	case v := <-nilCh:
		result = v  // nil channel is never ready
	case v := <-ch:
		result = v
	}
	assert(result == 42, "should receive from non-nil channel")
}

// =============================================================================
// Test 9: Select send on closed channel (should panic)
// =============================================================================

func testSelectSendClosed() {
	ch := make(chan int, 1)
	close(ch)
	
	defer func() {
		r := recover()
		assert(r != nil, "should panic on send to closed channel")
	}()
	
	select {
	case ch <- 1:
		panic("should not reach here")
	default:
		panic("should not hit default - send to closed panics first")
	}
}

// =============================================================================
// Test 10: Select with function calls in case expressions
// =============================================================================

var callCount int

func getChan() chan int {
	callCount++
	ch := make(chan int, 1)
	ch <- callCount
	return ch
}

func testSelectEvalOrder() {
	callCount = 0
	
	result := 0
	select {
	case v := <-getChan():
		result = v
	default:
		panic("should receive")
	}
	assert(callCount == 1, "getChan should be called once")
	assert(result == 1, "result should be 1")
}

// =============================================================================
// Test 11: Select with large struct (many slots)
// =============================================================================

type LargeStruct struct {
	A, B, C, D, E, F, G, H int
}

func testSelectLargeStruct() {
	ch := make(chan LargeStruct, 1)
	
	sent := LargeStruct{1, 2, 3, 4, 5, 6, 7, 8}
	select {
	case ch <- sent:
	default:
		panic("should send")
	}
	
	var recv LargeStruct
	select {
	case recv = <-ch:
	default:
		panic("should receive")
	}
	
	assert(recv.A == 1 && recv.B == 2 && recv.C == 3 && recv.D == 4, "first half")
	assert(recv.E == 5 && recv.F == 6 && recv.G == 7 && recv.H == 8, "second half")
}

// =============================================================================
// Test 12: Select with mixed send/recv cases
// =============================================================================

func testSelectMixed() {
	ch1 := make(chan int, 1)
	ch2 := make(chan int, 1)
	
	ch1 <- 10  // ch1 ready for recv
	// ch2 ready for send (empty buffer)
	
	recvCount := 0
	sendCount := 0
	
	for i := 0; i < 50; i++ {
		if len(ch1) == 0 && recvCount > 0 {
			ch1 <- 10
		}
		if len(ch2) > 0 {
			<-ch2
		}
		
		select {
		case v := <-ch1:
			assert(v == 10, "recv value")
			recvCount++
		case ch2 <- 20:
			sendCount++
		}
	}
	
	assert(recvCount > 0, "should recv some")
	assert(sendCount > 0, "should send some")
}

// =============================================================================
// Main
// =============================================================================

func main() {
	testSelectDefault()
	fmt.Println("✓ testSelectDefault")
	
	testSelectSend()
	fmt.Println("✓ testSelectSend")
	
	testSelectRecvOk()
	fmt.Println("✓ testSelectRecvOk")
	
	testSelectMultiReady()
	fmt.Println("✓ testSelectMultiReady")
	
	testSelectStructValue()
	fmt.Println("✓ testSelectStructValue")
	
	testSelectInLoop()
	fmt.Println("✓ testSelectInLoop")
	
	testNestedSelect()
	fmt.Println("✓ testNestedSelect")
	
	testSelectNilChannel()
	fmt.Println("✓ testSelectNilChannel")
	
	testSelectSendClosed()
	fmt.Println("✓ testSelectSendClosed")
	
	testSelectEvalOrder()
	fmt.Println("✓ testSelectEvalOrder")
	
	testSelectLargeStruct()
	fmt.Println("✓ testSelectLargeStruct")
	
	testSelectMixed()
	fmt.Println("✓ testSelectMixed")
	
	fmt.Println("\nAll JIT select tests passed!")
}

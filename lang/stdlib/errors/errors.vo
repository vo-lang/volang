package errors

// Error is the canonical structured error implementation.
type Error struct {
    code  int
    msg   string
    cause error
    data  any
}

func (e *Error) Error() string {
    return e.msg
}

func (e *Error) Code() int {
    return e.code
}

func (e *Error) Unwrap() error {
    return e.cause
}

func (e *Error) Data() any {
    return e.data
}

// New returns a new error with default code CodeUnknown.
func New(msg string) error {
    return &Error{code: CodeUnknown, msg: msg}
}

// NewCode returns a new error with the given code.
func NewCode(code int, msg string) error {
    return &Error{code: code, msg: msg}
}

// Wrap returns a new error that wraps cause, inheriting its code.
func Wrap(cause error, msg string) error {
    return &Error{code: cause.Code(), msg: msg, cause: cause}
}

// WrapCode returns a new error with a cause and the given code.
func WrapCode(cause error, code int, msg string) error {
    return &Error{code: code, msg: msg, cause: cause}
}

// WithData returns a new error that wraps cause and attaches data.
func WithData(cause error, data any) error {
    return &Error{code: cause.Code(), msg: cause.Error(), cause: cause, data: data}
}

// Is reports whether any error in err's unwrap chain matches target by code.
func Is(err error, target error) bool {
    if target == nil {
        return err == nil
    }
    targetCode := target.Code()
    for err != nil {
        if err.Code() == targetCode {
            return true
        }
        err = err.Unwrap()
    }
    return false
}

// IsCode checks whether any error in the unwrap chain matches code.
func IsCode(err error, code int) bool {
    for err != nil {
        if err.Code() == code {
            return true
        }
        err = err.Unwrap()
    }
    return false
}

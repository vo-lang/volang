package errors

// Error is the standard error implementation.
type Error struct {
    msg   string
    cause error
}

func (e *Error) Error() string {
    if e.cause == nil {
        return e.msg
    }
    return e.msg + ": " + e.cause.Error()
}

func (e *Error) Unwrap() error {
    return e.cause
}

// New returns a new error with the given message.
func New(msg string) error {
    return &Error{msg: msg}
}

// Wrap returns a new error that wraps cause with a message.
// Returns nil if cause is nil.
func Wrap(cause error, msg string) error {
    if cause == nil {
        return nil
    }
    return &Error{msg: msg, cause: cause}
}

// Unwrap returns the result of calling the Unwrap method on err,
// if err's type contains an Unwrap method returning error.
// Otherwise, Unwrap returns nil.
func Unwrap(err error) error {
    if err == nil {
        return nil
    }
    // Try calling Unwrap method via dynamic access
    if result, e := err~>Unwrap(); e == nil {
        if unwrapped, ok := result.(error); ok {
            return unwrapped
        }
    }
    return nil
}

// Join returns an error that wraps the given errors.
// Any nil error values are discarded. Join returns nil if every value in errs is nil.
// The error formats each wrapped error's message on a separate line.
func Join(errs ...error) error {
    var nonNil []error
    for _, e := range errs {
        if e != nil {
            nonNil = append(nonNil, e)
        }
    }
    if len(nonNil) == 0 {
        return nil
    }
    return &joinError{errs: nonNil}
}

type joinError struct {
    errs []error
}

func (e *joinError) Error() string {
    msg := ""
    for i, err := range e.errs {
        if i > 0 {
            msg += "\n"
        }
        msg += err.Error()
    }
    return msg
}

func (e *joinError) Unwrap() []error {
    return e.errs
}

// As finds the first error in err's chain that matches target and if one is found,
// sets target to that error value and returns true. Target must be a non-nil pointer.
// Since Vo lacks generics, target is passed as any and the match relies on a custom
// As(any) bool method on the error, or direct type equality check.
func As(err error, target any) bool {
    for err != nil {
        // Try calling custom As method via dynamic access
        if result, e := err~>As(target); e == nil {
            if ok, valid := result.(bool); valid && ok {
                return true
            }
        }
        err = Unwrap(err)
    }
    return false
}

// Is reports whether any error in err's unwrap chain matches target.
// If err implements Is(error) bool, that method is called.
func Is(err error, target error) bool {
    if target == nil {
        return err == nil
    }
    for err != nil {
        if err == target {
            return true
        }
        // Try calling custom Is method via dynamic access
        if result, e := err~>Is(target); e == nil {
            if ok, valid := result.(bool); valid && ok {
                return true
            }
        }
        err = Unwrap(err)
    }
    return false
}

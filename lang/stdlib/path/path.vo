package path

import (
	"errors"
	"strings"
)

// ErrBadPattern is returned when a glob pattern is malformed.
var ErrBadPattern = errors.New("syntax error in pattern")

// Clean returns the shortest path name equivalent to path
// by purely lexical processing with forward slash separators.
func Clean(path string) string {
	if path == "" {
		return "."
	}
	rooted := path[0] == '/'
	parts := strings.Split(path, "/")
	var out []string
	for _, p := range parts {
		switch p {
		case "", ".":
			// skip
		case "..":
			if len(out) > 0 {
				out = out[:len(out)-1]
			} else if !rooted {
				out = append(out, "..")
			}
		default:
			out = append(out, p)
		}
	}
	result := strings.Join(out, "/")
	if rooted {
		result = "/" + result
	}
	if result == "" {
		return "."
	}
	return result
}

// Base returns the last element of path.
// Trailing slashes are removed before extracting the last element.
// If the path is empty, Base returns ".".
// If the path consists entirely of slashes, Base returns "/".
func Base(path string) string {
	if path == "" {
		return "."
	}
	path = strings.TrimRight(path, "/")
	if path == "" {
		return "/"
	}
	i := strings.LastIndex(path, "/")
	if i >= 0 {
		path = path[i+1:]
	}
	return path
}

// Dir returns all but the last element of path.
// The returned path never ends in a slash unless it is the root "/".
func Dir(path string) string {
	dir, _ := Split(path)
	return Clean(dir)
}

// Ext returns the file name extension used by path.
// The extension is the suffix beginning at the final dot in the last element
// of path; it is empty if there is no dot.
func Ext(path string) string {
	base := Base(path)
	i := strings.LastIndex(base, ".")
	if i < 0 {
		return ""
	}
	return base[i:]
}

// IsAbs reports whether the path is absolute.
func IsAbs(path string) bool {
	return strings.HasPrefix(path, "/")
}

// Join joins any number of path elements into a single path,
// separating them with slashes. Empty elements are ignored.
// The result is Cleaned.
func Join(elem ...string) string {
	var parts []string
	for _, e := range elem {
		if e != "" {
			parts = append(parts, e)
		}
	}
	if len(parts) == 0 {
		return ""
	}
	return Clean(strings.Join(parts, "/"))
}

// Split splits path immediately following the final slash,
// separating it into a directory and file name component.
// If there is no slash in path, Split returns an empty dir and file set to path.
// The returned values have the property that path = dir + file.
func Split(path string) (dir, file string) {
	i := strings.LastIndex(path, "/")
	return path[:i+1], path[i+1:]
}

// Match reports whether name matches the shell pattern.
// The pattern syntax is the same as filepath.Match.
func Match(pattern, name string) (matched bool, err error) {
	for len(pattern) > 0 {
		var chunk string
		var star bool
		star, chunk, pattern = scanChunk(pattern)
		if star && chunk == "" {
			return !strings.Contains(name, "/"), nil
		}
		t, ok, err2 := matchChunk(chunk, name)
		if err2 != nil {
			return false, err2
		}
		if ok {
			if len(pattern) == 0 && len(t) > 0 {
				return false, nil
			}
			name = t
		} else if star {
			for i := 0; i < len(name) && name[i] != '/'; i++ {
				t, ok, err2 = matchChunk(chunk, name[i+1:])
				if err2 != nil {
					return false, err2
				}
				if ok {
					name = t
					break
				}
			}
		} else {
			return false, nil
		}
	}
	return len(name) == 0, nil
}

func scanChunk(pattern string) (star bool, chunk, rest string) {
	for len(pattern) > 0 && pattern[0] == '*' {
		pattern = pattern[1:]
		star = true
	}
	var i int
	inrange := false
	for i = 0; i < len(pattern); i++ {
		switch pattern[i] {
		case '\\':
			if i+1 < len(pattern) {
				i++
			}
		case '[':
			inrange = true
		case ']':
			inrange = false
		case '*':
			if !inrange {
				return star, pattern[:i], pattern[i:]
			}
		}
	}
	return star, pattern, ""
}

func matchChunk(chunk, s string) (rest string, ok bool, err error) {
	for len(chunk) > 0 {
		if len(s) == 0 {
			return "", false, nil
		}
		switch chunk[0] {
		case '[':
			r := rune(s[0])
			s = s[1:]
			chunk = chunk[1:]
			notNegated := true
			if len(chunk) > 0 && chunk[0] == '^' {
				notNegated = false
				chunk = chunk[1:]
			}
			matched := false
			for len(chunk) > 0 && chunk[0] != ']' {
				lo := rune(chunk[0])
				chunk = chunk[1:]
				if len(chunk) > 0 && chunk[0] == '-' && len(chunk) > 1 && chunk[1] != ']' {
					hi := rune(chunk[1])
					chunk = chunk[2:]
					if lo <= r && r <= hi {
						matched = true
					}
				} else {
					if lo == r {
						matched = true
					}
				}
			}
			if len(chunk) > 0 && chunk[0] == ']' {
				chunk = chunk[1:]
			}
			if matched == notNegated {
				return "", false, nil
			}
		case '?':
			if s[0] == '/' {
				return "", false, nil
			}
			s = s[1:]
			chunk = chunk[1:]
		case '\\':
			chunk = chunk[1:]
			if len(chunk) == 0 {
				return "", false, ErrBadPattern
			}
			if chunk[0] != s[0] {
				return "", false, nil
			}
			s = s[1:]
			chunk = chunk[1:]
		default:
			if chunk[0] != s[0] {
				return "", false, nil
			}
			s = s[1:]
			chunk = chunk[1:]
		}
	}
	return s, true, nil
}

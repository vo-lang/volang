package bytes

import (
    "errors"
    "io"
    "unicode/utf8"
)

// Extern functions (implemented in Rust)
func Index(s, sep []byte) int
func LastIndex(s, sep []byte) int
func Count(s, sep []byte) int
func ToLower(s []byte) []byte
func ToUpper(s []byte) []byte
func Replace(s, old, new []byte, n int) []byte

// Split splits s into all subslices separated by sep.
func Split(s, sep []byte) [][]byte {
    return splitGeneric(s, sep, 0, -1)
}

// SplitN splits s into at most n subslices separated by sep.
func SplitN(s, sep []byte, n int) [][]byte {
    return splitGeneric(s, sep, 0, n)
}

// SplitAfter splits s after each instance of sep.
func SplitAfter(s, sep []byte) [][]byte {
    return splitGeneric(s, sep, len(sep), -1)
}

// SplitAfterN splits s after each instance of sep, at most n times.
func SplitAfterN(s, sep []byte, n int) [][]byte {
    return splitGeneric(s, sep, len(sep), n)
}

// Fields splits s around each instance of one or more consecutive white space characters.
func Fields(s []byte) [][]byte {
    var result [][]byte
    start := -1
    for i := 0; i < len(s); i++ {
        isWS := s[i] == ' ' || s[i] == '\t' || s[i] == '\n' || s[i] == '\r' || s[i] == '\v' || s[i] == '\f'
        if isWS {
            if start >= 0 {
                result = append(result, s[start:i])
                start = -1
            }
        } else {
            if start < 0 {
                start = i
            }
        }
    }
    if start >= 0 {
        result = append(result, s[start:])
    }
    return result
}

// Internal helper for split functions
func splitGeneric(s, sep []byte, sepSave, n int) [][]byte {
    if n == 0 {
        return nil
    }
    if len(sep) == 0 {
        // Split at each byte
        if n < 0 || n > len(s) {
            n = len(s)
        }
        result := make([][]byte, n)
        for i := 0; i < n; i++ {
            result[i] = s[i : i+1]
        }
        return result
    }
    
    var result [][]byte
    i := 0
    for {
        if n > 0 && len(result) >= n-1 {
            break
        }
        idx := Index(s[i:], sep)
        if idx < 0 {
            break
        }
        result = append(result, s[i:i+idx+sepSave])
        i += idx + len(sep)
    }
    result = append(result, s[i:])
    return result
}

// Vo-implemented functions

// Equal reports whether a and b are the same length and contain the same bytes.
func Equal(a, b []byte) bool {
    if len(a) != len(b) {
        return false
    }
    for i := 0; i < len(a); i++ {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}

// Compare returns an integer comparing two byte slices lexicographically.
func Compare(a, b []byte) int {
    minLen := len(a)
    if len(b) < minLen {
        minLen = len(b)
    }
    for i := 0; i < minLen; i++ {
        if a[i] < b[i] {
            return -1
        }
        if a[i] > b[i] {
            return 1
        }
    }
    if len(a) < len(b) {
        return -1
    }
    if len(a) > len(b) {
        return 1
    }
    return 0
}

// HasPrefix tests whether the byte slice s begins with prefix.
func HasPrefix(s, prefix []byte) bool {
    return len(s) >= len(prefix) && Equal(s[:len(prefix)], prefix)
}

// HasSuffix tests whether the byte slice s ends with suffix.
func HasSuffix(s, suffix []byte) bool {
    return len(s) >= len(suffix) && Equal(s[len(s)-len(suffix):], suffix)
}

// Contains reports whether subslice is within s.
func Contains(s, subslice []byte) bool {
    return Index(s, subslice) >= 0
}

// ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.
func ContainsAny(b []byte, chars string) bool {
    return IndexAny(b, chars) >= 0
}

// ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.
func ContainsRune(b []byte, r rune) bool {
    return IndexRune(b, r) >= 0
}

// Clone returns a copy of b.
func Clone(b []byte) []byte {
    if b == nil {
        return nil
    }
    c := make([]byte, len(b))
    copy(c, b)
    return c
}

// Repeat returns a new byte slice consisting of count copies of b.
func Repeat(b []byte, count int) []byte {
    if count <= 0 || len(b) == 0 {
        return []byte{}
    }
    n := len(b) * count
    result := make([]byte, n)
    bp := copy(result, b)
    for bp < n {
        copy(result[bp:], result[:bp])
        bp *= 2
    }
    return result
}

// IndexByte returns the index of the first instance of c in b, or -1 if c is not present.
func IndexByte(b []byte, c byte) int {
    for i := 0; i < len(b); i++ {
        if b[i] == c {
            return i
        }
    }
    return -1
}

// LastIndexByte returns the index of the last instance of c in b, or -1 if c is not present.
func LastIndexByte(b []byte, c byte) int {
    for i := len(b) - 1; i >= 0; i-- {
        if b[i] == c {
            return i
        }
    }
    return -1
}

// IndexRune interprets b as a sequence of UTF-8-encoded code points and returns
// the byte index of the first occurrence in b of the given rune.
func IndexRune(b []byte, r rune) int {
    i := 0
    for i < len(b) {
        c, size := utf8.DecodeRune(b[i:])
        if c == r {
            return i
        }
        i += size
    }
    return -1
}

// IndexAny interprets b as a sequence of UTF-8-encoded Unicode code points.
// It returns the byte index of the first occurrence in b of any of the Unicode
// code points in chars. It returns -1 if chars is empty or if there is no code
// point in common.
func IndexAny(b []byte, chars string) int {
    if len(chars) == 0 {
        return -1
    }
    i := 0
    for i < len(b) {
        c, size := utf8.DecodeRune(b[i:])
        if indexRuneInString(chars, c) >= 0 {
            return i
        }
        i += size
    }
    return -1
}

// LastIndexAny interprets b as a sequence of UTF-8-encoded Unicode code points.
// It returns the byte index of the last occurrence in b of any of the Unicode
// code points in chars. It returns -1 if chars is empty or if there is no code
// point in common.
func LastIndexAny(b []byte, chars string) int {
    if len(chars) == 0 {
        return -1
    }
    lastIdx := -1
    i := 0
    for i < len(b) {
        c, size := utf8.DecodeRune(b[i:])
        if indexRuneInString(chars, c) >= 0 {
            lastIdx = i
        }
        i += size
    }
    return lastIdx
}

// TrimSpace returns a subslice of b by slicing off all leading and trailing white space.
func TrimSpace(b []byte) []byte {
    start := 0
    for start < len(b) && isSpace(b[start]) {
        start++
    }
    end := len(b)
    for end > start && isSpace(b[end-1]) {
        end--
    }
    return b[start:end]
}

// Trim returns a subslice of b by slicing off all leading and trailing
// UTF-8-encoded code points contained in cutset.
func Trim(b []byte, cutset string) []byte {
    return TrimRight(TrimLeft(b, cutset), cutset)
}

// TrimLeft returns a subslice of b by slicing off all leading
// UTF-8-encoded code points contained in cutset.
func TrimLeft(b []byte, cutset string) []byte {
    if len(b) == 0 || len(cutset) == 0 {
        return b
    }
    i := 0
    for i < len(b) {
        c, size := utf8.DecodeRune(b[i:])
        if indexRuneInString(cutset, c) < 0 {
            break
        }
        i += size
    }
    return b[i:]
}

// TrimRight returns a subslice of b by slicing off all trailing
// UTF-8-encoded code points contained in cutset.
func TrimRight(b []byte, cutset string) []byte {
    if len(b) == 0 || len(cutset) == 0 {
        return b
    }
    end := len(b)
    for end > 0 {
        r, size := utf8.DecodeLastRune(b[:end])
        if indexRuneInString(cutset, r) < 0 {
            break
        }
        end -= size
    }
    return b[:end]
}

// TrimPrefix returns b without the provided leading prefix byte slice.
func TrimPrefix(b, prefix []byte) []byte {
    if HasPrefix(b, prefix) {
        return b[len(prefix):]
    }
    return b
}

// TrimSuffix returns b without the provided trailing suffix byte slice.
func TrimSuffix(b, suffix []byte) []byte {
    if HasSuffix(b, suffix) {
        return b[:len(b)-len(suffix)]
    }
    return b
}

// ReplaceAll returns a copy of b with all occurrences of old replaced by new.
func ReplaceAll(b, old, new []byte) []byte {
    return Replace(b, old, new, -1)
}

// Join concatenates the elements of s to create a new byte slice.
func Join(s [][]byte, sep []byte) []byte {
    if len(s) == 0 {
        return []byte{}
    }
    if len(s) == 1 {
        return Clone(s[0])
    }
    n := len(sep) * (len(s) - 1)
    for i := 0; i < len(s); i++ {
        n += len(s[i])
    }
    b := make([]byte, n)
    bp := copy(b, s[0])
    for i := 1; i < len(s); i++ {
        bp += copy(b[bp:], sep)
        bp += copy(b[bp:], s[i])
    }
    return b
}

// Cut slices b around the first instance of sep, returning the slices before and after sep.
func Cut(b, sep []byte) (before, after []byte, found bool) {
    if i := Index(b, sep); i >= 0 {
        return b[:i], b[i+len(sep):], true
    }
    return b, nil, false
}

// CutPrefix returns b without the provided leading prefix byte slice and reports whether it found the prefix.
func CutPrefix(b, prefix []byte) (after []byte, found bool) {
    if !HasPrefix(b, prefix) {
        return b, false
    }
    return b[len(prefix):], true
}

// CutSuffix returns b without the provided ending suffix byte slice and reports whether it found the suffix.
func CutSuffix(b, suffix []byte) (before []byte, found bool) {
    if !HasSuffix(b, suffix) {
        return b, false
    }
    return b[:len(b)-len(suffix)], true
}

// Internal helper: check if byte is ASCII whitespace
func isSpace(c byte) bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\v' || c == '\f'
}

// Internal helper: find rune in string
func indexRuneInString(s string, r rune) int {
    i := 0
    for _, c := range s {
        if c == r {
            return i
        }
        i += utf8.RuneLen(c)
    }
    return -1
}

// ==================== Buffer ====================

// ErrUnreadByte is returned by UnreadByte when the previous operation was not a read.
var ErrUnreadByte = errors.NewCode(errors.CodeBytesUnreadByte, "bytes.Buffer: UnreadByte: previous operation was not a successful read")

// ErrUnreadRune is returned by UnreadRune when the previous operation was not ReadRune.
var ErrUnreadRune = errors.NewCode(errors.CodeBytesUnreadRune, "bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune")

// ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.
var ErrTooLarge = errors.NewCode(errors.CodeBytesTooLarge, "bytes.Buffer: too large")

// smallBufferSize is an initial allocation minimal capacity.
const smallBufferSize = 64

// Buffer is a variable-sized buffer of bytes with Read and Write methods.
// The zero value for Buffer is an empty buffer ready to use.
type Buffer struct {
    buf      []byte // contents are the bytes buf[off : len(buf)]
    off      int    // read at &buf[off], write at &buf[len(buf)]
    lastRead int // last read operation, so that Unread* can work correctly
}

// The readOp constants describe the last action performed on the buffer,
// so that UnreadRune and UnreadByte can check for invalid usage.
const (
    opRead      = -1 // Any other read operation
    opInvalid   = 0  // Non-read operation
    opReadRune1 = 1  // Read rune of size 1
    opReadRune2 = 2  // Read rune of size 2
    opReadRune3 = 3  // Read rune of size 3
    opReadRune4 = 4  // Read rune of size 4
)

// NewBuffer creates and initializes a new Buffer using buf as its initial contents.
// The new Buffer takes ownership of buf, and the caller should not use buf after this call.
// NewBuffer is intended to prepare a Buffer to read existing data.
// It can also be used to set the initial size of the internal buffer for writing.
// To do that, buf should have the desired capacity but a length of zero.
func NewBuffer(buf []byte) *Buffer {
    return &Buffer{buf: buf}
}

// NewBufferString creates and initializes a new Buffer using string s as its initial contents.
// It is intended to prepare a buffer to read an existing string.
func NewBufferString(s string) *Buffer {
    return &Buffer{buf: []byte(s)}
}

// Bytes returns a slice of length b.Len() holding the unread portion of the buffer.
// The slice is valid for use only until the next buffer modification
// (that is, only until the next call to a method like Read, Write, Reset, or Truncate).
func (b *Buffer) Bytes() []byte {
    return b.buf[b.off:]
}

// AvailableBuffer returns an empty buffer with b.Available() capacity.
// This buffer is intended to be appended to and passed to an immediately succeeding Write call.
func (b *Buffer) AvailableBuffer() []byte {
    return b.buf[len(b.buf):]
}

// String returns the contents of the unread portion of the buffer as a string.
func (b *Buffer) String() string {
    return string(b.buf[b.off:])
}

// Len returns the number of bytes of the unread portion of the buffer;
// b.Len() == len(b.Bytes()).
func (b *Buffer) Len() int {
    return len(b.buf) - b.off
}

// Cap returns the capacity of the buffer's underlying byte slice,
// that is, the total space allocated for the buffer's data.
func (b *Buffer) Cap() int {
    return cap(b.buf)
}

// Available returns how many bytes are unused in the buffer.
func (b *Buffer) Available() int {
    return cap(b.buf) - len(b.buf)
}

// Truncate discards all but the first n unread bytes from the buffer
// but continues to use the same allocated storage.
// It panics if n is negative or greater than the length of the buffer.
func (b *Buffer) Truncate(n int) {
    if n == 0 {
        b.Reset()
        return
    }
    b.lastRead = opInvalid
    if n < 0 || n > b.Len() {
        panic("bytes.Buffer: truncation out of range")
    }
    b.buf = b.buf[:b.off+n]
}

// Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes.
// Reset is the same as Truncate(0).
func (b *Buffer) Reset() {
    b.buf = b.buf[:0]
    b.off = 0
    b.lastRead = opInvalid
}

// tryGrowByReslice is an inlineable version of grow for the fast-case where the
// internal buffer only needs to be resliced.
// It returns the index where bytes should be written and whether it succeeded.
func (b *Buffer) tryGrowByReslice(n int) (int, bool) {
    if l := len(b.buf); n <= cap(b.buf)-l {
        b.buf = b.buf[:l+n]
        return l, true
    }
    return 0, false
}

// grow grows the buffer to guarantee space for n more bytes.
// It returns the index where bytes should be written.
func (b *Buffer) grow(n int) int {
    m := b.Len()
    // If buffer is empty, reset to recover space.
    if m == 0 && b.off != 0 {
        b.Reset()
    }
    // Try to grow by means of a reslice.
    if i, ok := b.tryGrowByReslice(n); ok {
        return i
    }
    if b.buf == nil {
        b.buf = make([]byte, n)
        return 0
    }
    c := cap(b.buf)
    if n <= c/2-m {
        // We can slide down instead of allocating a new slice.
        copy(b.buf, b.buf[b.off:])
    } else if c > maxInt-c-n {
        panic("bytes.Buffer: too large")
    } else {
        // Allocate a new buffer.
        buf := make([]byte, 2*c+n)
        copy(buf, b.buf[b.off:])
        b.buf = buf
    }
    // Restore b.off and len(b.buf).
    b.off = 0
    b.buf = b.buf[:m+n]
    return m
}

// Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes.
// After Grow(n), at least n bytes can be written to the buffer without another allocation.
// If n is negative, Grow will panic.
func (b *Buffer) Grow(n int) {
    if n < 0 {
        panic("bytes.Buffer.Grow: negative count")
    }
    m := b.grow(n)
    b.buf = b.buf[:m]
}

// Write appends the contents of p to the buffer, growing the buffer as needed.
// The return value n is the length of p; err is always nil.
func (b *Buffer) Write(p []byte) (int, error) {
    b.lastRead = opInvalid
    m, ok := b.tryGrowByReslice(len(p))
    if !ok {
        m = b.grow(len(p))
    }
    return copy(b.buf[m:], p), nil
}

// WriteString appends the contents of s to the buffer, growing the buffer as needed.
// The return value n is the length of s; err is always nil.
func (b *Buffer) WriteString(s string) (int, error) {
    b.lastRead = opInvalid
    m, ok := b.tryGrowByReslice(len(s))
    if !ok {
        m = b.grow(len(s))
    }
    return copy(b.buf[m:], []byte(s)), nil
}

// WriteByte appends the byte c to the buffer, growing the buffer as needed.
// The returned error is always nil, but is included to match bufio.Writer's WriteByte.
func (b *Buffer) WriteByte(c byte) error {
    b.lastRead = opInvalid
    m, ok := b.tryGrowByReslice(1)
    if !ok {
        m = b.grow(1)
    }
    b.buf[m] = c
    return nil
}

// WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer,
// returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune.
func (b *Buffer) WriteRune(r rune) (int, error) {
    // Compare as uint32 to correctly handle negative runes.
    if uint32(r) < utf8.RuneSelf {
        b.WriteByte(byte(r))
        return 1, nil
    }
    b.lastRead = opInvalid
    m, ok := b.tryGrowByReslice(utf8.UTFMax)
    if !ok {
        m = b.grow(utf8.UTFMax)
    }
    b.buf = b.buf[:m]
    b.buf = utf8.AppendRune(b.buf, r)
    return len(b.buf) - m, nil
}

// maxInt is the maximum value for an int.
const maxInt = int(^uint(0) >> 1)

// Read reads the next len(p) bytes from the buffer or until the buffer is drained.
// The return value n is the number of bytes read.
// If the buffer has no data to return, err is ErrEOF (otherwise it is nil).
func (b *Buffer) Read(p []byte) (int, error) {
    b.lastRead = opInvalid
    if b.empty() {
        // Buffer is empty, reset to recover space.
        b.Reset()
        if len(p) == 0 {
            return 0, nil
        }
        return 0, io.EOF
    }
    n := copy(p, b.buf[b.off:])
    b.off += n
    if n > 0 {
        b.lastRead = opRead
    }
    return n, nil
}

// Next returns a slice containing the next n bytes from the buffer,
// advancing the buffer as if the bytes had been returned by Read.
// If there are fewer than n bytes in the buffer, Next returns the entire buffer.
// The slice is only valid until the next call to a read or write method.
func (b *Buffer) Next(n int) []byte {
    b.lastRead = opInvalid
    m := b.Len()
    if n > m {
        n = m
    }
    data := b.buf[b.off : b.off+n]
    b.off += n
    if n > 0 {
        b.lastRead = opRead
    }
    return data
}

// ReadByte reads and returns the next byte from the buffer.
// If no byte is available, it returns error ErrEOF.
func (b *Buffer) ReadByte() (byte, error) {
    if b.empty() {
        // Buffer is empty, reset to recover space.
        b.Reset()
        return 0, io.EOF
    }
    c := b.buf[b.off]
    b.off++
    b.lastRead = opRead
    return c, nil
}

// ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer.
// If no bytes are available, the error returned is ErrEOF.
// If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.
func (b *Buffer) ReadRune() (rune, int, error) {
    if b.empty() {
        // Buffer is empty, reset to recover space.
        b.Reset()
        return 0, 0, io.EOF
    }
    c := b.buf[b.off]
    if c < utf8.RuneSelf {
        b.off++
        b.lastRead = opReadRune1
        return rune(c), 1, nil
    }
    r, n := utf8.DecodeRune(b.buf[b.off:])
    b.off += n
    b.lastRead = n
    return r, n, nil
}

// UnreadRune unreads the last rune returned by ReadRune.
// If the most recent read or write operation on the buffer was not a successful ReadRune,
// UnreadRune returns an error.
func (b *Buffer) UnreadRune() error {
    if b.lastRead <= opInvalid {
        return ErrUnreadRune
    }
    if b.off >= int(b.lastRead) {
        b.off -= int(b.lastRead)
    }
    b.lastRead = opInvalid
    return nil
}

// UnreadByte unreads the last byte returned by the most recent successful read operation
// that read at least one byte. If a write has happened since the last read,
// if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.
func (b *Buffer) UnreadByte() error {
    if b.lastRead == opInvalid {
        return ErrUnreadByte
    }
    b.lastRead = opInvalid
    if b.off > 0 {
        b.off--
    }
    return nil
}

// ReadBytes reads until the first occurrence of delim in the input,
// returning a slice containing the data up to and including the delimiter.
// If ReadBytes encounters an error before finding a delimiter,
// it returns the data read before the error and the error itself (often ErrEOF).
// ReadBytes returns err != nil if and only if the returned data does not end in delim.
func (b *Buffer) ReadBytes(delim byte) ([]byte, error) {
    slice, err := b.readSlice(delim)
    // return a copy of slice. The buffer's backing array may be overwritten by later calls.
    line := Clone(slice)
    return line, err
}

// readSlice is like ReadBytes but returns a reference to internal buffer data.
func (b *Buffer) readSlice(delim byte) ([]byte, error) {
    i := IndexByte(b.buf[b.off:], delim)
    end := b.off + i + 1
    if i < 0 {
        end = len(b.buf)
    }
    line := b.buf[b.off:end]
    b.off = end
    b.lastRead = opRead
    if i < 0 {
        return line, io.EOF
    }
    return line, nil
}

// ReadString reads until the first occurrence of delim in the input,
// returning a string containing the data up to and including the delimiter.
// If ReadString encounters an error before finding a delimiter,
// it returns the data read before the error and the error itself (often ErrEOF).
// ReadString returns err != nil if and only if the returned data does not end in delim.
func (b *Buffer) ReadString(delim byte) (string, error) {
    slice, err := b.readSlice(delim)
    return string(slice), err
}

// empty reports whether the unread portion of the buffer is empty.
func (b *Buffer) empty() bool {
    return len(b.buf) <= b.off
}


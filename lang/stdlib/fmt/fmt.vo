package fmt

import (
	"errors"
	"io"
)

// Stringer is implemented by any value that has a String method, which defines
// the "native" format for that value.
type Stringer interface {
	String() string
}

// GoStringer is implemented by any value that has a GoString method, which
// defines the Go syntax for that value.
type GoStringer interface {
	GoString() string
}

// State represents the printer state passed to custom formatters.
// It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier.
type State interface {
	Write(b []byte) (n int, err error)
	Width() (wid int, ok bool)
	Precision() (prec int, ok bool)
	Flag(c int) bool
}

// Formatter is implemented by values with a custom formatter.
type Formatter interface {
	Format(f State, verb rune)
}

// Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver.
type Scanner interface {
	Scan(state ScanState, verb rune) error
}

// ScanState represents the scanner state passed to custom scanners.
type ScanState interface {
	ReadRune() (r rune, size int, err error)
	UnreadRune() error
	SkipSpace()
	Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
	Width() (wid int, ok bool)
}

// Native functions (implemented in Rust)
func nativeWrite(s string)
func nativeSprint(a []interface{}) string
func nativeSprintln(a []interface{}) string
func nativeSprintf(format string, a []interface{}) string
func nativeSscan(str string) []any
func nativeSscanf(str string, format string) ([]any, error)
func nativeReadLine() (string, error)

// Print formats using the default formats and writes to standard output.
// Returns the number of bytes written.
func Print(a ...interface{}) int {
	s := nativeSprint(a)
	nativeWrite(s)
	return len(s)
}

// Println formats using the default formats and writes to standard output.
// A newline is appended. Returns the number of bytes written.
func Println(a ...interface{}) int {
	s := nativeSprintln(a)
	nativeWrite(s)
	return len(s)
}

// Printf formats according to a format specifier and writes to standard output.
// Returns the number of bytes written.
func Printf(format string, a ...interface{}) int {
	s := nativeSprintf(format, a)
	nativeWrite(s)
	return len(s)
}

// Sprint formats using the default formats and returns the resulting string.
func Sprint(a ...interface{}) string {
	return nativeSprint(a)
}

// Sprintln formats using the default formats and returns the resulting string.
// A newline is appended.
func Sprintln(a ...interface{}) string {
	return nativeSprintln(a)
}

// Sprintf formats according to a format specifier and returns the resulting string.
func Sprintf(format string, a ...interface{}) string {
	return nativeSprintf(format, a)
}

// Fprint formats using the default formats and writes to w.
// Returns the number of bytes written and any write error.
func Fprint(w io.Writer, a ...interface{}) (int, error) {
	s := nativeSprint(a)
	return io.WriteString(w, s)
}

// Fprintln formats using the default formats, appends a newline, and writes to w.
// Returns the number of bytes written and any write error.
func Fprintln(w io.Writer, a ...interface{}) (int, error) {
	s := nativeSprintln(a)
	return io.WriteString(w, s)
}

// Fprintf formats according to a format specifier and writes to w.
// Returns the number of bytes written and any write error.
func Fprintf(w io.Writer, format string, a ...interface{}) (int, error) {
	s := nativeSprintf(format, a)
	return io.WriteString(w, s)
}

// Errorf formats according to a format specifier and returns the string as an error.
func Errorf(format string, a ...interface{}) error {
	return errors.New(nativeSprintf(format, a))
}

// ==================== Scan Family ====================
//
// Vo adaptation: Go's Scan functions take pointer args (&x) to write into.
// Since Vo has no pointer-to-primitive types, scan functions return []any
// with typed values: %d→int, %f→float64, %s→string, %t→bool, %c→int(rune).

// Sscan splits str by whitespace and returns tokens as string values in []any.
func Sscan(str string) []any {
	return nativeSscan(str)
}

// Sscanln splits the first line of str by whitespace and returns tokens as string values.
func Sscanln(str string) []any {
	idx := -1
	for i := 0; i < len(str); i++ {
		if str[i] == '\n' {
			idx = i
			break
		}
	}
	if idx >= 0 {
		str = str[:idx]
	}
	return nativeSscan(str)
}

// Sscanf scans str according to the format string, returning typed values as []any.
// Format verbs: %d→int, %f→float64, %s→string, %t→bool, %c→int(rune),
// %x→int(hex), %o→int(octal), %b→int(binary), %v→string.
func Sscanf(str string, format string) ([]any, error) {
	return nativeSscanf(str, format)
}

// Fscan reads space-separated tokens from r and returns them as string values.
func Fscan(r io.Reader) ([]any, error) {
	buf := make([]byte, 4096)
	n, err := r.Read(buf)
	if n == 0 && err != nil {
		return nil, err
	}
	return nativeSscan(string(buf[:n])), nil
}

// Fscanf reads from r and scans according to format, returning typed values.
func Fscanf(r io.Reader, format string) ([]any, error) {
	buf := make([]byte, 4096)
	n, err := r.Read(buf)
	if n == 0 && err != nil {
		return nil, err
	}
	return nativeSscanf(string(buf[:n]), format)
}

// Fscanln reads from r until newline and returns space-separated tokens.
func Fscanln(r io.Reader) ([]any, error) {
	buf := make([]byte, 4096)
	n, err := r.Read(buf)
	if n == 0 && err != nil {
		return nil, err
	}
	return Sscanln(string(buf[:n])), nil
}

// Scan reads space-separated tokens from standard input.
func Scan() ([]any, error) {
	line, err := nativeReadLine()
	if err != nil {
		return nil, err
	}
	return nativeSscan(line), nil
}

// Scanf reads from standard input according to the format string.
func Scanf(format string) ([]any, error) {
	line, err := nativeReadLine()
	if err != nil {
		return nil, err
	}
	return nativeSscanf(line, format)
}

// Scanln reads space-separated tokens from standard input until newline.
func Scanln() ([]any, error) {
	line, err := nativeReadLine()
	if err != nil {
		return nil, err
	}
	return Sscanln(line), nil
}

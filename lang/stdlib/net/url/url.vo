package url

import (
	"errors"
	"strconv"
	"strings"
)

// URL represents a parsed URL.
type URL struct {
	Scheme   string
	User     *Userinfo
	Host     string // host or host:port
	Path     string // path (decoded)
	RawPath  string // encoded path hint (empty means use Path)
	RawQuery string // encoded query values, without '?'
	Fragment string // fragment for references, without '#'
}

// Userinfo is an immutable encapsulation of username and password details.
type Userinfo struct {
	username    string
	password    string
	passwordSet bool
}

// User returns a Userinfo containing the provided username.
func User(username string) *Userinfo {
	return &Userinfo{username: username}
}

// UserPassword returns a Userinfo containing the provided username and password.
func UserPassword(username, password string) *Userinfo {
	return &Userinfo{username: username, password: password, passwordSet: true}
}

// Username returns the username.
func (u *Userinfo) Username() string {
	if u == nil {
		return ""
	}
	return u.username
}

// Password returns the password and whether it is set.
func (u *Userinfo) Password() (string, bool) {
	if u == nil {
		return "", false
	}
	return u.password, u.passwordSet
}

// String returns the encoded userinfo in the standard form of "username[:password]".
func (u *Userinfo) String() string {
	if u == nil {
		return ""
	}
	s := escape(u.username, encodeUserPassword)
	if u.passwordSet {
		s += ":" + escape(u.password, encodeUserPassword)
	}
	return s
}

// Hostname returns u.Host, stripping any valid port number if present.
func (u *URL) Hostname() string {
	host, _ := splitHostPort(u.Host)
	return host
}

// Port returns the port part of u.Host, without the leading colon.
func (u *URL) Port() string {
	_, p := splitHostPort(u.Host)
	return p
}

// splitHostPort splits host and port. If there's no port, the second return is empty.
func splitHostPort(hostPort string) (string, string) {
	if hostPort == "" {
		return "", ""
	}
	// IPv6 literal: [host]:port
	if hostPort[0] == '[' {
		i := strings.Index(hostPort, "]")
		if i < 0 {
			return hostPort, ""
		}
		if i+1 < len(hostPort) && hostPort[i+1] == ':' {
			return hostPort[:i+1], hostPort[i+2:]
		}
		return hostPort[:i+1], ""
	}
	// No colon = no port
	colon := strings.LastIndex(hostPort, ":")
	if colon < 0 {
		return hostPort, ""
	}
	return hostPort[:colon], hostPort[colon+1:]
}

// RequestURI returns the encoded path?query or opaque?query string that
// would be used in an HTTP request for the URL.
func (u *URL) RequestURI() string {
	result := u.EscapedPath()
	if result == "" {
		result = "/"
	}
	if u.RawQuery != "" {
		result += "?" + u.RawQuery
	}
	return result
}

// EscapedPath returns the escaped form of u.Path.
func (u *URL) EscapedPath() string {
	if u.RawPath != "" {
		return u.RawPath
	}
	return escape(u.Path, encodePath)
}

// String reassembles the URL into a valid URL string.
func (u *URL) String() string {
	var buf []byte

	if u.Scheme != "" {
		buf = append(buf, u.Scheme...)
		buf = append(buf, ':')
	}
	if u.Scheme != "" || u.Host != "" || u.User != nil {
		if u.Host != "" || u.Path != "" || u.User != nil {
			buf = append(buf, '/', '/')
		}
		if u.User != nil {
			buf = append(buf, u.User.String()...)
			buf = append(buf, '@')
		}
		if u.Host != "" {
			buf = append(buf, escape(u.Host, encodeHost)...)
		}
	}
	path := u.EscapedPath()
	if path != "" && len(path) > 0 && path[0] != '/' && u.Host != "" {
		buf = append(buf, '/')
	}
	buf = append(buf, path...)

	if u.RawQuery != "" {
		buf = append(buf, '?')
		buf = append(buf, u.RawQuery...)
	}
	if u.Fragment != "" {
		buf = append(buf, '#')
		buf = append(buf, escape(u.Fragment, encodeFragment)...)
	}
	return string(buf)
}

// Parse parses a raw url into a URL structure.
func Parse(rawURL string) (*URL, error) {
	// Cut off #fragment
	u, frag, _ := cut(rawURL, "#")
	url, err := parse(u, false)
	if err != nil {
		return nil, err
	}
	if frag == "" {
		return url, nil
	}
	f, e := unescape(frag, encodeFragment)
	if e != nil {
		return nil, e
	}
	url.Fragment = f
	return url, nil
}

// parse parses a URL from a string.
func parse(rawURL string, viaRequest bool) (*URL, error) {
	if rawURL == "" && viaRequest {
		return nil, errors.New("empty url")
	}

	url := &URL{}
	rest := rawURL

	if rest == "*" {
		url.Path = "*"
		return url, nil
	}

	// Extract scheme
	if i := strings.Index(rest, "://"); i >= 0 {
		url.Scheme = strings.ToLower(rest[:i])
		rest = rest[i+3:]
	} else if i := strings.Index(rest, ":"); i >= 0 && !strings.Contains(rest[:i], "/") {
		// Could be a scheme without //
		url.Scheme = strings.ToLower(rest[:i])
		rest = rest[i+1:]
		// If it starts with //, strip those
		if strings.HasPrefix(rest, "//") {
			rest = rest[2:]
		} else {
			// opaque URI (e.g. mailto:user@host)
			url.Path = rest
			return url, nil
		}
	}

	if url.Scheme != "" || (!viaRequest && !strings.HasPrefix(rawURL, "///")) {
		if strings.HasPrefix(rest, "//") {
			rest = rest[2:]
		}
	}

	// If we have a scheme, the next part is authority (user@host:port)
	if url.Scheme != "" || strings.Contains(rawURL, "://") {
		var authority string
		authority, rest = splitOnSlash(rest)

		// Parse userinfo@host
		if at := strings.LastIndex(authority, "@"); at >= 0 {
			userinfo := authority[:at]
			authority = authority[at+1:]
			if ci := strings.Index(userinfo, ":"); ci >= 0 {
				un, e1 := unescape(userinfo[:ci], encodeUserPassword)
				if e1 != nil {
					return nil, e1
				}
				pw, e2 := unescape(userinfo[ci+1:], encodeUserPassword)
				if e2 != nil {
					return nil, e2
				}
				url.User = UserPassword(un, pw)
			} else {
				un, e := unescape(userinfo, encodeUserPassword)
				if e != nil {
					return nil, e
				}
				url.User = User(un)
			}
		}
		url.Host = authority
	}

	// Split path and query
	if qi := strings.Index(rest, "?"); qi >= 0 {
		url.RawQuery = rest[qi+1:]
		rest = rest[:qi]
	}

	// Decode path
	p, err := unescape(rest, encodePath)
	if err != nil {
		return nil, err
	}
	url.Path = p
	if rest != p {
		url.RawPath = rest
	}

	return url, nil
}

// splitOnSlash splits s into before first '/' and from '/' onward.
func splitOnSlash(s string) (string, string) {
	i := strings.Index(s, "/")
	if i < 0 {
		return s, ""
	}
	return s[:i], s[i:]
}

// cut is like strings.Cut.
func cut(s, sep string) (string, string, bool) {
	i := strings.Index(s, sep)
	if i < 0 {
		return s, "", false
	}
	return s[:i], s[i+len(sep):], true
}

// ResolveReference resolves a URI reference to an absolute URI from
// an absolute base URI u.
func (u *URL) ResolveReference(ref *URL) *URL {
	url := &URL{}
	if ref.Scheme != "" {
		url.Scheme = ref.Scheme
		url.User = ref.User
		url.Host = ref.Host
		url.Path = resolvePath(ref.Path, "")
		url.RawPath = ref.RawPath
		url.RawQuery = ref.RawQuery
	} else {
		if ref.Host != "" || ref.User != nil {
			url.User = ref.User
			url.Host = ref.Host
			url.Path = resolvePath(ref.Path, "")
			url.RawPath = ref.RawPath
			url.RawQuery = ref.RawQuery
		} else {
			if ref.Path == "" {
				url.Path = u.Path
				url.RawPath = u.RawPath
				if ref.RawQuery != "" {
					url.RawQuery = ref.RawQuery
				} else {
					url.RawQuery = u.RawQuery
				}
			} else {
				if len(ref.Path) > 0 && ref.Path[0] == '/' {
					url.Path = resolvePath(ref.Path, "")
				} else {
					url.Path = resolvePath(ref.Path, u.Path)
				}
				url.RawPath = ref.RawPath
				url.RawQuery = ref.RawQuery
			}
			url.Host = u.Host
			url.User = u.User
		}
		url.Scheme = u.Scheme
	}
	url.Fragment = ref.Fragment
	return url
}

// resolvePath applies special path segments. If base is non-empty and ref
// is relative, it uses the base directory.
func resolvePath(ref, base string) string {
	var full string
	if base == "" {
		full = ref
	} else {
		i := strings.LastIndex(base, "/")
		full = base[:i+1] + ref
	}
	if full == "" {
		return ""
	}
	// Clean .. and . segments
	return cleanPath(full)
}

// cleanPath resolves . and .. in a path.
func cleanPath(p string) string {
	if p == "" {
		return ""
	}
	isAbs := p[0] == '/'
	parts := strings.Split(p, "/")
	var out []string
	for _, part := range parts {
		if part == "." || part == "" {
			continue
		} else if part == ".." {
			if len(out) > 0 {
				out = out[:len(out)-1]
			}
		} else {
			out = append(out, part)
		}
	}
	result := strings.Join(out, "/")
	if isAbs {
		result = "/" + result
	}
	// Preserve trailing slash if original had one
	if len(p) > 0 && p[len(p)-1] == '/' && !strings.HasSuffix(result, "/") {
		result += "/"
	}
	return result
}

// ============================================
// Query (Values)
// ============================================

// Values maps a string key to a list of values.
type Values map[string][]string

// Get gets the first value associated with the given key.
func (v Values) Get(key string) string {
	vs, ok := v[key]
	if !ok || len(vs) == 0 {
		return ""
	}
	return vs[0]
}

// Set sets the key to value. It replaces any existing values.
func (v Values) Set(key, value string) {
	v[key] = []string{value}
}

// Add adds the value to key. It appends to any existing values.
func (v Values) Add(key, value string) {
	v[key] = append(v[key], value)
}

// Del deletes the values associated with key.
func (v Values) Del(key string) {
	delete(v, key)
}

// Has checks whether a given key is set.
func (v Values) Has(key string) bool {
	_, ok := v[key]
	return ok
}

// Encode encodes the values into URL-encoded form ("bar=baz&foo=quux") sorted by key.
func (v Values) Encode() string {
	if len(v) == 0 {
		return ""
	}
	// Collect keys and sort them for deterministic output
	keys := make([]string, 0, len(v))
	for k := range v {
		keys = append(keys, k)
	}
	sortStrings(keys)

	var buf []byte
	for _, k := range keys {
		vs := v[k]
		keyEscaped := QueryEscape(k)
		for _, val := range vs {
			if len(buf) > 0 {
				buf = append(buf, '&')
			}
			buf = append(buf, keyEscaped...)
			buf = append(buf, '=')
			buf = append(buf, QueryEscape(val)...)
		}
	}
	return string(buf)
}

// ParseQuery parses the URL-encoded query string and returns a Values.
func ParseQuery(query string) (Values, error) {
	m := make(Values)
	err := parseQuery(m, query)
	return m, err
}

func parseQuery(m Values, query string) error {
	for query != "" {
		var key string
		key, query, _ = cut(query, "&")
		if key == "" {
			continue
		}
		k, v, _ := cut(key, "=")
		kk, err := QueryUnescape(k)
		if err != nil {
			return err
		}
		vv, err2 := QueryUnescape(v)
		if err2 != nil {
			return err2
		}
		m[kk] = append(m[kk], vv)
	}
	return nil
}

// Query parses RawQuery and returns the corresponding Values.
func (u *URL) Query() Values {
	v, _ := ParseQuery(u.RawQuery)
	return v
}

// ============================================
// Escaping
// ============================================

const (
	encodeQueryComponent = 1
	encodePath           = 2
	encodeUserPassword   = 3
	encodeHost           = 4
	encodeFragment       = 5
	encodePathSegment    = 6
)

// shouldEscape reports whether the specified byte should be escaped.
func shouldEscape(c byte, mode int) bool {
	// Unreserved characters (RFC 3986 2.3): ALPHA / DIGIT / "-" / "." / "_" / "~"
	if (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') {
		return false
	}
	if c == '-' || c == '_' || c == '.' || c == '~' {
		return false
	}

	if mode == encodeQueryComponent {
		// In query, everything except unreserved needs escaping.
		// Space is encoded as +.
		return true
	} else if mode == encodePath {
		// Allowed: / : @ ! $ & ' ( ) * + , ; =
		if c == '/' || c == ':' || c == '@' || c == '!' || c == '$' || c == '&' || c == '\'' || c == '(' || c == ')' || c == '*' || c == '+' || c == ',' || c == ';' || c == '=' {
			return false
		}
	} else if mode == encodePathSegment {
		// Like path but '/' is escaped
		if c == ':' || c == '@' || c == '!' || c == '$' || c == '&' || c == '\'' || c == '(' || c == ')' || c == '*' || c == '+' || c == ',' || c == ';' || c == '=' {
			return false
		}
	} else if mode == encodeUserPassword {
		// Allowed: unreserved + some sub-delims (excluding : and @)
		if c == '!' || c == '$' || c == '&' || c == '\'' || c == '(' || c == ')' || c == '*' || c == '+' || c == ',' || c == ';' || c == '=' {
			return false
		}
	} else if mode == encodeHost {
		// Hosts should not normally be escaped much.
		if c == ':' || c == '[' || c == ']' {
			return false
		}
	} else if mode == encodeFragment {
		// Like path but also allow ? and /
		if c == '/' || c == ':' || c == '@' || c == '!' || c == '$' || c == '&' || c == '\'' || c == '(' || c == ')' || c == '*' || c == '+' || c == ',' || c == ';' || c == '=' || c == '?' {
			return false
		}
	}
	return true
}

const upperhex = "0123456789ABCDEF"

func escape(s string, mode int) string {
	spaceCount := 0
	hexCount := 0
	for i := 0; i < len(s); i++ {
		c := s[i]
		if shouldEscape(c, mode) {
			if c == ' ' && mode == encodeQueryComponent {
				spaceCount++
			} else {
				hexCount++
			}
		}
	}
	if spaceCount == 0 && hexCount == 0 {
		return s
	}

	buf := make([]byte, 0, len(s)+2*hexCount)
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c == ' ' && mode == encodeQueryComponent {
			buf = append(buf, '+')
		} else if shouldEscape(c, mode) {
			buf = append(buf, '%')
			buf = append(buf, upperhex[c>>4])
			buf = append(buf, upperhex[c&0x0F])
		} else {
			buf = append(buf, c)
		}
	}
	return string(buf)
}

func unescape(s string, mode int) (string, error) {
	// Count %, check they are well-formed.
	n := 0
	hasPlus := false
	for i := 0; i < len(s); {
		if s[i] == '%' {
			if i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {
				return "", errors.New("invalid URL escape \"" + s[i:i+3] + "\"")
			}
			n++
			i += 3
		} else if s[i] == '+' {
			hasPlus = mode == encodeQueryComponent
			i++
		} else {
			i++
		}
	}
	if n == 0 && !hasPlus {
		return s, nil
	}

	buf := make([]byte, 0, len(s)-2*n)
	for i := 0; i < len(s); {
		if s[i] == '%' {
			buf = append(buf, unhex(s[i+1])<<4|unhex(s[i+2]))
			i += 3
		} else if s[i] == '+' && mode == encodeQueryComponent {
			buf = append(buf, ' ')
			i++
		} else {
			buf = append(buf, s[i])
			i++
		}
	}
	return string(buf), nil
}

func ishex(c byte) bool {
	return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')
}

func unhex(c byte) byte {
	if c >= '0' && c <= '9' {
		return c - '0'
	} else if c >= 'a' && c <= 'f' {
		return c - 'a' + 10
	} else if c >= 'A' && c <= 'F' {
		return c - 'A' + 10
	}
	return 0
}

// QueryEscape escapes the string so it can be safely placed inside a URL query.
func QueryEscape(s string) string {
	return escape(s, encodeQueryComponent)
}

// QueryUnescape does the inverse transformation of QueryEscape.
func QueryUnescape(s string) (string, error) {
	return unescape(s, encodeQueryComponent)
}

// PathEscape escapes the string so it can be safely placed inside a URL path segment.
func PathEscape(s string) string {
	return escape(s, encodePathSegment)
}

// PathUnescape does the inverse transformation of PathEscape.
func PathUnescape(s string) (string, error) {
	return unescape(s, encodePath)
}

// ============================================
// Helper: simple string sort (insertion sort)
// ============================================

// JoinPath returns a URL with the provided path elements joined to the
// existing path of base and the resulting path cleaned of any ./ or ../ elements.
func JoinPath(base string, elem ...string) (result string, err error) {
	u, err := Parse(base)
	if err != nil {
		return "", err
	}
	result2, err := u.JoinPath(elem...)
	if err != nil {
		return "", err
	}
	return result2.String(), nil
}

// JoinPath returns a new URL with the provided path elements joined to the
// existing path of u and the resulting path cleaned of any ./ or ../ elements.
func (u *URL) JoinPath(elem ...string) (*URL, error) {
	p := u.Path
	for _, e := range elem {
		if e == "" {
			continue
		}
		if len(p) > 0 && p[len(p)-1] != '/' {
			p += "/"
		}
		if len(e) > 0 && e[0] == '/' {
			e = e[1:]
		}
		p += e
	}
	url2 := *u
	url2.Path = p
	return &url2, nil
}

func sortStrings(a []string) {
	for i := 1; i < len(a); i++ {
		key := a[i]
		j := i - 1
		for j >= 0 && a[j] > key {
			a[j+1] = a[j]
			j--
		}
		a[j+1] = key
	}
}

package http

import (
	"bytes"
	"context"
	"encoding/base64"
	"errors"
	"io"
	"net"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// ==================== Status Codes ====================

const (
	StatusContinue           = 100
	StatusSwitchingProtocols = 101
	StatusOK                 = 200
	StatusCreated            = 201
	StatusAccepted           = 202
	StatusNoContent          = 204
	StatusMovedPermanently   = 301
	StatusFound              = 302
	StatusNotModified        = 304
	StatusBadRequest         = 400
	StatusUnauthorized       = 401
	StatusForbidden          = 403
	StatusNotFound           = 404
	StatusMethodNotAllowed   = 405
	StatusRequestTimeout     = 408
	StatusInternalServerError = 500
	StatusNotImplemented     = 501
	StatusBadGateway         = 502
	StatusServiceUnavailable = 503
	StatusGatewayTimeout     = 504
)

// ==================== Methods ====================

const (
	MethodGet     = "GET"
	MethodHead    = "HEAD"
	MethodPost    = "POST"
	MethodPut     = "PUT"
	MethodPatch   = "PATCH"
	MethodDelete  = "DELETE"
	MethodOptions = "OPTIONS"
)

// ==================== Header ====================

// Header represents the key-value pairs in an HTTP header.
type Header map[string][]string

// CanonicalHeaderKey returns the canonical format of the header key s.
// The canonicalization converts the first letter and any letter following a hyphen to upper case;
// the rest are converted to lowercase.
func CanonicalHeaderKey(s string) string {
	if s == "" {
		return ""
	}
	b := []byte(s)
	upper := true
	for i, c := range b {
		if upper && c >= 'a' && c <= 'z' {
			b[i] = c - 32
		} else if !upper && c >= 'A' && c <= 'Z' {
			b[i] = c + 32
		}
		upper = c == '-'
	}
	return string(b)
}

// Add adds the key-value pair to the header.
func (h Header) Add(key, value string) {
	h[key] = append(h[key], value)
}

// Set sets the header entries associated with key to the single element value.
func (h Header) Set(key, value string) {
	h[key] = []string{value}
}

// Get gets the first value associated with the given key.
func (h Header) Get(key string) string {
	if v, ok := h[key]; ok && len(v) > 0 {
		return v[0]
	}
	return ""
}

// Del deletes the values associated with key.
func (h Header) Del(key string) {
	delete(h, key)
}

// Values returns all values associated with the given key.
func (h Header) Values(key string) []string {
	return h[key]
}

// Clone returns a copy of h.
func (h Header) Clone() Header {
	h2 := make(Header)
	for k, vv := range h {
		vv2 := make([]string, len(vv))
		copy(vv2, vv)
		h2[k] = vv2
	}
	return h2
}

// Write writes a header in wire format to w.
func (h Header) Write(w io.Writer) error {
	for k, vv := range h {
		for _, v := range vv {
			line := k + ": " + v + "\r\n"
			if _, err := io.WriteString(w, line); err != nil {
				return err
			}
		}
	}
	return nil
}

// WriteSubset writes a header in wire format to w, excluding keys in exclude.
func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error {
	for k, vv := range h {
		if exclude != nil && exclude[k] {
			continue
		}
		for _, v := range vv {
			line := k + ": " + v + "\r\n"
			if _, err := io.WriteString(w, line); err != nil {
				return err
			}
		}
	}
	return nil
}

// ==================== Request ====================

// Request represents an HTTP request received by a server or to be sent by a client.
type Request struct {
	Method        string
	URL           *url.URL
	Proto         string
	Header        Header
	Body          io.Reader
	ContentLength int64
	Host          string
	RemoteAddr    string
	RequestURI    string
	Form          url.Values
	ctx           context.Context
}

// NewRequestWithContext returns a Request suitable for use with Client.Do or Transport.RoundTrip
// to make an HTTP client request. The provided ctx must be non-nil. If the context is cancelled,
// requests made with this Request will be cancelled.
func NewRequestWithContext(ctx context.Context, method, rawurl string, body io.Reader) (*Request, error) {
	req, err := NewRequest(method, rawurl, body)
	if err != nil {
		return nil, err
	}
	req.ctx = ctx
	return req, nil
}

// NewRequest creates a new Request with the given method, URL, and optional body.
func NewRequest(method, rawurl string, body io.Reader) (*Request, error) {
	if method == "" {
		method = MethodGet
	}
	u, err := url.Parse(rawurl)
	if err != nil {
		return nil, err
	}
	req := &Request{
		Method: method,
		URL:    u,
		Proto:  "HTTP/1.1",
		Header: make(Header),
		Body:   body,
		Host:   u.Host,
	}
	return req, nil
}

// Context returns the request's context. To change the context, use WithContext.
func (r *Request) Context() context.Context {
	if r.ctx != nil {
		return r.ctx
	}
	return context.Background()
}

// WithContext returns a shallow copy of r with its context changed to ctx.
func (r *Request) WithContext(ctx context.Context) *Request {
	r2 := *r
	r2.ctx = ctx
	return &r2
}

// Clone returns a deep copy of r with its context changed to ctx.
func (r *Request) Clone(ctx context.Context) *Request {
	r2 := r.WithContext(ctx)
	if r.Header != nil {
		r2.Header = make(Header)
		for k, v := range r.Header {
			r2.Header[k] = v
		}
	}
	return r2
}

// FormValue returns the first value for the named component of the query.
// POST and PUT body parameters take precedence over URL query string values.
// FormValue calls ParseForm if necessary.
func (r *Request) FormValue(key string) string {
	if r.Form == nil {
		r.ParseForm()
	}
	if vs, ok := r.Form[key]; ok && len(vs) > 0 {
		return vs[0]
	}
	return ""
}

// ParseForm populates r.Form from URL query parameters and, for POST/PUT,
// the request body if Content-Type is application/x-www-form-urlencoded.
func (r *Request) ParseForm() error {
	if r.Form != nil {
		return nil
	}
	r.Form = make(url.Values)
	// Parse query string
	if r.URL != nil && r.URL.RawQuery != "" {
		q := r.URL.Query()
		for k, vs := range q {
			for _, v := range vs {
				r.Form.Add(k, v)
			}
		}
	}
	// Parse body for POST/PUT with form content type
	if (r.Method == MethodPost || r.Method == MethodPut) && r.Body != nil {
		ct := r.Header.Get("Content-Type")
		if strings.HasPrefix(ct, "application/x-www-form-urlencoded") {
			body, err := io.ReadAll(r.Body)
			if err != nil {
				return err
			}
			formValues, err := url.ParseQuery(string(body))
			if err != nil {
				return err
			}
			// Form body values take precedence by being added first lookup
			merged := make(url.Values)
			for k, vs := range formValues {
				for _, v := range vs {
					merged.Add(k, v)
				}
			}
			for k, vs := range r.Form {
				for _, v := range vs {
					merged.Add(k, v)
				}
			}
			r.Form = merged
		}
	}
	return nil
}

// ==================== Response ====================

// Response represents the response from an HTTP request.
type Response struct {
	Status        string
	StatusCode    int
	Proto         string
	Header        Header
	Body          io.ReadCloser
	ContentLength int64
	Request       *Request
}

// Cookies parses and returns the cookies set in the Set-Cookie headers.
func (r *Response) Cookies() []*Cookie {
	var cookies []*Cookie
	for _, line := range r.Header["Set-Cookie"] {
		parts := strings.Split(line, ";")
		if len(parts) == 0 {
			continue
		}
		kv := strings.TrimSpace(parts[0])
		i := strings.Index(kv, "=")
		if i <= 0 {
			continue
		}
		cookies = append(cookies, &Cookie{
			Name:  kv[:i],
			Value: kv[i+1:],
		})
	}
	return cookies
}

// ==================== Client ====================

// Client is an HTTP client.
type Client struct {
	Timeout time.Duration
}

// DefaultClient is the default Client.
var DefaultClient = &Client{}

// Get issues a GET to the specified URL.
func Get(url string) (*Response, error) {
	return DefaultClient.Get(url)
}

// Head issues a HEAD to the specified URL.
func Head(url string) (*Response, error) {
	return DefaultClient.Head(url)
}

// Post issues a POST to the specified URL.
func Post(url, contentType string, body io.Reader) (*Response, error) {
	return DefaultClient.Post(url, contentType, body)
}

// PostForm issues a POST to the specified URL with data's keys and values
// URL-encoded as the request body.
func PostForm(url string, data url.Values) (*Response, error) {
	return DefaultClient.PostForm(url, data)
}

// Get issues a GET to the specified URL.
func (c *Client) Get(url string) (*Response, error) {
	req, err := NewRequest(MethodGet, url, nil)
	if err != nil {
		return nil, err
	}
	return c.Do(req)
}

// Head issues a HEAD to the specified URL.
func (c *Client) Head(url string) (*Response, error) {
	req, err := NewRequest(MethodHead, url, nil)
	if err != nil {
		return nil, err
	}
	return c.Do(req)
}

// Post issues a POST to the specified URL.
func (c *Client) Post(url, contentType string, body io.Reader) (*Response, error) {
	req, err := NewRequest(MethodPost, url, body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", contentType)
	return c.Do(req)
}

// PostForm issues a POST to the specified URL with data's keys and values
// URL-encoded as the request body.
func (c *Client) PostForm(rawurl string, data url.Values) (*Response, error) {
	return c.Post(rawurl, "application/x-www-form-urlencoded", strings.NewReader(data.Encode()))
}

// Do sends an HTTP request and returns an HTTP response.
func (c *Client) Do(req *Request) (*Response, error) {
	bodyBytes, err := readRequestBody(req)
	if err != nil {
		return nil, err
	}

	// HTTPS and timeout-enabled requests use the native bridge
	rawURL := req.URL.String()
	scheme := req.URL.Scheme
	if scheme == "https" || c.Timeout > 0 {
		return c.doNativeRequest(req, bodyBytes, rawURL)
	}

	// Plain HTTP: parse URL and use Vo TCP client
	_, dialAddr, hostHeader, reqPath, err := parseURL(rawURL)
	if err != nil {
		return nil, err
	}

	conn, err := net.Dial("tcp", dialAddr)
	if err != nil {
		return nil, err
	}

	// Build and send HTTP request
	if err := writeRequest(conn, req, hostHeader, reqPath, bodyBytes); err != nil {
		conn.Close()
		return nil, err
	}

	// Read and parse HTTP response
	resp, err := readResponse(conn, req)
	if err != nil {
		conn.Close()
		return nil, err
	}

	return resp, nil
}

func readRequestBody(req *Request) ([]byte, error) {
	if req.Body == nil {
		req.ContentLength = 0
		return []byte{}, nil
	}
	body, err := io.ReadAll(req.Body)
	if err != nil {
		return nil, err
	}
	req.ContentLength = int64(len(body))
	return body, nil
}

func (c *Client) doNativeRequest(req *Request, bodyBytes []byte, rawURL string) (*Response, error) {
	headers := requestHeaderLines(req, "")
	timeoutNs := int64(0)
	if c.Timeout > 0 {
		timeoutNs = c.Timeout.Nanoseconds()
	}

	statusCode, status, proto, responseHeaderLines, responseBody, err := nativeHttpsRequest(req.Method, rawURL, headers, bodyBytes, timeoutNs)
	if err != nil {
		return nil, err
	}

	respHeader := parseHeaderLines(responseHeaderLines)
	resp := &Response{
		Status:        status,
		StatusCode:    statusCode,
		Proto:         proto,
		Header:        respHeader,
		Body:          io.NopCloser(bytes.NewReader(responseBody)),
		ContentLength: contentLengthFromHeaders(respHeader, int64(len(responseBody))),
		Request:       req,
	}
	return resp, nil
}

// parseURL extracts host:port and path from URL.
// Supports http://host:port/path, https://host/path and host/path formats.
func parseURL(url string) (scheme, dialAddr, hostHeader, path string, err error) {
	rest := url
	scheme = "http"
	if strings.HasPrefix(rest, "http://") {
		rest = rest[7:]
	} else if strings.HasPrefix(rest, "https://") {
		scheme = "https"
		rest = rest[8:]
	}

	idx := strings.Index(rest, "/")
	qIdx := strings.Index(rest, "?")
	if idx == -1 || (qIdx != -1 && qIdx < idx) {
		idx = qIdx
	}
	if idx == -1 {
		hostHeader = rest
		path = "/"
	} else {
		hostHeader = rest[:idx]
		path = rest[idx:]
		if len(path) > 0 && path[0] == '?' {
			path = "/" + path
		}
	}

	if hostHeader == "" {
		return "", "", "", "", errors.New("invalid URL: missing host")
	}
	if path == "" {
		path = "/"
	}

	if hasAuthorityPort(hostHeader) {
		dialAddr = hostHeader
	} else if scheme == "https" {
		dialAddr = hostHeader + ":443"
	} else {
		dialAddr = hostHeader + ":80"
	}

	return scheme, dialAddr, hostHeader, path, nil
}

func urlScheme(url string) string {
	if strings.HasPrefix(url, "https://") {
		return "https"
	}
	return "http"
}

func hasAuthorityPort(authority string) bool {
	if strings.HasPrefix(authority, "[") {
		return strings.Contains(authority, "]:")
	}
	return strings.Contains(authority, ":")
}

// writeRequest writes HTTP request to connection.
func writeRequest(conn net.Conn, req *Request, hostHeader, path string, bodyBytes []byte) error {
	// Request line: METHOD /path HTTP/1.1\r\n
	line := req.Method + " " + path + " HTTP/1.1\r\n"
	if _, err := conn.Write([]byte(line)); err != nil {
		return err
	}

	for _, header := range requestHeaderLines(req, hostHeader) {
		if _, err := conn.Write([]byte(header + "\r\n")); err != nil {
			return err
		}
	}

	// End of headers
	if _, err := conn.Write([]byte("\r\n")); err != nil {
		return err
	}
	
	// Write body
	if len(bodyBytes) > 0 {
		if _, err := conn.Write(bodyBytes); err != nil {
			return err
		}
	}
	
	return nil
}

func requestHeaderLines(req *Request, hostHeader string) []string {
	lines := make([]string, 0, len(req.Header)+2)
	if hostHeader != "" && req.Header.Get("Host") == "" {
		lines = append(lines, "Host: "+hostHeader)
	}

	for key, values := range req.Header {
		for _, val := range values {
			lines = append(lines, key+": "+val)
		}
	}

	if req.ContentLength > 0 && req.Header.Get("Content-Length") == "" {
		lines = append(lines, "Content-Length: "+strconv.Itoa(int(req.ContentLength)))
	}

	return lines
}

func parseHeaderLines(lines []string) Header {
	h := make(Header)
	for _, line := range lines {
		idx := strings.Index(line, ":")
		if idx <= 0 {
			continue
		}
		key := strings.TrimSpace(line[:idx])
		val := strings.TrimSpace(line[idx+1:])
		h[key] = append(h[key], val)
	}
	return h
}

func contentLengthFromHeaders(headers Header, fallback int64) int64 {
	if cl := headers.Get("Content-Length"); cl != "" {
		if n, err := strconv.Atoi(cl); err == nil {
			return int64(n)
		}
	}
	return fallback
}

// readResponse reads and parses HTTP response from connection.
func readResponse(conn net.Conn, req *Request) (*Response, error) {
	// Read response into buffer
	buf := make([]byte, 4096)
	var data []byte
	
	// Read headers (until \r\n\r\n)
	for {
		n, err := conn.Read(buf)
		if err != nil && !errors.Is(err, io.EOF) {
			if len(data) == 0 {
				return nil, err
			}
			break
		}
		if n == 0 {
			break
		}
		data = append(data, buf[:n]...)
		
		// Check if we have complete headers
		if strings.Index(string(data), "\r\n\r\n") != -1 {
			break
		}
	}
	
	if len(data) == 0 {
		return nil, errors.New("empty response")
	}
	
	// Parse response
	text := string(data)
	headerEnd := strings.Index(text, "\r\n\r\n")
	if headerEnd == -1 {
		return nil, errors.New("invalid response: no header end")
	}
	
	headerPart := text[:headerEnd]
	bodyStart := data[headerEnd+4:]
	
	// Parse status line: HTTP/1.1 200 OK
	lines := strings.Split(headerPart, "\r\n")
	if len(lines) == 0 {
		return nil, errors.New("invalid response: no status line")
	}
	
	statusLine := lines[0]
	parts := strings.SplitN(statusLine, " ", 3)
	if len(parts) < 2 {
		return nil, errors.New("invalid status line")
	}
	
	proto := parts[0]
	statusCode, err := strconv.Atoi(parts[1])
	if err != nil {
		return nil, errors.New("invalid status code")
	}
	status := statusLine
	
	// Parse headers
	headers := make(Header)
	for i := 1; i < len(lines); i++ {
		line := lines[i]
		colonIdx := strings.Index(line, ":")
		if colonIdx == -1 {
			continue
		}
		key := strings.TrimSpace(line[:colonIdx])
		val := strings.TrimSpace(line[colonIdx+1:])
		headers[key] = append(headers[key], val)
	}
	
	// Get content length
	contentLength := int64(-1)
	if cl := headers.Get("Content-Length"); cl != "" {
		if n, err := strconv.Atoi(cl); err == nil {
			contentLength = int64(n)
		}
	}
	
	// Read remaining body if Content-Length specified
	body := bodyStart
	if contentLength > 0 && int64(len(body)) < contentLength {
		remaining := contentLength - int64(len(body))
		for remaining > 0 {
			n, err := conn.Read(buf)
			if err != nil {
				break
			}
			body = append(body, buf[:n]...)
			remaining -= int64(n)
		}
	}
	
	resp := &Response{
		Status:        status,
		StatusCode:    statusCode,
		Proto:         proto,
		Header:        headers,
		Body:          &connBody{conn: conn, buf: body, pos: 0},
		ContentLength: contentLength,
		Request:       req,
	}
	
	return resp, nil
}

// connBody implements io.ReadCloser for response body.
type connBody struct {
	conn net.Conn
	buf  []byte
	pos  int
}

func (b *connBody) Read(p []byte) (int, error) {
	if b.pos >= len(b.buf) {
		return 0, io.EOF
	}
	n := copy(p, b.buf[b.pos:])
	b.pos += n
	return n, nil
}

func (b *connBody) Close() error {
	return b.conn.Close()
}

// ==================== ResponseWriter and related interfaces ====================

// Flusher is implemented by ResponseWriters that allow an HTTP handler to flush
// buffered data to the client.
type Flusher interface {
	Flush()
}

// Hijacker is implemented by ResponseWriters that allow an HTTP handler to
// take over the connection.
type Hijacker interface {
	Hijack() (net.Conn, error)
}

// CloseNotifier is implemented by ResponseWriters which detect when the
// underlying connection has gone away. Deprecated: use Request.Context().
type CloseNotifier interface {
	CloseNotify() <-chan bool
}

// ResponseWriter interface is used by an HTTP handler to construct an HTTP response.
type ResponseWriter interface {
	Header() Header
	Write([]byte) (int, error)
	WriteHeader(statusCode int)
}

// ==================== Handler ====================

// Handler responds to an HTTP request.
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}

// HandlerFunc is an adapter to allow the use of ordinary functions as HTTP handlers.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}

// ==================== ServeMux ====================

// ServeMux is an HTTP request multiplexer.
type ServeMux struct {
	patterns []string
	handlers []Handler
}

// NewServeMux allocates and returns a new ServeMux.
func NewServeMux() *ServeMux {
	return &ServeMux{}
}

// Handle registers the handler for the given pattern.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.patterns = append(mux.patterns, pattern)
	mux.handlers = append(mux.handlers, handler)
}

// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}

// ServeHTTP dispatches the request to the handler whose pattern most closely matches.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	h := mux.match(r.RequestURI)
	if h == nil {
		NotFound(w, r)
		return
	}
	h.ServeHTTP(w, r)
}

func (mux *ServeMux) match(uri string) Handler {
	path := urlPath(uri)
	bestMatch := -1
	bestLen := 0
	for i, pattern := range mux.patterns {
		if pathMatch(pattern, path) {
			if len(pattern) > bestLen {
				bestMatch = i
				bestLen = len(pattern)
			}
		}
	}
	if bestMatch >= 0 {
		return mux.handlers[bestMatch]
	}
	return nil
}

// DefaultServeMux is the default ServeMux.
var DefaultServeMux = NewServeMux()

// Handle registers the handler for the given pattern in the DefaultServeMux.
func Handle(pattern string, handler Handler) {
	DefaultServeMux.Handle(pattern, handler)
}

// HandleFunc registers the handler function for the given pattern in the DefaultServeMux.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}

// ==================== Server ====================

// Server defines parameters for running an HTTP server.
type Server struct {
	Addr    string
	Handler Handler
	ln      net.Listener
}

var ErrServerClosed = errors.New("http: Server closed")

// Common HTTP errors.
var (
	ErrBodyReadAfterClose  = errors.New("http: invalid Read on closed Body")
	ErrHandlerTimeout      = errors.New("http: Handler timeout")
	ErrLineTooLong         = errors.New("http: header line too long")
	ErrMissingFile         = errors.New("http: no such file")
	ErrNotSupported        = errors.New("http: feature not supported by handler")
	ErrUnexpectedTrailer   = errors.New("http: trailer header without chunked transfer encoding")
	ErrMissingBoundary     = errors.New("http: no multipart boundary param in Content-Type")
	ErrNotMultipart        = errors.New("http: request Content-Type isn't multipart/form-data")
	ErrContentLength       = errors.New("http: wrote more than the declared Content-Length")
	ErrBodyNotAllowed      = errors.New("http: request method or response status code does not allow body")
	ErrHijacked            = errors.New("http: connection has been hijacked")
	ErrAbortHandler        = errors.New("net/http: abort Handler")
)

// ListenAndServe listens on the TCP network address addr and then calls Serve.
func (srv *Server) ListenAndServe() error {
	addr := srv.Addr
	if addr == "" {
		addr = ":8080"
	}
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	srv.ln = ln
	return srv.Serve(ln)
}

// Serve accepts incoming connections on the Listener l.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	
	handler := srv.Handler
	if handler == nil {
		handler = DefaultServeMux
	}
	if srv.ln == nil {
		srv.ln = l
	}
	
	for {
		conn, err := l.Accept()
		if err != nil {
			if err.Error() == "use of closed network connection" {
				srv.ln = nil
				return ErrServerClosed
			}
			srv.ln = nil
			return err
		}
		go srv.handleConn(conn, handler)
	}
}

func (srv *Server) handleConn(conn net.Conn, handler Handler) {
	defer conn.Close()

	req, err := parseRequest(conn)
	if err != nil {
		return
	}
	
	w := &serverResponseWriter{
		conn:   conn,
		header: make(Header),
	}
	
	handler.ServeHTTP(w, req)
	w.finishRequest()
}

// Close immediately closes all active connections and the listener.
func (srv *Server) Close() error {
	err := srv.ln.Close()
	srv.ln = nil
	return err
}

// ListenAndServe listens on the TCP network address addr and then calls Serve with handler.
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}

// ==================== Helper Functions ====================

// NotFound replies to the request with an HTTP 404 not found error.
// NotFoundHandler returns a simple request handler that replies to each request with a 404 page.
func NotFoundHandler() Handler {
	return HandlerFunc(NotFound)
}

// RedirectHandler returns a request handler that redirects each request it receives
// to the given url using the given status code.
func RedirectHandler(url string, code int) Handler {
	return HandlerFunc(func(w ResponseWriter, r *Request) {
		Redirect(w, r, url, code)
	})
}

func NotFound(w ResponseWriter, r *Request) {
	w.WriteHeader(StatusNotFound)
	w.Write([]byte("404 page not found\n"))
}

// Error replies to the request with the specified error message and HTTP code.
func Error(w ResponseWriter, error string, code int) {
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.WriteHeader(code)
	w.Write([]byte(error))
}

// Redirect replies to the request with a redirect to the given URL and status code.
func Redirect(w ResponseWriter, r *Request, redirectURL string, code int) {
	w.Header().Set("Location", redirectURL)
	if r.Method == MethodGet || r.Method == MethodHead {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
	}
	w.WriteHeader(code)
	if r.Method != MethodHead {
		body := "<a href=\"" + redirectURL + "\">" + StatusText(code) + "</a>.\n"
		w.Write([]byte(body))
	}
}

// ==================== Cookie ====================

// Cookie represents an HTTP cookie.
type Cookie struct {
	Name     string
	Value    string
	Path     string
	Domain   string
	MaxAge   int
	Secure   bool
	HttpOnly bool
}

// String returns the serialization of the cookie for use in a Set-Cookie header.
func (c *Cookie) String() string {
	var b []byte
	b = append(b, c.Name...)
	b = append(b, '=')
	b = append(b, c.Value...)
	if c.Path != "" {
		b = append(b, "; Path="...)
		b = append(b, c.Path...)
	}
	if c.Domain != "" {
		b = append(b, "; Domain="...)
		b = append(b, c.Domain...)
	}
	if c.MaxAge > 0 {
		b = append(b, "; Max-Age="...)
		b = append(b, strconv.Itoa(c.MaxAge)...)
	} else if c.MaxAge < 0 {
		b = append(b, "; Max-Age=0"...)
	}
	if c.Secure {
		b = append(b, "; Secure"...)
	}
	if c.HttpOnly {
		b = append(b, "; HttpOnly"...)
	}
	return string(b)
}

// SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.
func SetCookie(w ResponseWriter, cookie *Cookie) {
	w.Header().Add("Set-Cookie", cookie.String())
}

// Cookies parses and returns the HTTP cookies sent with the request.
func (r *Request) Cookies() []*Cookie {
	var cookies []*Cookie
	for _, line := range r.Header.Values("Cookie") {
		parts := strings.Split(line, ";")
		for _, part := range parts {
			part = strings.TrimSpace(part)
			i := strings.Index(part, "=")
			if i <= 0 {
				continue
			}
			cookies = append(cookies, &Cookie{
				Name:  part[:i],
				Value: part[i+1:],
			})
		}
	}
	return cookies
}

// Cookie returns the named cookie provided in the request.
func (r *Request) Cookie(name string) (*Cookie, error) {
	for _, c := range r.Cookies() {
		if c.Name == name {
			return c, nil
		}
	}
	return nil, ErrNoCookie
}

var ErrNoCookie = errors.New("http: named cookie not present")

// UserAgent returns the client's User-Agent, if sent in the request.
func (r *Request) UserAgent() string {
	return r.Header.Get("User-Agent")
}

// Referer returns the referring URL, if sent in the request.
func (r *Request) Referer() string {
	return r.Header.Get("Referer")
}

// BasicAuth returns the username and password provided in the request's
// Authorization header, if the request uses HTTP Basic Authentication.
func (r *Request) BasicAuth() (username, password string, ok bool) {
	auth := r.Header.Get("Authorization")
	if auth == "" {
		return "", "", false
	}
	if !strings.HasPrefix(auth, "Basic ") {
		return "", "", false
	}
	decoded, err := base64.DecodeString(auth[6:])
	if err != nil {
		return "", "", false
	}
	cs := string(decoded)
	i := strings.Index(cs, ":")
	if i < 0 {
		return cs, "", true
	}
	return cs[:i], cs[i+1:], true
}

// ProtoAtLeast reports whether the HTTP protocol used in the request is
// at least major.minor.
func (r *Request) ProtoAtLeast(major, minor int) bool {
	if !strings.HasPrefix(r.Proto, "HTTP/") {
		return false
	}
	parts := strings.Split(r.Proto[5:], ".")
	if len(parts) != 2 {
		return false
	}
	pMajor, err1 := strconv.Atoi(parts[0])
	pMinor, err2 := strconv.Atoi(parts[1])
	if err1 != nil || err2 != nil {
		return false
	}
	return pMajor > major || (pMajor == major && pMinor >= minor)
}

// StatusText returns a text for the HTTP status code.
func StatusText(code int) string {
	switch code {
	case StatusContinue:
		return "Continue"
	case StatusSwitchingProtocols:
		return "Switching Protocols"
	case StatusOK:
		return "OK"
	case StatusCreated:
		return "Created"
	case StatusAccepted:
		return "Accepted"
	case StatusNoContent:
		return "No Content"
	case StatusMovedPermanently:
		return "Moved Permanently"
	case StatusFound:
		return "Found"
	case StatusNotModified:
		return "Not Modified"
	case StatusBadRequest:
		return "Bad Request"
	case StatusUnauthorized:
		return "Unauthorized"
	case StatusForbidden:
		return "Forbidden"
	case StatusNotFound:
		return "Not Found"
	case StatusMethodNotAllowed:
		return "Method Not Allowed"
	case StatusRequestTimeout:
		return "Request Timeout"
	case StatusInternalServerError:
		return "Internal Server Error"
	case StatusNotImplemented:
		return "Not Implemented"
	case StatusBadGateway:
		return "Bad Gateway"
	case StatusServiceUnavailable:
		return "Service Unavailable"
	case StatusGatewayTimeout:
		return "Gateway Timeout"
	}
	return ""
}

// ==================== Internal Response Writer ====================

type serverResponseWriter struct {
	conn        net.Conn
	header      Header
	wroteHeader bool
	statusCode  int
}

func (w *serverResponseWriter) Header() Header {
	return w.header
}

func (w *serverResponseWriter) Write(data []byte) (int, error) {
	if !w.wroteHeader {
		w.WriteHeader(StatusOK)
	}
	return w.conn.Write(data)
}

func (w *serverResponseWriter) WriteHeader(statusCode int) {
	if w.wroteHeader {
		return
	}
	w.wroteHeader = true
	w.statusCode = statusCode
	if w.header.Get("Connection") == "" {
		w.header.Set("Connection", "close")
	}
	
	status := "HTTP/1.1 " + strconv.Itoa(statusCode) + " " + StatusText(statusCode) + "\r\n"
	w.conn.Write([]byte(status))
	
	for key, values := range w.header {
		for _, value := range values {
			w.conn.Write([]byte(key + ": " + value + "\r\n"))
		}
	}
	w.conn.Write([]byte("\r\n"))
}

func (w *serverResponseWriter) finishRequest() {
	if !w.wroteHeader {
		w.WriteHeader(StatusOK)
	}
}

// ==================== Internal Helpers ====================

func urlPath(url string) string {
	start := 0
	for i := 0; i < len(url); i++ {
		if url[i] == '/' && i+1 < len(url) && url[i+1] == '/' {
			i += 2
			for i < len(url) && url[i] != '/' {
				i++
			}
			start = i
			break
		}
	}
	if start == 0 && len(url) > 0 && url[0] == '/' {
		start = 0
	}
	end := len(url)
	for i := start; i < len(url); i++ {
		if url[i] == '?' {
			end = i
			break
		}
	}
	if start >= end {
		return "/"
	}
	return url[start:end]
}

func pathMatch(pattern, path string) bool {
	if len(pattern) == 0 {
		return false
	}
	if pattern == path {
		return true
	}
	if pattern[len(pattern)-1] == '/' {
		return len(path) >= len(pattern) && path[:len(pattern)] == pattern
	}
	return false
}


func parseRequest(conn net.Conn) (*Request, error) {
	buf := make([]byte, 4096)
	n, err := conn.Read(buf)
	if err != nil {
		return nil, err
	}
	
	data := string(buf[:n])
	
	// Parse request line
	lineEnd := 0
	for i := 0; i < len(data)-1; i++ {
		if data[i] == '\r' && data[i+1] == '\n' {
			lineEnd = i
			break
		}
	}
	if lineEnd == 0 {
		return nil, errors.New("invalid request line")
	}
	
	reqLine := data[:lineEnd]
	method, rest := parseWord(reqLine)
	uri, proto := parseWord(rest)
	
	parsedURL, _ := url.Parse(uri)
	req := &Request{
		Method:     method,
		URL:        parsedURL,
		RequestURI: uri,
		Proto:      proto,
		Header:     make(Header),
	}
	
	// Parse headers
	pos := lineEnd + 2
	for pos < len(data)-1 {
		if data[pos] == '\r' && data[pos+1] == '\n' {
			break
		}
		hdrEnd := pos
		for hdrEnd < len(data)-1 {
			if data[hdrEnd] == '\r' && data[hdrEnd+1] == '\n' {
				break
			}
			hdrEnd++
		}
		hdrLine := data[pos:hdrEnd]
		colonIdx := -1
		for i := 0; i < len(hdrLine); i++ {
			if hdrLine[i] == ':' {
				colonIdx = i
				break
			}
		}
		if colonIdx > 0 {
			key := hdrLine[:colonIdx]
			val := hdrLine[colonIdx+1:]
			for len(val) > 0 && val[0] == ' ' {
				val = val[1:]
			}
			req.Header.Add(key, val)
		}
		pos = hdrEnd + 2
	}
	
	// Read body based on Content-Length
	bodyStartPos := pos + 2
	if bodyStartPos < len(data) {
		clStr := req.Header.Get("Content-Length")
		if clStr != "" {
			cl, clErr := strconv.Atoi(clStr)
			if clErr == nil && cl > 0 {
				bodyData := data[bodyStartPos:]
				// If we already have all the body
				if len(bodyData) >= cl {
					req.Body = bytes.NewReader([]byte(bodyData[:cl]))
					req.ContentLength = int64(cl)
				} else {
					// Need to read more body data
					fullBody := make([]byte, 0, cl)
					fullBody = append(fullBody, bodyData...)
					readBuf := make([]byte, 4096)
					for len(fullBody) < cl {
						rn, rerr := conn.Read(readBuf)
						if rerr != nil {
							break
						}
						fullBody = append(fullBody, readBuf[:rn]...)
					}
					req.Body = bytes.NewReader(fullBody[:cl])
					req.ContentLength = int64(cl)
				}
			}
		}
	}

	return req, nil
}

func parseWord(s string) (word, rest string) {
	for len(s) > 0 && s[0] == ' ' {
		s = s[1:]
	}
	end := 0
	for end < len(s) && s[end] != ' ' {
		end++
	}
	word = s[:end]
	rest = s[end:]
	for len(rest) > 0 && rest[0] == ' ' {
		rest = rest[1:]
	}
	return word, rest
}

func nativeHttpsRequest(method, url string, headers []string, body []byte, timeoutNs int64) (int, string, string, []string, []byte, error)

// DetectContentType implements the algorithm described at
// https://mimesniff.spec.whatwg.org/ to determine the Content-Type
// of the given data. It considers at most the first 512 bytes of data.
func DetectContentType(data []byte) string {
	if len(data) > 512 {
		data = data[:512]
	}
	if len(data) >= 4 {
		if data[0] == 0xFF && data[1] == 0xD8 && data[2] == 0xFF {
			return "image/jpeg"
		}
		if data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47 {
			return "image/png"
		}
		if data[0] == 0x47 && data[1] == 0x49 && data[2] == 0x46 {
			return "image/gif"
		}
		if data[0] == 0x25 && data[1] == 0x50 && data[2] == 0x44 && data[3] == 0x46 {
			return "application/pdf"
		}
		if data[0] == 0x50 && data[1] == 0x4B && data[2] == 0x03 && data[3] == 0x04 {
			return "application/zip"
		}
		if data[0] == 0x52 && data[1] == 0x49 && data[2] == 0x46 && data[3] == 0x46 {
			return "audio/wave"
		}
	}
	if len(data) >= 8 {
		if data[0] == 0x42 && data[1] == 0x4D {
			return "image/bmp"
		}
		if data[4] == 0x66 && data[5] == 0x74 && data[6] == 0x79 && data[7] == 0x70 {
			return "video/mp4"
		}
	}
	// Check for text-based types
	s := string(data)
	for _, b := range data {
		if b > 0x7E && b < 0x80 {
			continue
		}
		if b < 0x09 || (b >= 0x0E && b < 0x20 && b != 0x1B) {
			return "application/octet-stream"
		}
	}
	if strings.HasPrefix(s, "<?xml") || strings.HasPrefix(s, "<xml") {
		return "text/xml; charset=utf-8"
	}
	if strings.HasPrefix(s, "<!DOCTYPE html") || strings.HasPrefix(s, "<html") || strings.HasPrefix(s, "<head") || strings.HasPrefix(s, "<body") {
		return "text/html; charset=utf-8"
	}
	if strings.HasPrefix(s, "{") || strings.HasPrefix(s, "[") {
		return "application/json"
	}
	return "text/plain; charset=utf-8"
}

// ==================== File Serving ====================

// fileHandler serves files from the file system rooted at root.
type fileHandler struct {
	root string
}

// FileServer returns a handler that serves HTTP requests with the contents
// of the file system rooted at root.
func FileServer(root string) Handler {
	return &fileHandler{root: root}
}

func (fh *fileHandler) ServeHTTP(w ResponseWriter, r *Request) {
	upath := r.URL.Path
	if !strings.HasPrefix(upath, "/") {
		upath = "/" + upath
	}
	fullPath := filepath.Join([]string{fh.root, filepath.FromSlash(upath)})
	fi, err := os.Stat(fullPath)
	if err != nil {
		if os.IsNotExist(err) {
			NotFound(w, r)
		} else {
			Error(w, "Internal Server Error", StatusInternalServerError)
		}
		return
	}
	if fi.IsDir() {
		indexPath := filepath.Join([]string{fullPath, "index.html"})
		if _, err2 := os.Stat(indexPath); err2 == nil {
			fullPath = indexPath
			fi, _ = os.Stat(fullPath)
		} else {
			serveDirectory(w, r, fullPath)
			return
		}
	}
	serveFile(w, r, fullPath, fi)
}

func serveFile(w ResponseWriter, r *Request, path string, fi os.FileInfo) {
	f, err := os.Open(path)
	if err != nil {
		Error(w, "Internal Server Error", StatusInternalServerError)
		return
	}
	defer f.Close()
	content, err := io.ReadAll(f)
	if err != nil {
		Error(w, "Internal Server Error", StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", mimeTypeForPath(path))
	w.Header().Set("Content-Length", strconv.Itoa(len(content)))
	w.WriteHeader(StatusOK)
	w.Write(content)
}

func serveDirectory(w ResponseWriter, r *Request, path string) {
	entries, err := os.ReadDir(path)
	if err != nil {
		Error(w, "Internal Server Error", StatusInternalServerError)
		return
	}
	var sb strings.Builder
	sb.WriteString("<html><body><ul>")
	for _, e := range entries {
		name := e.Name()
		if e.IsDir() {
			name = name + "/"
		}
		sb.WriteString("<li><a href=\"")
		sb.WriteString(name)
		sb.WriteString("\">")
		sb.WriteString(name)
		sb.WriteString("</a></li>")
	}
	sb.WriteString("</ul></body></html>")
	body := []byte(sb.String())
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.Header().Set("Content-Length", strconv.Itoa(len(body)))
	w.WriteHeader(StatusOK)
	w.Write(body)
}

func mimeTypeForPath(path string) string {
	ext := strings.ToLower(filepath.Ext(path))
	switch ext {
	case ".html", ".htm":
		return "text/html; charset=utf-8"
	case ".css":
		return "text/css; charset=utf-8"
	case ".js":
		return "application/javascript"
	case ".json":
		return "application/json"
	case ".png":
		return "image/png"
	case ".jpg", ".jpeg":
		return "image/jpeg"
	case ".gif":
		return "image/gif"
	case ".svg":
		return "image/svg+xml"
	case ".ico":
		return "image/x-icon"
	case ".txt":
		return "text/plain; charset=utf-8"
	case ".pdf":
		return "application/pdf"
	case ".wasm":
		return "application/wasm"
	default:
		return "application/octet-stream"
	}
}

// maxBytesReader wraps an io.ReadCloser and enforces a byte limit.
type maxBytesReader struct {
	r   io.ReadCloser
	n   int64
	err error
}

func (m *maxBytesReader) Read(p []byte) (n int, err error) {
	if m.err != nil {
		return 0, m.err
	}
	if int64(len(p)) > m.n+1 {
		p = p[:m.n+1]
	}
	n, err = m.r.Read(p)
	m.n -= int64(n)
	if m.n < 0 {
		m.err = errors.New("http: request body too large")
		return n + int(m.n), m.err
	}
	return n, err
}

func (m *maxBytesReader) Close() error { return m.r.Close() }

// MaxBytesReader is similar to io.LimitReader but is intended for limiting
// the size of incoming request bodies. It returns an error if the limit is exceeded.
func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser {
	return &maxBytesReader{r: r, n: n}
}

// maxBytesHandlerImpl wraps a handler with a max bytes limit on the request body.
type maxBytesHandlerImpl struct {
	h   Handler
	n   int64
}

func (m *maxBytesHandlerImpl) ServeHTTP(w ResponseWriter, r *Request) {
	r2 := *r
	var rc io.ReadCloser
	if closer, ok := r.Body.(io.ReadCloser); ok {
		rc = closer
	} else {
		rc = io.NopCloser(r.Body)
	}
	r2.Body = MaxBytesReader(w, rc, m.n)
	m.h.ServeHTTP(w, &r2)
}

// MaxBytesHandler returns a Handler that runs h with its ResponseWriter and Request.Body
// limited to at most n bytes. This protects servers from abuse by clients sending large bodies.
func MaxBytesHandler(h Handler, n int64) Handler {
	return &maxBytesHandlerImpl{h: h, n: n}
}

// StripPrefix returns a handler that serves HTTP requests by removing the
// given prefix from the request's URL Path and invoking the handler h.
func StripPrefix(prefix string, h Handler) Handler {
	if prefix == "" {
		return h
	}
	return HandlerFunc(func(w ResponseWriter, r *Request) {
		origPath := r.URL.Path
		p := strings.TrimPrefix(origPath, prefix)
		if len(p) < len(origPath) {
			r2 := *r
			r2.URL = &url.URL{Path: p, RawQuery: r.URL.RawQuery}
			h.ServeHTTP(w, &r2)
		} else {
			NotFound(w, r)
		}
	})
}

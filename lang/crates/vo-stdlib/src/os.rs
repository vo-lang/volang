//! os package native function implementations.
//!
//! This module requires std for file system operations.
//! In no_std mode, all functions panic with "requires std".

#[cfg(feature = "std")]
use std::fs::{self, File, OpenOptions};
#[cfg(feature = "std")]
use std::io::{Read, Seek, SeekFrom, Write};
#[cfg(feature = "std")]
use std::os::unix::fs::{MetadataExt, PermissionsExt, symlink};
#[cfg(feature = "std")]
use std::os::unix::io::AsRawFd;
#[cfg(feature = "std")]
use std::collections::HashMap;
#[cfg(feature = "std")]
use std::sync::Mutex;

#[cfg(feature = "std")]
use vo_common_core::types::ValueKind;
use vo_ffi_macro::{vostd_fn, vostd_errors, vo_consts};
use vo_runtime::ffi::{ExternCallContext, ExternResult};
#[cfg(feature = "std")]
use vo_runtime::gc::{Gc, GcRef};
#[cfg(feature = "std")]
use vo_runtime::io::{IoHandle, CompletionData};
#[cfg(feature = "std")]
use vo_runtime::objects::slice;
#[cfg(feature = "std")]
use vo_runtime::slot::SLOT_BYTES;
#[cfg(feature = "std")]
use vo_runtime::builtins::error_helper::{write_error_to, write_nil_error};


#[cfg(feature = "std")]
const MODE_DIR: u32 = 1 << 31;
#[cfg(feature = "std")]
const MODE_SYMLINK: u32 = 1 << 27;

#[cfg(feature = "std")]
lazy_static::lazy_static! {
    static ref FILE_HANDLES: Mutex<HashMap<i32, File>> = Mutex::new(HashMap::new());
    static ref NEXT_FD: Mutex<i32> = Mutex::new(100);
}

#[cfg(feature = "std")]
fn register_file(file: File) -> i32 {
    #[cfg(unix)]
    {
        let raw_fd = file.as_raw_fd();

        let fd_flags = unsafe { libc::fcntl(raw_fd, libc::F_GETFD) };
        if fd_flags == -1 {
            panic!("fcntl(F_GETFD) failed: {}", std::io::Error::last_os_error());
        }
        let ret = unsafe { libc::fcntl(raw_fd, libc::F_SETFD, fd_flags | libc::FD_CLOEXEC) };
        if ret == -1 {
            panic!("fcntl(F_SETFD) failed: {}", std::io::Error::last_os_error());
        }

        let flags = unsafe { libc::fcntl(raw_fd, libc::F_GETFL) };
        if flags == -1 {
            panic!("fcntl(F_GETFL) failed: {}", std::io::Error::last_os_error());
        }
        let ret = unsafe { libc::fcntl(raw_fd, libc::F_SETFL, flags | libc::O_NONBLOCK) };
        if ret == -1 {
            panic!("fcntl(F_SETFL) failed: {}", std::io::Error::last_os_error());
        }
    }

    let mut handles = FILE_HANDLES.lock().unwrap();
    let mut next_fd = NEXT_FD.lock().unwrap();
    let fd = *next_fd;
    *next_fd += 1;
    handles.insert(fd, file);
    fd
}

#[cfg(feature = "std")]
fn remove_file(fd: i32) -> Option<File> {
    FILE_HANDLES.lock().unwrap().remove(&fd)
}

#[cfg(feature = "std")]
pub(crate) fn raw_fd_from_handle(fd: i32) -> Option<i32> {
    if fd == 0 || fd == 1 || fd == 2 {
        return Some(fd);
    }
    let handles = FILE_HANDLES.lock().unwrap();
    handles.get(&fd).map(|f| f.as_raw_fd())
}

#[cfg(feature = "std")]
macro_rules! with_file_mut {
    ($fd:expr, $call:expr, $err_slot:expr, |$file:ident| $body:expr) => {{
        let mut handles = FILE_HANDLES.lock().unwrap();
        if let Some($file) = handles.get_mut(&$fd) { $body }
        else { write_error_to($call, $err_slot, "invalid file descriptor"); }
    }};
    ($fd:expr, $call:expr, $err_slot:expr, ret0, |$file:ident| $body:expr) => {{
        let mut handles = FILE_HANDLES.lock().unwrap();
        if let Some($file) = handles.get_mut(&$fd) { $body }
        else { $call.ret_i64(0, 0); write_error_to($call, $err_slot, "invalid file descriptor"); }
    }};
}

#[cfg(feature = "std")]
macro_rules! with_file {
    ($fd:expr, $call:expr, $err_slot:expr, |$file:ident| $body:expr) => {{
        let handles = FILE_HANDLES.lock().unwrap();
        if let Some($file) = handles.get(&$fd) { $body }
        else { write_error_to($call, $err_slot, "invalid file descriptor"); }
    }};
    ($fd:expr, $call:expr, $err_slot:expr, nil $n:expr, |$file:ident| $body:expr) => {{
        let handles = FILE_HANDLES.lock().unwrap();
        if let Some($file) = handles.get(&$fd) { $body }
        else { for i in 0..$n { $call.ret_nil(i as u16); } write_error_to($call, $err_slot, "invalid fd"); }
    }};
}

// Os sentinel errors - generated by vostd_errors! macro
vostd_errors! {
    "os" => {
        NotExist => "file does not exist",
        Exist => "file already exists",
        Permission => "permission denied",
        Invalid => "invalid argument",
        Timeout => "operation timed out",
        Closed => "file already closed",
        NotDir => "not a directory",
        IsDir => "is a directory",
    }
}

#[cfg(feature = "std")]
fn write_io_error(call: &mut ExternCallContext, ret_slot: u16, err: std::io::Error) {
    let kind = match err.kind() {
        std::io::ErrorKind::NotFound => Some(OsErrorKind::NotExist),
        std::io::ErrorKind::PermissionDenied => Some(OsErrorKind::Permission),
        std::io::ErrorKind::AlreadyExists => Some(OsErrorKind::Exist),
        std::io::ErrorKind::InvalidInput => Some(OsErrorKind::Invalid),
        std::io::ErrorKind::TimedOut => Some(OsErrorKind::Timeout),
        std::io::ErrorKind::NotADirectory => Some(OsErrorKind::NotDir),
        std::io::ErrorKind::IsADirectory => Some(OsErrorKind::IsDir),
        _ => None,
    };
    
    if let Some(k) = kind {
        let pair = os_sentinel_error(call, k);
        call.ret_interface_pair(ret_slot, pair);
    } else {
        write_error_to(call, ret_slot, &err.to_string());
    }
}

#[cfg(feature = "std")]
fn metadata_to_file_info(call: &mut ExternCallContext, name: &str, meta: &fs::Metadata) -> GcRef {
    let file_info = call.gc_alloc_struct("os.FileInfo");
    let name_ref = call.alloc_str(name);
    let size = meta.len() as i64;
    let mut mode = meta.permissions().mode();
    if meta.is_dir() { mode |= MODE_DIR; }
    if meta.file_type().is_symlink() { mode |= MODE_SYMLINK; }
    let mod_time = meta.mtime();
    let is_dir = if meta.is_dir() { 1u64 } else { 0u64 };
    
    unsafe {
        Gc::write_slot(file_info, 0, name_ref as u64);
        Gc::write_slot(file_info, 1, size as u64);
        Gc::write_slot(file_info, 2, mode as u64);
        Gc::write_slot(file_info, 3, mod_time as u64);
        Gc::write_slot(file_info, 4, is_dir);
    }
    file_info
}

#[cfg(feature = "std")]
fn handle_read_completion(call: &mut ExternCallContext, c: vo_runtime::io::Completion, ret_n: u16, ret_err: u16) {
    match c.result {
        Ok(CompletionData::Size(0)) => {
            call.ret_i64(ret_n, 0);
            let eof_pair = crate::io::io_sentinel_error(call, crate::io::IoErrorKind::EOF);
            call.ret_interface_pair(ret_err, eof_pair);
        }
        Ok(CompletionData::Size(n)) => {
            call.ret_i64(ret_n, n as i64);
            write_nil_error(call, ret_err);
        }
        Ok(_) => panic!("unexpected completion data for read"),
        Err(e) => {
            call.ret_i64(ret_n, 0);
            write_io_error(call, ret_err, e);
        }
    }
}

#[cfg(feature = "std")]
fn handle_write_completion(call: &mut ExternCallContext, c: vo_runtime::io::Completion, ret_n: u16, ret_err: u16) {
    match c.result {
        Ok(CompletionData::Size(n)) => {
            call.ret_i64(ret_n, n as i64);
            write_nil_error(call, ret_err);
        }
        Ok(_) => panic!("unexpected completion data for write"),
        Err(e) => {
            call.ret_i64(ret_n, 0);
            write_io_error(call, ret_err, e);
        }
    }
}

#[vostd_fn("os", "blocking_fileRead", std)]
fn os_file_read(call: &mut ExternCallContext) -> ExternResult {
    let resume_token = call.take_resume_io_token();
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    let buf_ref = call.arg_ref(slots::ARG_B);
    let buf_len = slice::len(buf_ref);
    let buf_ptr = slice::data_ptr(buf_ref);
    if buf_ptr.is_null() && buf_len > 0 {
        call.ret_i64(slots::RET_0, 0);
        write_error_to(call, slots::RET_1, "invalid buffer pointer");
        return ExternResult::Ok;
    }
    let buf = if buf_len == 0 { &mut [] as &mut [u8] } else { unsafe { std::slice::from_raw_parts_mut(buf_ptr, buf_len) } };
    
    if fd == 0 {
        match std::io::stdin().read(buf) {
            Ok(0) => {
                call.ret_i64(slots::RET_0, 0);
                let eof_pair = crate::io::io_sentinel_error(call, crate::io::IoErrorKind::EOF);
                call.ret_interface_pair(slots::RET_1, eof_pair);
            }
            Ok(n) => { call.ret_i64(slots::RET_0, n as i64); write_nil_error(call, slots::RET_1); }
            Err(e) => { call.ret_i64(slots::RET_0, 0); write_io_error(call, slots::RET_1, e); }
        }
        return ExternResult::Ok;
    }

    let raw_fd = {
        let handles = FILE_HANDLES.lock().unwrap();
        let file = match handles.get(&fd) {
            Some(f) => f,
            None => {
                call.ret_i64(slots::RET_0, 0);
                write_error_to(call, slots::RET_1, "invalid file descriptor");
                return ExternResult::Ok;
            }
        };
        file.as_raw_fd()
    };

    let token = match resume_token {
        Some(token) => token,
        None => {
            let token = call.io_mut().submit_read(raw_fd as IoHandle, buf_ptr, buf_len);
            match call.io_mut().try_take_completion(token) {
                Some(c) => {
                    handle_read_completion(call, c, slots::RET_0, slots::RET_1);
                    return ExternResult::Ok;
                }
                None => return ExternResult::WaitIo { token },
            }
        }
    };

    let c = call.io_mut().take_completion(token);
    handle_read_completion(call, c, slots::RET_0, slots::RET_1);
    ExternResult::Ok
}

#[vostd_fn("os", "blocking_fileWrite", std)]
fn os_file_write(call: &mut ExternCallContext) -> ExternResult {
    let resume_token = call.take_resume_io_token();
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    let buf_ref = call.arg_ref(slots::ARG_B);
    let buf_len = slice::len(buf_ref);
    let buf_ptr = slice::data_ptr(buf_ref);
    if buf_ptr.is_null() && buf_len > 0 {
        call.ret_i64(slots::RET_0, 0);
        write_error_to(call, slots::RET_1, "invalid buffer pointer");
        return ExternResult::Ok;
    }
    let buf = if buf_len == 0 { &[] } else { unsafe { std::slice::from_raw_parts(buf_ptr, buf_len) } };
    
    if fd == 1 || fd == 2 {
        let result = if fd == 1 { std::io::stdout().write(buf) } else { std::io::stderr().write(buf) };
        match result {
            Ok(n) => { call.ret_i64(slots::RET_0, n as i64); write_nil_error(call, slots::RET_1); }
            Err(e) => { call.ret_i64(slots::RET_0, 0); write_io_error(call, slots::RET_1, e); }
        }
        return ExternResult::Ok;
    }

    let raw_fd = {
        let handles = FILE_HANDLES.lock().unwrap();
        let file = match handles.get(&fd) {
            Some(f) => f,
            None => {
                call.ret_i64(slots::RET_0, 0);
                write_error_to(call, slots::RET_1, "invalid file descriptor");
                return ExternResult::Ok;
            }
        };
        file.as_raw_fd()
    };

    let token = match resume_token {
        Some(token) => token,
        None => {
            let token = call.io_mut().submit_write(raw_fd as IoHandle, buf_ptr, buf_len);
            match call.io_mut().try_take_completion(token) {
                Some(c) => {
                    handle_write_completion(call, c, slots::RET_0, slots::RET_1);
                    return ExternResult::Ok;
                }
                None => return ExternResult::WaitIo { token },
            }
        }
    };

    let c = call.io_mut().take_completion(token);
    handle_write_completion(call, c, slots::RET_0, slots::RET_1);
    ExternResult::Ok
}

#[vostd_fn("os", "blocking_fileReadAt", std)]
fn os_file_read_at(call: &mut ExternCallContext) -> ExternResult {
    let resume_token = call.take_resume_io_token();
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    let buf_ref = call.arg_ref(slots::ARG_B);
    let offset = call.arg_i64(slots::ARG_OFF);
    let buf_len = slice::len(buf_ref);
    let buf_ptr = slice::data_ptr(buf_ref);
    
    let raw_fd = {
        let handles = FILE_HANDLES.lock().unwrap();
        let file = match handles.get(&fd) {
            Some(f) => f,
            None => {
                call.ret_i64(slots::RET_0, 0);
                write_error_to(call, slots::RET_1, "invalid file descriptor");
                return ExternResult::Ok;
            }
        };
        file.as_raw_fd()
    };

    let token = match resume_token {
        Some(token) => token,
        None => {
            let token = call.io_mut().submit_read_at(raw_fd as IoHandle, buf_ptr, buf_len, offset);
            match call.io_mut().try_take_completion(token) {
                Some(c) => {
                    handle_read_completion(call, c, slots::RET_0, slots::RET_1);
                    return ExternResult::Ok;
                }
                None => return ExternResult::WaitIo { token },
            }
        }
    };

    let c = call.io_mut().take_completion(token);
    handle_read_completion(call, c, slots::RET_0, slots::RET_1);
    ExternResult::Ok
}

#[vostd_fn("os", "blocking_fileWriteAt", std)]
fn os_file_write_at(call: &mut ExternCallContext) -> ExternResult {
    let resume_token = call.take_resume_io_token();
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    let buf_ref = call.arg_ref(slots::ARG_B);
    let offset = call.arg_i64(slots::ARG_OFF);
    let buf_len = slice::len(buf_ref);
    let buf_ptr = slice::data_ptr(buf_ref);
    
    let raw_fd = {
        let handles = FILE_HANDLES.lock().unwrap();
        let file = match handles.get(&fd) {
            Some(f) => f,
            None => {
                call.ret_i64(slots::RET_0, 0);
                write_error_to(call, slots::RET_1, "invalid file descriptor");
                return ExternResult::Ok;
            }
        };
        file.as_raw_fd()
    };

    let token = match resume_token {
        Some(token) => token,
        None => {
            let token = call.io_mut().submit_write_at(raw_fd as IoHandle, buf_ptr, buf_len, offset);
            match call.io_mut().try_take_completion(token) {
                Some(c) => {
                    handle_write_completion(call, c, slots::RET_0, slots::RET_1);
                    return ExternResult::Ok;
                }
                None => return ExternResult::WaitIo { token },
            }
        }
    };

    let c = call.io_mut().take_completion(token);
    handle_write_completion(call, c, slots::RET_0, slots::RET_1);
    ExternResult::Ok
}

#[vostd_fn("os", "fileSeek", std)]
fn os_file_seek(call: &mut ExternCallContext) -> ExternResult {
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    let offset = call.arg_i64(slots::ARG_OFFSET);
    let whence = call.arg_i64(slots::ARG_WHENCE) as i32;
    
    with_file_mut!(fd, call, slots::RET_1, ret0, |file| {
        let seek_from = match whence {
            0 => Some(SeekFrom::Start(offset as u64)),
            1 => Some(SeekFrom::Current(offset)),
            2 => Some(SeekFrom::End(offset)),
            _ => { call.ret_i64(slots::RET_0, 0); write_error_to(call, slots::RET_1, "invalid whence"); None }
        };
        if let Some(sf) = seek_from {
            match file.seek(sf) {
                Ok(pos) => { call.ret_i64(slots::RET_0, pos as i64); write_nil_error(call, slots::RET_1); }
                Err(e) => { call.ret_i64(slots::RET_0, 0); write_io_error(call, slots::RET_1, e); }
            }
        }
    });
    ExternResult::Ok
}

#[vostd_fn("os", "fileClose", std)]
fn os_file_close(call: &mut ExternCallContext) -> ExternResult {
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    if fd <= 2 { write_nil_error(call, slots::RET_0); return ExternResult::Ok; }
    if remove_file(fd).is_some() { write_nil_error(call, slots::RET_0); }
    else { write_error_to(call, slots::RET_0, "invalid file descriptor"); }
    ExternResult::Ok
}

#[vostd_fn("os", "fileSync", std)]
fn os_file_sync(call: &mut ExternCallContext) -> ExternResult {
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    with_file!(fd, call, slots::RET_0, |file| {
        match file.sync_all() { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) }
    });
    ExternResult::Ok
}

#[vostd_fn("os", "fileStat", std)]
fn os_file_stat(call: &mut ExternCallContext) -> ExternResult {
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    with_file!(fd, call, 5, nil 5, |file| {
        match file.metadata() {
            Ok(meta) => {
                let file_info = metadata_to_file_info(call, "", &meta);
                for i in 0..5 { call.ret_u64(i as u16, unsafe { Gc::read_slot(file_info, i) }); }
                write_nil_error(call, 5);
            }
            Err(e) => { for i in 0..5 { call.ret_nil(i as u16); } write_io_error(call, 5, e); }
        }
    });
    ExternResult::Ok
}

#[vostd_fn("os", "fileTruncate", std)]
fn os_file_truncate(call: &mut ExternCallContext) -> ExternResult {
    let fd = call.arg_i64(slots::ARG_FD) as i32;
    let size = call.arg_i64(slots::ARG_SIZE) as u64;
    with_file!(fd, call, slots::RET_0, |file| {
        match file.set_len(size) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) }
    });
    ExternResult::Ok
}

// O_* flags - generated by vo_consts! macro
vo_consts! {
    internal "os" => {
        O_RDONLY => 0,
        O_WRONLY => 1,
        O_RDWR => 2,
        O_APPEND => 8,
        O_CREATE => 16,
        O_EXCL => 32,
        O_SYNC => 64,
        O_TRUNC => 128,
    }
}

#[vostd_fn("os", "openFile", std)]
fn os_open_file(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    let flag = call.arg_i64(slots::ARG_FLAG) as i32;
    let perm = call.arg_u64(slots::ARG_PERM) as u32;
    
    let mut opts = OpenOptions::new();
    let access = flag & 0x3;
    if access == O_RDONLY as i32 { opts.read(true); }
    else if access == O_WRONLY as i32 { opts.write(true); }
    else if access == O_RDWR as i32 { opts.read(true).write(true); }
    if flag & O_APPEND as i32 != 0 { opts.append(true); }
    if flag & O_CREATE as i32 != 0 { opts.create(true); }
    if flag & O_EXCL as i32 != 0 { opts.create_new(true); }
    if flag & O_TRUNC as i32 != 0 { opts.truncate(true); }
    
    match opts.open(name) {
        Ok(file) => {
            #[cfg(unix)]
            if flag & O_CREATE as i32 != 0 { let _ = file.set_permissions(fs::Permissions::from_mode(perm)); }
            let fd = register_file(file);
            call.ret_i64(slots::RET_0, fd as i64);
            write_nil_error(call, slots::RET_1);
        }
        Err(e) => { call.ret_i64(slots::RET_0, -1); write_io_error(call, slots::RET_1, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeMkdir", std)]
fn os_mkdir(call: &mut ExternCallContext) -> ExternResult {
    let path = call.arg_str(slots::ARG_PATH);
    let perm = call.arg_u64(slots::ARG_PERM) as u32;
    match fs::create_dir(path) {
        Ok(_) => { #[cfg(unix)] { let _ = fs::set_permissions(path, fs::Permissions::from_mode(perm)); } write_nil_error(call, slots::RET_0); }
        Err(e) => write_io_error(call, slots::RET_0, e),
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeMkdirAll", std)]
fn os_mkdir_all(call: &mut ExternCallContext) -> ExternResult {
    let path = call.arg_str(slots::ARG_PATH);
    let perm = call.arg_u64(slots::ARG_PERM) as u32;
    match fs::create_dir_all(path) {
        Ok(_) => { #[cfg(unix)] { let _ = fs::set_permissions(path, fs::Permissions::from_mode(perm)); } write_nil_error(call, slots::RET_0); }
        Err(e) => write_io_error(call, slots::RET_0, e),
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeRemove", std)]
fn os_remove(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    match fs::remove_file(name) {
        Ok(_) => write_nil_error(call, slots::RET_0),
        Err(_) => match fs::remove_dir(name) {
            Ok(_) => write_nil_error(call, slots::RET_0),
            Err(e) => write_io_error(call, slots::RET_0, e),
        }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeRemoveAll", std)]
fn os_remove_all(call: &mut ExternCallContext) -> ExternResult {
    let path = call.arg_str(slots::ARG_PATH);
    match fs::remove_dir_all(path) {
        Ok(_) => write_nil_error(call, slots::RET_0),
        Err(e) => match fs::remove_file(path) { Ok(_) => write_nil_error(call, slots::RET_0), Err(_) => write_io_error(call, slots::RET_0, e) }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeRename", std)]
fn os_rename(call: &mut ExternCallContext) -> ExternResult {
    let oldpath = call.arg_str(slots::ARG_OLDPATH);
    let newpath = call.arg_str(slots::ARG_NEWPATH);
    match fs::rename(oldpath, newpath) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeStat", std)]
fn os_stat(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    match fs::metadata(name) {
        Ok(meta) => {
            let basename = std::path::Path::new(name).file_name().map(|s| s.to_string_lossy().to_string()).unwrap_or_default();
            let file_info = metadata_to_file_info(call, &basename, &meta);
            for i in 0..5 { let val = unsafe { Gc::read_slot(file_info, i) }; call.ret_u64(i as u16, val); }
            write_nil_error(call, 5);
        }
        Err(e) => { for i in 0..5 { call.ret_nil(i as u16); } write_io_error(call, 5, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeLstat", std)]
fn os_lstat(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    match fs::symlink_metadata(name) {
        Ok(meta) => {
            let basename = std::path::Path::new(name).file_name().map(|s| s.to_string_lossy().to_string()).unwrap_or_default();
            let file_info = metadata_to_file_info(call, &basename, &meta);
            for i in 0..5 { let val = unsafe { Gc::read_slot(file_info, i) }; call.ret_u64(i as u16, val); }
            write_nil_error(call, 5);
        }
        Err(e) => { for i in 0..5 { call.ret_nil(i as u16); } write_io_error(call, 5, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeReadDir", std)]
fn os_read_dir(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    match fs::read_dir(name) {
        Ok(entries) => {
            let mut dir_entries: Vec<(String, bool, u32)> = Vec::new();
            for entry in entries.flatten() {
                let entry_name = entry.file_name().to_string_lossy().to_string();
                let is_dir = entry.file_type().map(|t| t.is_dir()).unwrap_or(false);
                let mode = entry.metadata().map(|m| { let mut mode = m.permissions().mode(); if m.is_dir() { mode |= MODE_DIR; } mode }).unwrap_or(0);
                dir_entries.push((entry_name, is_dir, mode));
            }
            let len = dir_entries.len();
            let elem_slots = 3;
            let elem_meta = vo_runtime::ValueMeta::new(0, ValueKind::Struct);
            let result = slice::create(call.gc(), elem_meta, elem_slots * SLOT_BYTES, len, len);
            for (i, (entry_name, is_dir, mode)) in dir_entries.iter().enumerate() {
                let name_ref = call.alloc_str(entry_name);
                let base = i * elem_slots;
                slice::set(result, base, name_ref as u64, SLOT_BYTES);
                slice::set(result, base + 1, if *is_dir { 1 } else { 0 }, SLOT_BYTES);
                slice::set(result, base + 2, *mode as u64, SLOT_BYTES);
            }
            call.ret_ref(slots::RET_0, result);
            write_nil_error(call, slots::RET_1);
        }
        Err(e) => { call.ret_nil(slots::RET_0); write_io_error(call, slots::RET_1, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeChmod", std)]
fn os_chmod(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    let mode = call.arg_u64(slots::ARG_MODE) as u32;
    #[cfg(unix)] { match fs::set_permissions(name, fs::Permissions::from_mode(mode)) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) } }
    #[cfg(not(unix))] { write_error_to(call, slots::RET_0, "chmod not supported"); }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeChown", std)]
fn os_chown(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    let uid = call.arg_i64(slots::ARG_UID) as u32;
    let gid = call.arg_i64(slots::ARG_GID) as u32;
    #[cfg(unix)] { use std::os::unix::fs::chown; match chown(name, Some(uid), Some(gid)) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) } }
    #[cfg(not(unix))] { write_error_to(call, slots::RET_0, "chown not supported"); }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeSymlink", std)]
fn os_symlink(call: &mut ExternCallContext) -> ExternResult {
    let oldname = call.arg_str(slots::ARG_OLDNAME);
    let newname = call.arg_str(slots::ARG_NEWNAME);
    #[cfg(unix)] { match symlink(oldname, newname) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) } }
    #[cfg(not(unix))] { write_error_to(call, slots::RET_0, "symlink not supported"); }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeReadlink", std)]
fn os_readlink(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    match fs::read_link(name) {
        Ok(path) => { call.ret_str(slots::RET_0, &path.to_string_lossy()); write_nil_error(call, slots::RET_1); }
        Err(e) => { call.ret_str(slots::RET_0, ""); write_io_error(call, slots::RET_1, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeLink", std)]
fn os_link(call: &mut ExternCallContext) -> ExternResult {
    let oldname = call.arg_str(slots::ARG_OLDNAME);
    let newname = call.arg_str(slots::ARG_NEWNAME);
    match fs::hard_link(oldname, newname) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeTruncate", std)]
fn os_truncate(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    let size = call.arg_i64(slots::ARG_SIZE) as u64;
    match File::options().write(true).open(name) {
        Ok(file) => match file.set_len(size) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) }
        Err(e) => write_io_error(call, slots::RET_0, e),
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeReadFile", std)]
fn os_read_file_native(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    match fs::read(name) {
        Ok(data) => { call.ret_bytes(slots::RET_0, &data); write_nil_error(call, slots::RET_1); }
        Err(e) => { call.ret_nil(slots::RET_0); write_io_error(call, slots::RET_1, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeWriteFile", std)]
fn os_write_file_native(call: &mut ExternCallContext) -> ExternResult {
    let name = call.arg_str(slots::ARG_NAME);
    let data = call.arg_bytes(slots::ARG_DATA);
    let perm = call.arg_u64(slots::ARG_PERM) as u32;
    match fs::write(name, data) {
        Ok(_) => { #[cfg(unix)] { let _ = fs::set_permissions(name, fs::Permissions::from_mode(perm)); } write_nil_error(call, slots::RET_0); }
        Err(e) => write_io_error(call, slots::RET_0, e),
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeGetenv", std)]
fn os_getenv(call: &mut ExternCallContext) -> ExternResult {
    let key = call.arg_str(slots::ARG_KEY);
    call.ret_str(slots::RET_0, &std::env::var(key).unwrap_or_default());
    ExternResult::Ok
}

#[vostd_fn("os", "nativeSetenv", std)]
fn os_setenv(call: &mut ExternCallContext) -> ExternResult {
    std::env::set_var(call.arg_str(slots::ARG_KEY), call.arg_str(slots::ARG_VALUE));
    write_nil_error(call, slots::RET_0);
    ExternResult::Ok
}

#[vostd_fn("os", "nativeUnsetenv", std)]
fn os_unsetenv(call: &mut ExternCallContext) -> ExternResult {
    std::env::remove_var(call.arg_str(slots::ARG_KEY));
    write_nil_error(call, slots::RET_0);
    ExternResult::Ok
}

#[vostd_fn("os", "nativeEnviron", std)]
fn os_environ(call: &mut ExternCallContext) -> ExternResult {
    let vars: Vec<String> = std::env::vars().map(|(k, v)| format!("{}={}", k, v)).collect();
    call.ret_string_slice(slots::RET_0, &vars);
    ExternResult::Ok
}

#[vostd_fn("os", "nativeLookupEnv", std)]
fn os_lookup_env(call: &mut ExternCallContext) -> ExternResult {
    let key = call.arg_str(slots::ARG_KEY);
    match std::env::var(key) {
        Ok(value) => { call.ret_str(slots::RET_0, &value); call.ret_bool(slots::RET_1, true); }
        Err(_) => { call.ret_str(slots::RET_0, ""); call.ret_bool(slots::RET_1, false); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeClearenv", std)]
fn os_clearenv(_call: &mut ExternCallContext) -> ExternResult {
    for (key, _) in std::env::vars() { std::env::remove_var(key); }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeExpandEnv", std)]
fn os_expand_env(call: &mut ExternCallContext) -> ExternResult {
    let s = call.arg_str(slots::ARG_S);
    let bytes = s.as_bytes();
    let len = bytes.len();
    let mut result = String::with_capacity(len);
    let mut i = 0;
    while i < len {
        if bytes[i] == b'$' && i + 1 < len {
            if bytes[i + 1] == b'{' {
                // ${VAR} form
                if let Some(end) = s[i + 2..].find('}') {
                    let name = &s[i + 2..i + 2 + end];
                    result.push_str(&std::env::var(name).unwrap_or_default());
                    i += 2 + end + 1;
                } else {
                    // Go: unterminated ${ → expand empty name (""), consume just the "${",
                    // rest of string is literal. getenv("") = ""
                    i += 2;
                }
            } else if bytes[i + 1].is_ascii_alphabetic() || bytes[i + 1] == b'_' {
                // $VAR form: consume alphanumeric + underscore
                let start = i + 1;
                let mut end = start;
                while end < len && (bytes[end].is_ascii_alphanumeric() || bytes[end] == b'_') {
                    end += 1;
                }
                let name = &s[start..end];
                result.push_str(&std::env::var(name).unwrap_or_default());
                i = end;
            } else {
                // Go: $x where x is not alpha/underscore/{: treat x as a single-char var name
                // e.g., $$ → getenv("$"), $1 → getenv("1"), $- → getenv("-")
                let name = &s[i + 1..i + 2];
                result.push_str(&std::env::var(name).unwrap_or_default());
                i += 2;
            }
        } else {
            result.push(bytes[i] as char);
            i += 1;
        }
    }
    call.ret_str(slots::RET_0, &result);
    ExternResult::Ok
}

#[vostd_fn("os", "nativeGetwd", std)]
fn os_getwd(call: &mut ExternCallContext) -> ExternResult {
    match std::env::current_dir() {
        Ok(path) => { call.ret_str(slots::RET_0, &path.to_string_lossy()); write_nil_error(call, slots::RET_1); }
        Err(e) => { call.ret_str(slots::RET_0, ""); write_io_error(call, slots::RET_1, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeChdir", std)]
fn os_chdir(call: &mut ExternCallContext) -> ExternResult {
    match std::env::set_current_dir(call.arg_str(slots::ARG_DIR)) { Ok(_) => write_nil_error(call, slots::RET_0), Err(e) => write_io_error(call, slots::RET_0, e) }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeUserHomeDir", std)]
fn os_user_home_dir(call: &mut ExternCallContext) -> ExternResult {
    match dirs::home_dir() {
        Some(path) => { call.ret_str(slots::RET_0, &path.to_string_lossy()); write_nil_error(call, slots::RET_1); }
        None => { call.ret_str(slots::RET_0, ""); write_error_to(call, slots::RET_1, "home directory not found"); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeUserCacheDir", std)]
fn os_user_cache_dir(call: &mut ExternCallContext) -> ExternResult {
    match dirs::cache_dir() {
        Some(path) => { call.ret_str(slots::RET_0, &path.to_string_lossy()); write_nil_error(call, slots::RET_1); }
        None => { call.ret_str(slots::RET_0, ""); write_error_to(call, slots::RET_1, "cache directory not found"); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeUserConfigDir", std)]
fn os_user_config_dir(call: &mut ExternCallContext) -> ExternResult {
    match dirs::config_dir() {
        Some(path) => { call.ret_str(slots::RET_0, &path.to_string_lossy()); write_nil_error(call, slots::RET_1); }
        None => { call.ret_str(slots::RET_0, ""); write_error_to(call, slots::RET_1, "config directory not found"); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeTempDir", std)]
fn os_temp_dir(call: &mut ExternCallContext) -> ExternResult {
    call.ret_str(slots::RET_0, &std::env::temp_dir().to_string_lossy());
    ExternResult::Ok
}

#[vostd_fn("os", "nativeGetpid", std)]
fn os_getpid(call: &mut ExternCallContext) -> ExternResult { call.ret_i64(slots::RET_0, std::process::id() as i64); ExternResult::Ok }
#[vostd_fn("os", "nativeGetppid", std)]
fn os_getppid(call: &mut ExternCallContext) -> ExternResult { #[cfg(unix)] { call.ret_i64(slots::RET_0, unsafe { libc::getppid() } as i64); } #[cfg(not(unix))] { call.ret_i64(slots::RET_0, 0); } ExternResult::Ok }
#[vostd_fn("os", "nativeGetuid", std)]
fn os_getuid(call: &mut ExternCallContext) -> ExternResult { #[cfg(unix)] { call.ret_i64(slots::RET_0, unsafe { libc::getuid() } as i64); } #[cfg(not(unix))] { call.ret_i64(slots::RET_0, 0); } ExternResult::Ok }
#[vostd_fn("os", "nativeGeteuid", std)]
fn os_geteuid(call: &mut ExternCallContext) -> ExternResult { #[cfg(unix)] { call.ret_i64(slots::RET_0, unsafe { libc::geteuid() } as i64); } #[cfg(not(unix))] { call.ret_i64(slots::RET_0, 0); } ExternResult::Ok }
#[vostd_fn("os", "nativeGetgid", std)]
fn os_getgid(call: &mut ExternCallContext) -> ExternResult { #[cfg(unix)] { call.ret_i64(slots::RET_0, unsafe { libc::getgid() } as i64); } #[cfg(not(unix))] { call.ret_i64(slots::RET_0, 0); } ExternResult::Ok }
#[vostd_fn("os", "nativeGetegid", std)]
fn os_getegid(call: &mut ExternCallContext) -> ExternResult { #[cfg(unix)] { call.ret_i64(slots::RET_0, unsafe { libc::getegid() } as i64); } #[cfg(not(unix))] { call.ret_i64(slots::RET_0, 0); } ExternResult::Ok }
#[vostd_fn("os", "nativeExit", std)]
fn os_exit(call: &mut ExternCallContext) -> ExternResult { std::process::exit(call.arg_i64(slots::ARG_CODE) as i32); }
#[vostd_fn("os", "nativeGetArgs", std)]
fn os_get_args(call: &mut ExternCallContext) -> ExternResult {
    let args: Vec<String> = call.program_args().to_vec();
    call.ret_string_slice(slots::RET_0, &args);
    ExternResult::Ok
}

#[vostd_fn("os", "nativeIsTerminal", std)]
fn os_is_terminal(call: &mut ExternCallContext) -> ExternResult {
    let fd = call.arg_i64(slots::ARG_FD) as i32;

    #[cfg(unix)]
    {
        if (0..=2).contains(&fd) {
            let ok = unsafe { libc::isatty(fd) == 1 };
            call.ret_bool(slots::RET_0, ok);
            return ExternResult::Ok;
        }

        let handles = FILE_HANDLES.lock().unwrap();
        if let Some(file) = handles.get(&fd) {
            let raw_fd = file.as_raw_fd();
            let ok = unsafe { libc::isatty(raw_fd) == 1 };
            call.ret_bool(slots::RET_0, ok);
        } else {
            call.ret_bool(slots::RET_0, false);
        }
        return ExternResult::Ok;
    }

    #[cfg(not(unix))]
    {
        call.ret_bool(slots::RET_0, false);
        ExternResult::Ok
    }
}

#[vostd_fn("os", "nativeHostname", std)]
fn os_hostname(call: &mut ExternCallContext) -> ExternResult {
    match hostname::get() {
        Ok(name) => { call.ret_str(slots::RET_0, &name.to_string_lossy()); write_nil_error(call, slots::RET_1); }
        Err(e) => { call.ret_str(slots::RET_0, ""); write_io_error(call, slots::RET_1, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeExecutable", std)]
fn os_executable(call: &mut ExternCallContext) -> ExternResult {
    match std::env::current_exe() {
        Ok(path) => { call.ret_str(slots::RET_0, &path.to_string_lossy()); write_nil_error(call, slots::RET_1); }
        Err(e) => { call.ret_str(slots::RET_0, ""); write_io_error(call, slots::RET_1, e); }
    }
    ExternResult::Ok
}

#[vostd_fn("os", "nativeCreateTemp", std)]
fn os_create_temp(call: &mut ExternCallContext) -> ExternResult {
    let dir = call.arg_str(slots::ARG_DIR);
    let pattern = call.arg_str(slots::ARG_PATTERN);
    let dir = if dir.is_empty() { std::env::temp_dir() } else { std::path::PathBuf::from(dir) };
    let (prefix, suffix) = if let Some(pos) = pattern.find('*') { (&pattern[..pos], &pattern[pos + 1..]) } else { (pattern, "") };
    for _ in 0..10000 {
        let name = format!("{}{:016x}{}", prefix, crate::rand::next_u64(), suffix);
        let path = dir.join(&name);
        match OpenOptions::new().write(true).create_new(true).open(&path) {
            Ok(file) => { let fd = register_file(file); call.ret_i64(slots::RET_0, fd as i64); call.ret_str(slots::RET_1, &path.to_string_lossy()); write_nil_error(call, slots::RET_2); return ExternResult::Ok; }
            Err(ref e) if e.kind() == std::io::ErrorKind::AlreadyExists => continue,
            Err(e) => { call.ret_i64(slots::RET_0, -1); call.ret_str(slots::RET_1, ""); write_io_error(call, slots::RET_2, e); return ExternResult::Ok; }
        }
    }
    call.ret_i64(slots::RET_0, -1); call.ret_str(slots::RET_1, ""); write_error_to(call, slots::RET_2, "failed to create temp file");
    ExternResult::Ok
}

#[vostd_fn("os", "nativeMkdirTemp", std)]
fn os_mkdir_temp(call: &mut ExternCallContext) -> ExternResult {
    let dir = call.arg_str(slots::ARG_DIR);
    let pattern = call.arg_str(slots::ARG_PATTERN);
    let dir = if dir.is_empty() { std::env::temp_dir() } else { std::path::PathBuf::from(dir) };
    let (prefix, suffix) = if let Some(pos) = pattern.find('*') { (&pattern[..pos], &pattern[pos + 1..]) } else { (pattern, "") };
    for _ in 0..10000 {
        let name = format!("{}{:016x}{}", prefix, crate::rand::next_u64(), suffix);
        let path = dir.join(&name);
        match fs::create_dir(&path) {
            Ok(_) => { call.ret_str(slots::RET_0, &path.to_string_lossy()); write_nil_error(call, slots::RET_1); return ExternResult::Ok; }
            Err(ref e) if e.kind() == std::io::ErrorKind::AlreadyExists => continue,
            Err(e) => { call.ret_str(slots::RET_0, ""); write_io_error(call, slots::RET_1, e); return ExternResult::Ok; }
        }
    }
    call.ret_str(slots::RET_0, ""); write_error_to(call, slots::RET_1, "failed to create temp dir");
    ExternResult::Ok
}

// ==================== Pipe ====================

#[cfg(feature = "std")]
#[vostd_fn("os", "nativePipe", std)]
fn os_native_pipe(call: &mut ExternCallContext) -> ExternResult {
    use std::os::unix::io::{FromRawFd, IntoRawFd};
    
    match nix::unistd::pipe() {
        Ok((read_fd, write_fd)) => {
            let rfd_raw = read_fd.into_raw_fd();
            let wfd_raw = write_fd.into_raw_fd();
            
            // Wrap raw fds into File and register in our handle system
            let r_file = unsafe { File::from_raw_fd(rfd_raw) };
            let w_file = unsafe { File::from_raw_fd(wfd_raw) };
            
            let rfd = register_file(r_file);
            let wfd = register_file(w_file);
            
            call.ret_i64(slots::RET_0, rfd as i64);
            call.ret_i64(slots::RET_1, wfd as i64);
            write_nil_error(call, slots::RET_2);
        }
        Err(e) => {
            call.ret_i64(slots::RET_0, -1);
            call.ret_i64(slots::RET_1, -1);
            write_error_to(call, slots::RET_2, &e.to_string());
        }
    }
    ExternResult::Ok
}

// ==================== Chtimes ====================

#[cfg(feature = "std")]
#[vostd_fn("os", "nativeChtimes", std)]
fn os_native_chtimes(call: &mut ExternCallContext) -> ExternResult {
    use std::time::{Duration, UNIX_EPOCH};
    use std::fs::FileTimes;
    
    let name = call.arg_str(slots::ARG_NAME);
    let atime = call.arg_i64(slots::ARG_ATIME);
    let mtime = call.arg_i64(slots::ARG_MTIME);
    
    let atime_systime = UNIX_EPOCH + Duration::from_secs(atime as u64);
    let mtime_systime = UNIX_EPOCH + Duration::from_secs(mtime as u64);
    
    let file = match File::options().write(true).open(&name) {
        Ok(f) => f,
        Err(e) => {
            write_io_error(call, slots::RET_0, e);
            return ExternResult::Ok;
        }
    };
    
    let times = FileTimes::new()
        .set_accessed(atime_systime)
        .set_modified(mtime_systime);
    
    match file.set_times(times) {
        Ok(_) => write_nil_error(call, slots::RET_0),
        Err(e) => write_io_error(call, slots::RET_0, e),
    }
    ExternResult::Ok
}

// ==================== FindProcess / Kill ====================

#[cfg(feature = "std")]
#[vostd_fn("os", "nativeFindProcess", std)]
fn os_native_find_process(call: &mut ExternCallContext) -> ExternResult {
    let pid = call.arg_i64(slots::ARG_PID) as i32;
    
    // Check if process exists by sending signal 0
    match nix::sys::signal::kill(nix::unistd::Pid::from_raw(pid), None) {
        Ok(_) => write_nil_error(call, slots::RET_0),
        Err(e) => write_error_to(call, slots::RET_0, &e.to_string()),
    }
    ExternResult::Ok
}

#[cfg(feature = "std")]
#[vostd_fn("os", "nativeKillProcess", std)]
fn os_native_kill_process(call: &mut ExternCallContext) -> ExternResult {
    let pid = call.arg_i64(slots::ARG_PID) as i32;
    let sig = call.arg_i64(slots::ARG_SIG) as i32;
    
    let signal = match nix::sys::signal::Signal::try_from(sig) {
        Ok(s) => Some(s),
        Err(_) => {
            write_error_to(call, slots::RET_0, "invalid signal");
            return ExternResult::Ok;
        }
    };
    
    match nix::sys::signal::kill(nix::unistd::Pid::from_raw(pid), signal) {
        Ok(_) => write_nil_error(call, slots::RET_0),
        Err(e) => write_error_to(call, slots::RET_0, &e.to_string()),
    }
    ExternResult::Ok
}

#[cfg(feature = "std")]
vo_runtime::stdlib_register!(os:
    getOsErrors, getOsConsts,
    blocking_fileRead, blocking_fileWrite, blocking_fileReadAt, blocking_fileWriteAt, fileSeek, fileClose, fileSync, fileStat, fileTruncate,
    openFile, nativeMkdir, nativeMkdirAll, nativeRemove, nativeRemoveAll, nativeRename,
    nativeStat, nativeLstat, nativeReadDir, nativeChmod, nativeChown, nativeSymlink, nativeReadlink,
    nativeLink, nativeTruncate, nativeReadFile, nativeWriteFile,
    nativeGetenv, nativeSetenv, nativeUnsetenv, nativeEnviron, nativeLookupEnv, nativeClearenv, nativeExpandEnv,
    nativeGetwd, nativeChdir, nativeUserHomeDir, nativeUserCacheDir, nativeUserConfigDir, nativeTempDir,
    nativeGetpid, nativeGetppid, nativeGetuid, nativeGeteuid, nativeGetgid, nativeGetegid,
    nativeExit, nativeGetArgs, nativeIsTerminal, nativeHostname, nativeExecutable, nativeCreateTemp, nativeMkdirTemp,
    nativePipe, nativeChtimes, nativeFindProcess, nativeKillProcess,
);

#[cfg(not(feature = "std"))]
pub fn register_externs(
    _registry: &mut vo_runtime::ffi::ExternRegistry,
    _externs: &[vo_runtime::bytecode::ExternDef],
) {
    // No-op: WASM platform externs are registered by vo-web-runtime-wasm
}

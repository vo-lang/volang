#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(not(feature = "std"))]
extern crate alloc;

extern crate self as vo_runtime;

pub mod slot;
pub mod output;

// Core runtime (no_std compatible)
pub mod gc;
pub mod gc_types;
pub mod objects;
pub mod itab;
pub mod pack;
pub mod island;
pub mod island_msg;

// FFI core types (no_std compatible), registration requires std
pub mod ffi;

// Builtins (no_std compatible, linkme registration is std-only)
pub mod builtins;

// Std-only modules
#[cfg(feature = "std")]
pub mod jit_api;
#[cfg(feature = "gc-debug")]
pub mod gc_debug;
#[cfg(feature = "std")]
pub mod ext_loader;
#[cfg(feature = "std")]
pub mod io;

// Re-exports from vo-common-core (no_std compatible)
pub use vo_common_core::types::{MetaId, SlotType, ValueKind, ValueMeta, ValueRttid, META_ID_MASK, INVALID_META_ID};
pub use vo_common_core::symbol::Symbol;
#[cfg(feature = "std")]
pub use vo_common_core::symbol::SymbolInterner;
pub use vo_common_core::runtime_type::{RuntimeType, ChanDir, StructField, InterfaceMethod};
pub use vo_common_core::instruction::{Instruction, Opcode};
pub use vo_common_core::bytecode::{Module, FunctionDef, Constant, ExternDef, GlobalDef, StructMeta, InterfaceMeta, Itab};
pub use vo_common_core::serialize;

// Re-export modules for downstream crates
pub use vo_common_core::bytecode;
pub use vo_common_core::instruction;
pub use vo_common_core::types as core_types;
pub use vo_common_core::symbol;

// Re-export InterfaceSlot from objects::interface (the canonical location)
pub use objects::interface::InterfaceSlot;

// Re-exports from ffi (core types always available)
pub use ffi::{
    ExternCallContext, ExternFn, ExternRegistry, ExternResult,
    SentinelErrorCache,
};
// Re-exports from ffi (std only - linkme registration and extension ABI types)
#[cfg(feature = "std")]
pub use ffi::{
    ExternEntry, ExtensionTable, ExternFnPtr,
    EXTERN_TABLE, lookup_extern,
};
#[cfg(feature = "std")]
pub use linkme::distributed_slice;

/// Macro to generate register_externs function from a list of function names.
/// 
/// Usage:
/// ```ignore
/// stdlib_register!(math: Floor, Ceil, Round, Modf, Frexp);
/// ```
/// 
/// This expands to a `register_externs` function that registers all listed functions.
/// Each function must have a corresponding `__STDLIB_<pkg>_<Name>` const generated by `vostd_extern`.
#[macro_export]
macro_rules! stdlib_register {
    ($pkg:ident : $($name:ident),* $(,)?) => {
        pub fn register_externs(
            registry: &mut $crate::ffi::ExternRegistry,
            externs: &[$crate::bytecode::ExternDef],
        ) {
            const TABLE: &[$crate::ffi::StdlibEntry] = &[
                $(paste::paste! { [<__STDLIB_ $pkg _ $name>] }),*
            ];
            
            for (id, def) in externs.iter().enumerate() {
                for entry in TABLE {
                    if def.name == entry.name() {
                        entry.register(registry, id as u32);
                        break;
                    }
                }
            }
        }
    };
}


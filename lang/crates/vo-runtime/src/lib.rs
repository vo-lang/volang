#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(not(feature = "std"))]
extern crate alloc;

pub mod slot;
pub mod output;

// Core runtime (no_std compatible)
pub mod gc;
pub mod gc_types;
pub mod objects;
pub mod itab;

// FFI core types (no_std compatible), registration requires std
pub mod ffi;

// Builtins and stdlib (no_std compatible, linkme registration is std-only)
pub mod builtins;
pub mod stdlib;

// Std-only modules
#[cfg(feature = "std")]
pub mod jit_api;
#[cfg(feature = "gc-debug")]
pub mod gc_debug;
#[cfg(feature = "std")]
pub mod ext_loader;

// Re-exports from vo-common-core (no_std compatible)
pub use vo_common_core::types::{MetaId, SlotType, ValueKind, ValueMeta, ValueRttid, META_ID_MASK, INVALID_META_ID};
pub use vo_common_core::symbol::Symbol;
#[cfg(feature = "std")]
pub use vo_common_core::symbol::SymbolInterner;
pub use vo_common_core::runtime_type::{RuntimeType, ChanDir, StructField, InterfaceMethod};
pub use vo_common_core::instruction::{Instruction, Opcode};
pub use vo_common_core::bytecode::{Module, FunctionDef, Constant, ExternDef, GlobalDef, StructMeta, InterfaceMeta, Itab};
pub use vo_common_core::serialize;

// Re-export modules for downstream crates
pub use vo_common_core::bytecode;
pub use vo_common_core::instruction;
pub use vo_common_core::types as core_types;
pub use vo_common_core::symbol;

// Re-export AnySlot directly from objects::interface (the canonical location)
pub use objects::interface::{AnySlot, InterfaceSlot, ErrorSlot};

// Re-exports from ffi (core types always available)
pub use ffi::{
    ExternCall, ExternCallContext, ExternFn, ExternFnWithContext, ExternRegistry, ExternResult,
    ClosureCallResult, ClosureCallFn,
};
// Re-exports from ffi (std only - linkme registration)
#[cfg(feature = "std")]
pub use ffi::{
    ExternEntry, ExternEntryWithContext, EXTERN_TABLE, EXTERN_TABLE_WITH_CONTEXT,
    lookup_extern, lookup_extern_with_context,
};
#[cfg(feature = "std")]
pub use linkme::distributed_slice;

/// Macro to generate register_externs function from a list of function names.
/// 
/// Usage:
/// ```ignore
/// stdlib_register!(math: Floor, Ceil, Round, Modf, Frexp);
/// ```
/// 
/// This expands to a `register_externs` function that registers all listed functions.
/// Each function must have a corresponding `__STDLIB_<pkg>_<Name>` const generated by `vostd_extern`.
#[macro_export]
macro_rules! stdlib_register {
    ($pkg:ident : $($name:ident),* $(,)?) => {
        pub fn register_externs(
            registry: &mut $crate::ffi::ExternRegistry,
            externs: &[$crate::bytecode::ExternDef],
        ) {
            const TABLE: &[$crate::ffi::StdlibEntry] = &[
                $(paste::paste! { [<__STDLIB_ $pkg _ $name>] }),*
            ];
            
            for (id, def) in externs.iter().enumerate() {
                for entry in TABLE {
                    if def.name == entry.name() {
                        entry.register(registry, id as u32);
                        break;
                    }
                }
            }
        }
    };
}

/// Register all stdlib extern functions into the registry.
/// This is used in no_std mode where linkme distributed_slice is not available.
pub fn register_all_stdlib_externs(registry: &mut ExternRegistry, externs: &[bytecode::ExternDef]) {
    stdlib::builtin::register_externs(registry, externs);
    stdlib::math::register_externs(registry, externs);
    stdlib::bits::register_externs(registry, externs);
    stdlib::bytes::register_externs(registry, externs);
    stdlib::strings::register_externs(registry, externs);
    stdlib::strconv::register_externs(registry, externs);
    stdlib::unicode::register_externs(registry, externs);
    stdlib::fmt::register_externs(registry, externs);
    stdlib::dynamic::register_externs(registry, externs);
    stdlib::os::register_externs(registry, externs);
    stdlib::regexp::register_externs(registry, externs);
    stdlib::json::register_externs(registry, externs);
}

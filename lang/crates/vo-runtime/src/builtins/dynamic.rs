//! Dynamic access runtime helpers for the ~> operator.
//!
//! Architecture:
//! - Layer 0: Common types (DynKey, DynErr)
//! - Layer 1: Protocol infrastructure
//! - Layer 2: Unified get_value/set_value
//! - Layer 3: Reflection handlers
//! - Layer 4: Call context and call/method
//! - Layer 5: Arg/return packing
//! - Layer 6: Extern entry points
//! - Layer 7: User API (dyn.GetAttr etc)

#[cfg(not(feature = "std"))]
use alloc::vec::Vec;
#[cfg(not(feature = "std"))]
use alloc::vec;
#[cfg(not(feature = "std"))]
use alloc::format;

use vo_common_core::types::ValueKind;
use vo_ffi_macro::vo_errors;

use crate::ffi::{ExternCallContext, ExternResult};
use crate::gc::{Gc, GcRef};
use crate::objects::{array, interface, map, slice, string as str_obj, closure};
use super::error_helper::create_error_with_cause;

// ============================================================================
// Layer 0: Error Types (generated by vo_errors! macro)
// ============================================================================

vo_errors! {
    internal "dyn" => {
        Unknown => "dynamic access: unknown error",
        NilBase => "dynamic access: base value is nil",
        BadField => "dynamic access: field does not exist",
        BadIndex => "dynamic access: invalid index type",
        OutOfBounds => "dynamic access: index out of bounds",
        BadCall => "dynamic access: cannot call value",
        SigMismatch => "dynamic access: signature mismatch",
        TypeMismatch => "dynamic access: type mismatch",
    }
}

// ============================================================================
// Layer 0: Common Types
// ============================================================================

/// Unified key for field or index access
enum DynKey<'a> {
    Field(&'a str),
    Index(u64, u64),
}

/// Internal error type (mirrors DynErrorKind but Copy)
#[derive(Clone, Copy)]
enum DynErr {
    NilBase,
    BadField,
    BadIndex,
    OutOfBounds,
    BadCall,
    SigMismatch,
    TypeMismatch,
}

impl From<DynErr> for DynErrorKind {
    fn from(e: DynErr) -> Self {
        match e {
            DynErr::NilBase => DynErrorKind::NilBase,
            DynErr::BadField => DynErrorKind::BadField,
            DynErr::BadIndex => DynErrorKind::BadIndex,
            DynErr::OutOfBounds => DynErrorKind::OutOfBounds,
            DynErr::BadCall => DynErrorKind::BadCall,
            DynErr::SigMismatch => DynErrorKind::SigMismatch,
            DynErr::TypeMismatch => DynErrorKind::TypeMismatch,
        }
    }
}

type DynResult<T> = Result<T, (DynErr, &'static str)>;

/// Error type that can carry either a DynErr or a CallClosure suspend request.
/// Used by helpers that need to call closures via the replay pattern.
enum DynOrSuspend {
    Dyn(DynErr, &'static str),
    Suspend(ExternResult),
}

impl From<(DynErr, &'static str)> for DynOrSuspend {
    fn from((e, m): (DynErr, &'static str)) -> Self {
        DynOrSuspend::Dyn(e, m)
    }
}

type DynSuspendResult<T> = Result<T, DynOrSuspend>;

/// Read `count` slots from a GcRef, returning zeros if the ref is null.
fn read_ref_slots(src_ref: GcRef, count: usize) -> Vec<u64> {
    (0..count).map(|i| {
        if src_ref.is_null() { 0 } else { unsafe { Gc::read_slot(src_ref, i) } }
    }).collect()
}

// ============================================================================
// Layer 1: Protocol Infrastructure
// ============================================================================

/// Check if type implements a protocol interface.
fn check_protocol(
    call: &ExternCallContext,
    rttid: u32,
    vk: ValueKind,
    iface_id: Option<u32>,
) -> Option<u32> {
    let iface_id = iface_id?;
    let is_named = call.get_named_type_id_from_rttid(rttid, true).is_some();
    if is_named && call.check_interface_satisfaction(rttid, vk, iface_id) {
        Some(iface_id)
    } else {
        None
    }
}

/// Get func_id for a protocol method via itab lookup.
fn protocol_func_id(
    call: &mut ExternCallContext,
    rttid: u32,
    vk: ValueKind,
    iface_id: u32,
    err: DynErr,
) -> DynResult<u32> {
    let named_type_id = call.get_named_type_id_from_rttid(rttid, true)
        .ok_or((err, "type has no methods"))?;
    
    let src_is_pointer = vk == ValueKind::Pointer;
    let itab_id = call.try_get_or_create_itab(named_type_id, iface_id, src_is_pointer)
        .ok_or((err, "type does not implement protocol"))?;
    
    let itab = call.get_itab(itab_id)
        .ok_or((err, "invalid itab"))?;
    
    itab.methods.first().copied()
        .ok_or((err, "protocol has no methods"))
}

/// Call a protocol method and check for error in return value.
/// Uses suspend/replay pattern: returns Suspend on first call, cached result on replay.
fn call_protocol<const N: usize>(
    call: &mut ExternCallContext,
    func_id: u32,
    args: &[u64],
    err: DynErr,
) -> DynSuspendResult<[u64; N]> {
    if call.is_replay_panicked() {
        return Err(DynOrSuspend::Dyn(DynErr::BadCall, "closure panicked"));
    }
    let ret_vec = match call.resume_closure_result() {
        Some(cached) => cached,
        None => {
            let closure_ref = closure::create(call.gc(), func_id, 0);
            return Err(DynOrSuspend::Suspend(ExternResult::CallClosure {
                closure_ref,
                args: args.to_vec(),
            }));
        }
    };
    
    // Unpack cached result into fixed-size array
    let mut ret = [0u64; N];
    let copy_len = ret_vec.len().min(N);
    ret[..copy_len].copy_from_slice(&ret_vec[..copy_len]);
    
    // Error is always in last 2 slots
    let err_start = N.saturating_sub(2);
    if ret[err_start] != 0 || ret.get(err_start + 1).copied().unwrap_or(0) != 0 {
        return Err(DynOrSuspend::Dyn(err, "protocol returned error"));
    }
    Ok(ret)
}

// ============================================================================
// Layer 2: Unified Get/Set
// ============================================================================

/// Get a value by field name or index. Returns (slot0, slot1) in interface format.
fn get_value(
    call: &mut ExternCallContext,
    base_slot0: u64,
    base_slot1: u64,
    key: DynKey,
) -> DynSuspendResult<(u64, u64)> {
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // Protocol check
    let protocol_id = match &key {
        DynKey::Field(_) => call.well_known().attr_object_iface_id,
        DynKey::Index(..) => call.well_known().index_object_iface_id,
    };
    if let Some(iface_id) = check_protocol(call, rttid, vk, protocol_id) {
        return get_via_protocol(call, base_slot1, rttid, vk, iface_id, &key);
    }
    
    // Reflection fallback
    get_reflection(call, base_slot0, base_slot1, rttid, vk, key).map_err(|e| e.into())
}

/// Set a value by field name or index.
fn set_value(
    call: &mut ExternCallContext,
    base_slot0: u64,
    base_slot1: u64,
    key: DynKey,
    val_slot0: u64,
    val_slot1: u64,
) -> DynSuspendResult<()> {
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // Protocol check
    let protocol_id = match &key {
        DynKey::Field(_) => call.well_known().set_attr_object_iface_id,
        DynKey::Index(..) => call.well_known().set_index_object_iface_id,
    };
    if let Some(iface_id) = check_protocol(call, rttid, vk, protocol_id) {
        return set_via_protocol(call, base_slot1, rttid, vk, iface_id, &key, val_slot0, val_slot1);
    }
    
    // Reflection fallback
    set_reflection(call, base_slot0, base_slot1, rttid, vk, key, val_slot0, val_slot1).map_err(|e| e.into())
}

/// Get via protocol (AttrObject or IndexObject)
fn get_via_protocol(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    iface_id: u32,
    key: &DynKey,
) -> DynSuspendResult<(u64, u64)> {
    let err = match key {
        DynKey::Field(_) => DynErr::BadField,
        DynKey::Index(..) => DynErr::BadIndex,
    };
    let func_id = protocol_func_id(call, rttid, vk, iface_id, err)?;
    
    let ret = match key {
        DynKey::Field(name) => {
            let name_ref = call.alloc_str(name);
            call_protocol::<4>(call, func_id, &[base_slot1, name_ref as u64], err)?
        }
        DynKey::Index(k0, k1) => {
            call_protocol::<4>(call, func_id, &[base_slot1, *k0, *k1], err)?
        }
    };
    Ok((ret[0], ret[1]))
}

/// Set via protocol (SetAttrObject or SetIndexObject)
fn set_via_protocol(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    iface_id: u32,
    key: &DynKey,
    val_slot0: u64,
    val_slot1: u64,
) -> DynSuspendResult<()> {
    let err = match key {
        DynKey::Field(_) => DynErr::BadField,
        DynKey::Index(..) => DynErr::BadIndex,
    };
    let func_id = protocol_func_id(call, rttid, vk, iface_id, err)?;
    
    match key {
        DynKey::Field(name) => {
            let name_ref = call.alloc_str(name);
            call_protocol::<2>(call, func_id, &[base_slot1, name_ref as u64, val_slot0, val_slot1], err)?;
        }
        DynKey::Index(k0, k1) => {
            call_protocol::<2>(call, func_id, &[base_slot1, *k0, *k1, val_slot0, val_slot1], err)?;
        }
    };
    Ok(())
}

// ============================================================================
// Layer 3: Reflection Handlers
// ============================================================================

/// Get via reflection (built-in type handling)
fn get_reflection(
    call: &mut ExternCallContext,
    _base_slot0: u64,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    key: DynKey,
) -> DynResult<(u64, u64)> {
    let base_ref = base_slot1 as GcRef;
    
    match (&key, vk) {
        // Field access on struct - try field first, then method
        (DynKey::Field(name), ValueKind::Struct) => {
            match get_struct_field(call, base_ref, rttid, name) {
                Ok(v) => Ok(v),
                Err(_) => get_method(call, rttid, base_slot1, name),
            }
        }
        // Field access on pointer - try field first, then method
        (DynKey::Field(name), ValueKind::Pointer) => {
            let elem_rttid = call.get_elem_value_rttid_from_base(rttid).rttid();
            match get_struct_field(call, base_ref, elem_rttid, name) {
                Ok(v) => Ok(v),
                Err(_) => get_method(call, rttid, base_slot1, name),
            }
        }
        // Field access on map (string key)
        (DynKey::Field(name), ValueKind::Map) => {
            get_map_string_key(call, base_ref, rttid, name)
        }
        // Index access on slice
        (DynKey::Index(k0, k1), ValueKind::Slice) => {
            get_slice_index(call, base_ref, rttid, *k0, *k1)
        }
        // Index access on array
        (DynKey::Index(k0, k1), ValueKind::Array) => {
            get_array_index(call, base_ref, rttid, *k0, *k1)
        }
        // Index access on string
        (DynKey::Index(k0, k1), ValueKind::String) => {
            get_string_index(call, base_ref, *k0, *k1)
        }
        // Index access on map
        (DynKey::Index(k0, k1), ValueKind::Map) => {
            get_map_index(call, base_ref, rttid, *k0, *k1)
        }
        // Field access on other types - try method lookup
        (DynKey::Field(name), _) => {
            if call.get_named_type_id_from_rttid(rttid, false).is_some() {
                get_method(call, rttid, base_slot1, name)
            } else {
                Err((DynErr::TypeMismatch, "cannot access field on this type"))
            }
        }
        _ => Err((DynErr::TypeMismatch, "type does not support this access")),
    }
}

/// Set via reflection
fn set_reflection(
    call: &mut ExternCallContext,
    _base_slot0: u64,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    key: DynKey,
    val_slot0: u64,
    val_slot1: u64,
) -> DynResult<()> {
    let base_ref = base_slot1 as GcRef;
    
    match (&key, vk) {
        // Field set on struct/pointer
        (DynKey::Field(name), ValueKind::Struct) => {
            set_struct_field(call, base_ref, rttid, name, val_slot0, val_slot1)
        }
        (DynKey::Field(name), ValueKind::Pointer) => {
            let elem_rttid = call.get_elem_value_rttid_from_base(rttid).rttid();
            set_struct_field(call, base_ref, elem_rttid, name, val_slot0, val_slot1)
        }
        // Field set on map (string key)
        (DynKey::Field(name), ValueKind::Map) => {
            set_map_string_key(call, base_ref, rttid, name, val_slot0, val_slot1)
        }
        // Index set on slice
        (DynKey::Index(k0, k1), ValueKind::Slice) => {
            set_slice_index(call, base_ref, rttid, *k0, *k1, val_slot0, val_slot1)
        }
        // Index set on map
        (DynKey::Index(k0, k1), ValueKind::Map) => {
            set_map_index(call, base_ref, rttid, *k0, *k1, val_slot0, val_slot1)
        }
        // Cannot set on array/string (value types)
        (DynKey::Index(..), ValueKind::Array) => {
            Err((DynErr::TypeMismatch, "cannot set index on value-type array"))
        }
        (DynKey::Index(..), ValueKind::String) => {
            Err((DynErr::TypeMismatch, "cannot set index on string"))
        }
        _ => Err((DynErr::TypeMismatch, "type does not support this assignment")),
    }
}

// ============================================================================
// Layer 3a: Struct Field Handlers
// ============================================================================

/// Recursive field lookup result
struct FieldInfo {
    offset: usize,
    slot_count: usize,
    rttid: u32,
    value_kind: ValueKind,
    ptr_derefs: Vec<PtrDeref>,
}

#[derive(Clone)]
struct PtrDeref {
    offset: u16,
}

fn lookup_field_recursive(
    call: &ExternCallContext,
    struct_meta_id: usize,
    field_name: &str,
    base_offset: usize,
    ptr_derefs: &mut Vec<PtrDeref>,
) -> Option<FieldInfo> {
    let meta = call.struct_meta(struct_meta_id)?;
    
    // Direct field match
    for field in &meta.fields {
        if field.name == field_name {
            let field_vk = field.type_info.value_kind();
            let field_rttid = field.type_info.rttid();
            return Some(FieldInfo {
                offset: base_offset + field.offset as usize,
                slot_count: field.slot_count as usize,
                rttid: field_rttid,
                value_kind: field_vk,
                ptr_derefs: ptr_derefs.clone(),
            });
        }
    }
    
    // Check embedded fields
    for field in &meta.fields {
        if !field.embedded { continue; }
        
        let embed_vk = field.type_info.value_kind();
        let embed_rttid = field.type_info.rttid();
        
        let (embed_struct_rttid, is_ptr) = if embed_vk == ValueKind::Pointer {
            (call.get_elem_value_rttid_from_base(embed_rttid).rttid(), true)
        } else {
            (embed_rttid, false)
        };
        
        let embed_struct_meta_id = call.get_struct_meta_id_from_rttid(embed_struct_rttid)?;
        
        let new_base = if is_ptr {
            ptr_derefs.push(PtrDeref { offset: (base_offset + field.offset as usize) as u16 });
            0
        } else {
            base_offset + field.offset as usize
        };
        
        if let Some(result) = lookup_field_recursive(call, embed_struct_meta_id as usize, field_name, new_base, ptr_derefs) {
            return Some(result);
        }
        
        if is_ptr { ptr_derefs.pop(); }
    }
    
    None
}

fn get_struct_field(
    call: &mut ExternCallContext,
    data_ref: GcRef,
    effective_rttid: u32,
    field_name: &str,
) -> DynResult<(u64, u64)> {
    let struct_meta_id = call.get_struct_meta_id_from_rttid(effective_rttid)
        .ok_or((DynErr::BadField, "not a struct type"))?;
    
    let mut ptr_derefs = Vec::new();
    let field = lookup_field_recursive(call, struct_meta_id as usize, field_name, 0, &mut ptr_derefs)
        .ok_or((DynErr::BadField, "field not found"))?;
    
    if data_ref.is_null() {
        return Err((DynErr::NilBase, "struct data is nil"));
    }
    
    // Follow pointer derefs
    let mut current_ref = data_ref;
    for deref in &field.ptr_derefs {
        let ptr_val = unsafe { Gc::read_slot(current_ref, deref.offset as usize) } as GcRef;
        if ptr_val.is_null() {
            return Err((DynErr::NilBase, "nil pointer in embedding path"));
        }
        current_ref = ptr_val;
    }
    
    // Read field data
    let raw_slots: Vec<u64> = (0..field.slot_count)
        .map(|i| unsafe { Gc::read_slot(current_ref, field.offset + i) })
        .collect();
    
    let boxed = call.box_to_interface(field.rttid, field.value_kind, &raw_slots);
    Ok((boxed.slot0, boxed.slot1))
}

fn set_struct_field(
    call: &mut ExternCallContext,
    data_ref: GcRef,
    effective_rttid: u32,
    field_name: &str,
    val_slot0: u64,
    val_slot1: u64,
) -> DynResult<()> {
    let struct_meta_id = call.get_struct_meta_id_from_rttid(effective_rttid)
        .ok_or((DynErr::BadField, "not a struct type"))?;
    
    let mut ptr_derefs = Vec::new();
    let field = lookup_field_recursive(call, struct_meta_id as usize, field_name, 0, &mut ptr_derefs)
        .ok_or((DynErr::BadField, "field not found"))?;
    
    if data_ref.is_null() {
        return Err((DynErr::NilBase, "struct data is nil"));
    }
    
    // Follow pointer derefs
    let mut current_ref = data_ref;
    for deref in &field.ptr_derefs {
        let ptr_val = unsafe { Gc::read_slot(current_ref, deref.offset as usize) } as GcRef;
        if ptr_val.is_null() {
            return Err((DynErr::NilBase, "embedded pointer is nil"));
        }
        current_ref = ptr_val;
    }
    
    // Unbox and write
    let field_vk = field.value_kind;
    let field_slots = field.slot_count;
    let val_vk = interface::unpack_value_kind(val_slot0);
    
    if field_vk == ValueKind::Interface {
        // Interface field: validate implementation and compute itab
        let iface_meta_id = call.get_interface_meta_id_from_rttid(field.rttid).unwrap_or(0);
        let (stored_slot0, stored_slot1) = prepare_interface_value(call, val_slot0, val_slot1, iface_meta_id)?;
        unsafe {
            Gc::write_slot(current_ref, field.offset, stored_slot0);
            Gc::write_slot(current_ref, field.offset + 1, stored_slot1);
        }
    } else if interface::is_nil(val_slot0) {
        // Cannot write nil to non-interface field (except reference types)
        let is_nillable = matches!(field_vk, 
            ValueKind::Pointer | ValueKind::Slice | ValueKind::Map | 
            ValueKind::Closure | ValueKind::String
        );
        if !is_nillable {
            return Err((DynErr::TypeMismatch, "cannot write nil to non-nillable field"));
        }
        // Write zero value for nillable types
        unsafe { Gc::write_slot(current_ref, field.offset, 0); }
    } else if field_vk != val_vk {
        // Type check for non-interface fields
        return Err((DynErr::TypeMismatch, "field type mismatch"));
    } else if field_vk == ValueKind::Struct || field_vk == ValueKind::Array {
        // Struct/Array: val_slot1 is a GcRef to boxed data
        let vals = read_ref_slots(val_slot1 as GcRef, field_slots);
        for (i, &val) in vals.iter().enumerate() {
            unsafe { Gc::write_slot(current_ref, field.offset + i, val); }
        }
    } else {
        // Primitive types: val_slot1 is the direct value
        unsafe { Gc::write_slot(current_ref, field.offset, val_slot1); }
    }
    
    Ok(())
}

// ============================================================================
// Layer 3b: Map Handlers
// ============================================================================

fn get_map_string_key(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    name: &str,
) -> DynResult<(u64, u64)> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot access field on nil map"));
    }
    
    let map_key_vk = map::key_kind(base_ref);
    if map_key_vk != ValueKind::String && map_key_vk != ValueKind::Interface {
        return Err((DynErr::BadField, "map key type is not string"));
    }
    
    let key_ref = call.alloc_str(name);
    let val_meta = map::val_meta(base_ref);
    let val_vk = val_meta.value_kind();
    let val_rttid = call.get_elem_value_rttid_from_base(rttid);
    
    let found = if map_key_vk == ValueKind::Interface {
        let key_slot0 = interface::pack_slot0(0, ValueKind::String as u32, ValueKind::String);
        map::get(base_ref, &[key_slot0, key_ref as u64], Some(call.module()))
    } else {
        map::get(base_ref, &[key_ref as u64], Some(call.module()))
    };
    
    // Dynamic access: missing key returns error (unlike Go's zero value)
    let val_slice = match found {
        Some(v) => v,
        None => return Err((DynErr::BadField, "map key not found")),
    };
    
    if val_vk == ValueKind::Interface {
        return Ok((val_slice[0], val_slice[1]));
    }
    
    let raw_slots: Vec<u64> = val_slice.to_vec();
    
    let boxed = call.box_to_interface(val_rttid.rttid(), val_vk, &raw_slots);
    Ok((boxed.slot0, boxed.slot1))
}

fn set_map_string_key(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    name: &str,
    val_slot0: u64,
    val_slot1: u64,
) -> DynResult<()> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot set field on nil map"));
    }
    
    let map_key_vk = map::key_kind(base_ref);
    if map_key_vk != ValueKind::String && map_key_vk != ValueKind::Interface {
        return Err((DynErr::BadField, "map key type is not string"));
    }
    
    let key_ref = call.alloc_str(name);
    let val_meta = map::val_meta(base_ref);
    let val_vk = val_meta.value_kind();
    let val_rttid = call.get_elem_value_rttid_from_base(rttid);
    let val_slots = call.get_type_slot_count(val_rttid.rttid()) as usize;
    
    // Unbox value
    let val_data: Vec<u64> = if val_vk == ValueKind::Interface {
        vec![val_slot0, val_slot1]
    } else if val_slots == 1 {
        vec![val_slot1]
    } else {
        read_ref_slots(val_slot1 as GcRef, val_slots)
    };
    
    // For map[any]T, wrap key as interface
    if map_key_vk == ValueKind::Interface {
        let key_slot0 = interface::pack_slot0(0, ValueKind::String as u32, ValueKind::String);
        map::set(base_ref, &[key_slot0, key_ref as u64], &val_data, Some(call.module()));
    } else {
        map::set(base_ref, &[key_ref as u64], &val_data, Some(call.module()));
    }
    Ok(())
}

fn get_map_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
) -> DynResult<(u64, u64)> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot index nil map"));
    }
    
    let key_vk = interface::unpack_value_kind(key_slot0);
    let map_key_vk = map::key_kind(base_ref);
    let map_key_slots = map::key_slots(base_ref) as usize;
    
    // Key type validation
    let key_compatible = match (map_key_vk, key_vk) {
        (a, b) if a == b => true,
        (ValueKind::Interface, _) => true,
        (ValueKind::Int, k) | (k, ValueKind::Int) => is_integer_value_kind(k),
        _ => false,
    };
    if !key_compatible {
        return Err((DynErr::BadIndex, "map key type mismatch"));
    }
    
    // Prepare key data
    let key_data: Vec<u64> = if map_key_vk == ValueKind::Interface {
        vec![key_slot0, key_slot1]
    } else if map_key_slots == 1 {
        vec![key_slot1]
    } else {
        read_ref_slots(key_slot1 as GcRef, map_key_slots)
    };
    
    let val_meta = map::val_meta(base_ref);
    let val_vk = val_meta.value_kind();
    let val_rttid = call.get_elem_value_rttid_from_base(rttid);
    
    let found = map::get(base_ref, &key_data, Some(call.module()));
    
    // Dynamic access: missing key returns error (unlike Go's zero value)
    let val_slice = match found {
        Some(v) => v,
        None => return Err((DynErr::BadField, "map key not found")),
    };
    
    if val_vk == ValueKind::Interface {
        return Ok((val_slice[0], val_slice[1]));
    }
    
    let raw_slots: Vec<u64> = val_slice.to_vec();
    
    let boxed = call.box_to_interface(val_rttid.rttid(), val_vk, &raw_slots);
    Ok((boxed.slot0, boxed.slot1))
}

fn set_map_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
    val_slot0: u64,
    val_slot1: u64,
) -> DynResult<()> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot set index on nil map"));
    }
    
    let key_vk = interface::unpack_value_kind(key_slot0);
    let map_key_vk = map::key_kind(base_ref);
    let map_key_slots = map::key_slots(base_ref) as usize;
    
    // Key type validation
    let key_compatible = match (map_key_vk, key_vk) {
        (a, b) if a == b => true,
        (ValueKind::Interface, _) => true,
        (ValueKind::Int, k) | (k, ValueKind::Int) => is_integer_value_kind(k),
        _ => false,
    };
    if !key_compatible {
        return Err((DynErr::BadIndex, "map key type mismatch"));
    }
    
    // Prepare key data
    let key_data: Vec<u64> = if map_key_vk == ValueKind::Interface {
        vec![key_slot0, key_slot1]
    } else if map_key_slots == 1 {
        vec![key_slot1]
    } else {
        read_ref_slots(key_slot1 as GcRef, map_key_slots)
    };
    
    let val_meta = map::val_meta(base_ref);
    let val_vk = val_meta.value_kind();
    let val_rttid = call.get_elem_value_rttid_from_base(rttid);
    let val_slots = call.get_type_slot_count(val_rttid.rttid()) as usize;
    
    // Value type validation (for non-interface map values)
    let src_val_vk = interface::unpack_value_kind(val_slot0);
    if val_vk != ValueKind::Interface && !interface::is_nil(val_slot0) && val_vk != src_val_vk {
        return Err((DynErr::TypeMismatch, "map value type mismatch"));
    }
    
    // Unbox value
    let val_data: Vec<u64> = if val_vk == ValueKind::Interface {
        vec![val_slot0, val_slot1]
    } else if val_vk == ValueKind::Struct || val_vk == ValueKind::Array {
        read_ref_slots(val_slot1 as GcRef, val_slots)
    } else {
        vec![val_slot1]
    };
    
    map::set(base_ref, &key_data, &val_data, Some(call.module()));
    Ok(())
}

// ============================================================================
// Layer 3c: Slice/Array/String Index Handlers
// ============================================================================

fn is_integer_value_kind(vk: ValueKind) -> bool {
    matches!(vk, 
        ValueKind::Int | ValueKind::Int8 | ValueKind::Int16 | ValueKind::Int32 | ValueKind::Int64 |
        ValueKind::Uint | ValueKind::Uint8 | ValueKind::Uint16 | ValueKind::Uint32 | ValueKind::Uint64
    )
}

/// Validates that the value implements the interface and computes the itab.
fn prepare_interface_value(
    call: &mut ExternCallContext,
    val_slot0: u64,
    val_slot1: u64,
    target_iface_meta_id: u32,
) -> DynResult<(u64, u64)> {
    let val_vk = interface::unpack_value_kind(val_slot0);
    let val_rttid = interface::unpack_rttid(val_slot0);
    
    // For empty interface (any), meta_id is 0 - no itab needed
    if target_iface_meta_id == 0 {
        return Ok((val_slot0, val_slot1));
    }
    
    let named_type_id = call.get_named_type_id_from_rttid(val_rttid, true)
        .ok_or((DynErr::TypeMismatch, "value does not have methods"))?;
    let src_is_pointer = val_vk == ValueKind::Pointer;
    let itab_id = call.try_get_or_create_itab(named_type_id, target_iface_meta_id, src_is_pointer)
        .ok_or((DynErr::TypeMismatch, "value does not implement interface"))?;
    let stored_slot0 = interface::pack_slot0(itab_id, val_rttid, val_vk);
    Ok((stored_slot0, val_slot1))
}

enum IndexError { BadType, OutOfBounds }

fn check_int_index(key_slot0: u64, key_slot1: u64, len: usize) -> Result<usize, IndexError> {
    let key_vk = interface::unpack_value_kind(key_slot0);
    
    let idx: i64 = match key_vk {
        ValueKind::Int | ValueKind::Int8 | ValueKind::Int16 | ValueKind::Int32 | ValueKind::Int64 => {
            key_slot1 as i64
        }
        ValueKind::Uint | ValueKind::Uint8 | ValueKind::Uint16 | ValueKind::Uint32 | ValueKind::Uint64 => {
            key_slot1 as i64
        }
        _ => return Err(IndexError::BadType),
    };
    
    if idx < 0 || idx as usize >= len {
        return Err(IndexError::OutOfBounds);
    }
    Ok(idx as usize)
}

fn get_slice_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
) -> DynResult<(u64, u64)> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot index nil slice"));
    }
    
    let len = slice::len(base_ref);
    let idx = check_int_index(key_slot0, key_slot1, len)
        .map_err(|e| match e {
            IndexError::BadType => (DynErr::BadIndex, "index must be integer"),
            IndexError::OutOfBounds => (DynErr::OutOfBounds, "slice index out of bounds"),
        })?;
    
    let elem_meta = slice::elem_meta(base_ref);
    let elem_vk = elem_meta.value_kind();
    let elem_rttid = call.get_elem_value_rttid_from_base(rttid);
    let elem_slots = call.get_type_slot_count(elem_rttid.rttid()) as usize;
    
    let raw_slots: Vec<u64> = (0..elem_slots)
        .map(|i| slice::get(base_ref, idx * elem_slots + i, 8))
        .collect();
    
    let boxed = call.box_to_interface(elem_rttid.rttid(), elem_vk, &raw_slots);
    Ok((boxed.slot0, boxed.slot1))
}

fn set_slice_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
    val_slot0: u64,
    val_slot1: u64,
) -> DynResult<()> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot set index on nil slice"));
    }
    
    let len = slice::len(base_ref);
    let idx = check_int_index(key_slot0, key_slot1, len)
        .map_err(|e| match e {
            IndexError::BadType => (DynErr::BadIndex, "index must be integer"),
            IndexError::OutOfBounds => (DynErr::OutOfBounds, "slice index out of bounds"),
        })?;
    
    let elem_meta = slice::elem_meta(base_ref);
    let elem_vk = elem_meta.value_kind();
    let elem_rttid = call.get_elem_value_rttid_from_base(rttid);
    let elem_slots = call.get_type_slot_count(elem_rttid.rttid()) as usize;
    let val_vk = interface::unpack_value_kind(val_slot0);
    
    // Type check for non-interface elements
    if elem_vk != ValueKind::Interface && elem_vk != val_vk && !interface::is_nil(val_slot0) {
        return Err((DynErr::TypeMismatch, "slice element type mismatch"));
    }
    
    // Unbox and write
    if elem_vk == ValueKind::Interface {
        slice::set(base_ref, idx * elem_slots, val_slot0, 8);
        slice::set(base_ref, idx * elem_slots + 1, val_slot1, 8);
    } else if elem_vk == ValueKind::Struct || elem_vk == ValueKind::Array {
        let vals = read_ref_slots(val_slot1 as GcRef, elem_slots);
        for (i, &slot) in vals.iter().enumerate() {
            slice::set(base_ref, idx * elem_slots + i, slot, 8);
        }
    } else {
        slice::set(base_ref, idx * elem_slots, val_slot1, 8);
    }
    
    Ok(())
}

fn get_array_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
) -> DynResult<(u64, u64)> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot index nil array"));
    }
    
    let len = array::len(base_ref);
    let idx = check_int_index(key_slot0, key_slot1, len)
        .map_err(|e| match e {
            IndexError::BadType => (DynErr::BadIndex, "index must be integer"),
            IndexError::OutOfBounds => (DynErr::OutOfBounds, "array index out of bounds"),
        })?;
    
    let elem_meta = array::elem_meta(base_ref);
    let elem_vk = elem_meta.value_kind();
    let elem_bytes = array::elem_bytes(base_ref);
    let elem_rttid = call.get_elem_value_rttid_from_base(rttid);
    let elem_slots = call.get_type_slot_count(elem_rttid.rttid()) as usize;
    
    let mut raw_slots = vec![0u64; elem_slots];
    array::get_n(base_ref, idx, &mut raw_slots, elem_bytes);
    
    let boxed = call.box_to_interface(elem_rttid.rttid(), elem_vk, &raw_slots);
    Ok((boxed.slot0, boxed.slot1))
}

fn get_string_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    key_slot0: u64,
    key_slot1: u64,
) -> DynResult<(u64, u64)> {
    let s = str_obj::as_str(base_ref);
    let bytes = s.as_bytes();
    
    let idx = check_int_index(key_slot0, key_slot1, bytes.len())
        .map_err(|e| match e {
            IndexError::BadType => (DynErr::BadIndex, "index must be integer"),
            IndexError::OutOfBounds => (DynErr::OutOfBounds, "string index out of bounds"),
        })?;
    
    let boxed = call.box_to_interface(ValueKind::Uint8 as u32, ValueKind::Uint8, &[bytes[idx] as u64]);
    Ok((boxed.slot0, boxed.slot1))
}

// ============================================================================
// Layer 3d: Method Lookup
// ============================================================================

fn get_method(
    call: &mut ExternCallContext,
    rttid: u32,
    receiver_slot1: u64,
    method_name: &str,
) -> DynResult<(u64, u64)> {
    let (func_id, _is_pointer_receiver, signature_rttid) = call.lookup_method(rttid, method_name)
        .ok_or((DynErr::BadField, "method not found"))?;
    
    let closure_ref = closure::create(call.gc(), func_id, 1);
    closure::set_capture(closure_ref, 0, receiver_slot1);
    
    let slot0 = interface::pack_slot0(0, signature_rttid, ValueKind::Closure);
    Ok((slot0, closure_ref as u64))
}

// ============================================================================
// Layer 4: Call Helpers
// ============================================================================

fn call_return_error(
    call: &mut ExternCallContext,
    error_offset: u16,
    err: DynErr,
    msg: &str,
) -> ExternResult {
    for i in 0..error_offset {
        call.ret_u64(i, 0);
    }
    let (cause0, cause1) = dyn_sentinel_error(call, err.into());
    let pair = create_error_with_cause(call, msg, cause0, cause1);
    call.ret_interface_pair(error_offset, pair);
    ExternResult::Ok
}

fn call_return_success(call: &mut ExternCallContext, error_offset: u16) -> ExternResult {
    call.ret_nil(error_offset);
    call.ret_nil(error_offset + 1);
    ExternResult::Ok
}

fn get_expected_meta(call: &ExternCallContext, metas_start: u16, is_any_start: u16, i: usize) -> (u32, ValueKind, bool) {
    let meta_raw = call.arg_u64(metas_start + i as u16) as u32;
    let is_any = call.arg_u64(is_any_start + i as u16) != 0;
    let rttid = meta_raw >> 8;
    let vk = ValueKind::from_u8((meta_raw & 0xFF) as u8);
    (rttid, vk, is_any)
}

fn compute_error_offset(
    call: &ExternCallContext,
    ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
) -> u16 {
    let mut offset: u16 = 0;
    for i in 0..ret_count {
        let meta_raw = call.arg_u64(metas_start + i as u16) as u32;
        let is_any = call.arg_u64(is_any_start + i as u16) != 0;
        let rttid = meta_raw >> 8;
        let vk = ValueKind::from_u8((meta_raw & 0xFF) as u8);
        let width = match vk {
            ValueKind::Interface => 2,
            ValueKind::Struct | ValueKind::Array => call.get_type_slot_count(rttid) as usize,
            _ => 1,
        };
        offset += output_slot_count(is_any, vk, width);
    }
    offset
}

fn output_slot_count(is_any: bool, vk: ValueKind, width: usize) -> u16 {
    if is_any {
        2
    } else if (vk == ValueKind::Struct || vk == ValueKind::Array) && width > 2 {
        2
    } else {
        width.min(2) as u16
    }
}

// ============================================================================
// Layer 4: Call/Method Implementation
// ============================================================================

fn do_call(
    call: &mut ExternCallContext,
    closure_ref: GcRef,
    sig_rttid: u32,
    args_slice_ref: GcRef,
    ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
    error_offset: u16,
) -> ExternResult {
    if call.is_replay_panicked() {
        return call_return_error(call, error_offset, DynErr::BadCall, "closure panicked");
    }
    if closure_ref.is_null() {
        return call_return_error(call, error_offset, DynErr::BadCall, "closure is null");
    }
    
    // Get function signature
    let (params, ret_value_rttids, is_variadic) = match call.get_func_signature(sig_rttid) {
        Some((p, r, v)) => (p.clone(), r.clone(), v),
        None => return call_return_error(call, error_offset, DynErr::BadCall, "invalid closure signature"),
    };
    
    // Check return count
    let actual_ret_count = ret_value_rttids.len();
    if ret_count != actual_ret_count {
        let msg = format!(
            "return count mismatch: expected {} return value(s), function returns {} (hint: adjust LHS variable count to match function signature)",
            ret_count, actual_ret_count
        );
        return call_return_error(call, error_offset, DynErr::SigMismatch, &msg);
    }
    
    // Check parameter count
    let arg_count = if args_slice_ref.is_null() { 0 } else { slice::len(args_slice_ref) };
    let expected_params = if is_variadic && !params.is_empty() { params.len() - 1 } else { params.len() };
    
    if !is_variadic && arg_count != expected_params {
        let msg = format!("parameter count mismatch: expected {}, got {}", expected_params, arg_count);
        return call_return_error(call, error_offset, DynErr::SigMismatch, &msg);
    }
    if is_variadic && arg_count < expected_params {
        let msg = format!("parameter count mismatch: expected at least {}, got {}", expected_params, arg_count);
        return call_return_error(call, error_offset, DynErr::SigMismatch, &msg);
    }
    
    // Unpack args
    let args = match unpack_args(call, args_slice_ref, &params, is_variadic) {
        Ok(a) => a,
        Err(_) => return call_return_error(call, error_offset, DynErr::SigMismatch, "argument type mismatch"),
    };
    
    // Call closure via suspend/replay
    let ret_buffer = match call.resume_closure_result() {
        Some(cached) => cached,
        None => {
            return ExternResult::CallClosure {
                closure_ref,
                args,
            };
        }
    };
    
    // Pack returns
    pack_returns(call, &ret_buffer, &ret_value_rttids, ret_count, metas_start, is_any_start, error_offset);
    call_return_success(call, error_offset)
}

fn do_method(
    call: &mut ExternCallContext,
    base_slot0: u64,
    base_slot1: u64,
    method_name: &str,
    args_slice_ref: GcRef,
    ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
    error_offset: u16,
) -> ExternResult {
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // Try protocol first
    let closure = if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().attr_object_iface_id) {
        match get_method_via_protocol(call, base_slot1, rttid, vk, iface_id, method_name) {
            Ok(c) => Some(c),
            Err(DynOrSuspend::Dyn(e, m)) => return call_return_error(call, error_offset, e, m),
            Err(DynOrSuspend::Suspend(r)) => return r,
        }
    } else {
        None
    };
    
    // Fallback to reflection
    let (closure_slot0, closure_slot1) = if let Some(c) = closure {
        c
    } else {
        match get_method(call, rttid, base_slot1, method_name) {
            Ok(c) => c,
            Err((e, m)) => return call_return_error(call, error_offset, e, m),
        }
    };
    
    // Verify it's a closure
    let closure_vk = interface::unpack_value_kind(closure_slot0);
    if closure_vk != ValueKind::Closure {
        return call_return_error(call, error_offset, DynErr::BadCall, &format!("{} is not a method", method_name));
    }
    
    let closure_rttid = interface::unpack_rttid(closure_slot0);
    let closure_ref = closure_slot1 as GcRef;
    
    do_call(call, closure_ref, closure_rttid, args_slice_ref, ret_count, metas_start, is_any_start, error_offset)
}

fn get_method_via_protocol(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    iface_id: u32,
    method_name: &str,
) -> DynSuspendResult<(u64, u64)> {
    let func_id = protocol_func_id(call, rttid, vk, iface_id, DynErr::BadField)?;
    let name_ref = call.alloc_str(method_name);
    let ret = call_protocol::<4>(call, func_id, &[base_slot1, name_ref as u64], DynErr::BadField)?;
    Ok((ret[0], ret[1]))
}

// ============================================================================
// Layer 5: Arg/Return Packing
// ============================================================================

fn unpack_args(
    call: &mut ExternCallContext,
    args_slice_ref: GcRef,
    params: &[vo_common_core::types::ValueRttid],
    is_variadic: bool,
) -> Result<Vec<u64>, ()> {
    use vo_common_core::types::ValueMeta;
    
    let mut args = Vec::new();
    
    if args_slice_ref.is_null() {
        return Ok(args);
    }
    
    let arg_count = slice::len(args_slice_ref);
    let elem_bytes = array::elem_bytes(slice::array_ref(args_slice_ref));
    let non_variadic_count = if is_variadic && !params.is_empty() { params.len() - 1 } else { params.len() };
    
    // Unpack non-variadic args
    for i in 0..non_variadic_count.min(arg_count) {
        let param = &params[i];
        let param_vk = param.value_kind();
        let param_rttid = param.rttid();
        let param_slots = call.get_type_slot_count(param_rttid) as usize;
        
        let (arg_slot0, arg_slot1) = read_slice_elem(args_slice_ref, i, elem_bytes);
        
        // Type check (unless param is any)
        if param_vk != ValueKind::Interface {
            let arg_vk = interface::unpack_value_kind(arg_slot0);
            let arg_rttid = interface::unpack_rttid(arg_slot0);
            
            if interface::is_nil(arg_slot0) {
                // nil is only valid for reference types
                if !matches!(param_vk, 
                    ValueKind::Pointer | ValueKind::Slice | ValueKind::Map | 
                    ValueKind::String | ValueKind::Closure) {
                    return Err(());
                }
            } else {
                // Check ValueKind compatibility
                if arg_vk != param_vk {
                    return Err(());
                }
                // For composite types, also check rttid to catch e.g. []int vs []string
                if matches!(param_vk, ValueKind::Struct | ValueKind::Array | 
                           ValueKind::Slice | ValueKind::Map | ValueKind::Pointer) {
                    if arg_rttid != param_rttid {
                        return Err(());
                    }
                }
            }
        }
        
        // Unbox
        if param_vk == ValueKind::Interface {
            args.push(arg_slot0);
            args.push(arg_slot1);
        } else if param_slots == 1 {
            args.push(arg_slot1);
        } else {
            args.extend(read_ref_slots(arg_slot1 as GcRef, param_slots));
        }
    }
    
    // Handle variadic
    if is_variadic && !params.is_empty() {
        let variadic_param = params.last().unwrap();
        let variadic_slice_rttid = variadic_param.rttid();
        
        let elem_vr = match call.get_slice_elem(variadic_slice_rttid) {
            Some(vr) => vr,
            None => return Ok(args),
        };
        let elem_vk = elem_vr.value_kind();
        let elem_slots = call.get_type_slot_count(elem_vr.rttid()) as usize;
        let elem_meta = ValueMeta::new(elem_vr.rttid(), elem_vk);
        
        let variadic_count = arg_count.saturating_sub(non_variadic_count);
        if variadic_count == 0 {
            args.push(core::ptr::null::<u8>() as u64);
        } else {
            let new_slice = slice::create(call.gc(), elem_meta, elem_slots * 8, variadic_count, variadic_count);
            for i in 0..variadic_count {
                let (arg_slot0, arg_slot1) = read_slice_elem(args_slice_ref, non_variadic_count + i, elem_bytes);
                set_slice_elem_from_any(new_slice, i, arg_slot0, arg_slot1, elem_vk, elem_slots);
            }
            args.push(new_slice as u64);
        }
    }
    
    Ok(args)
}

fn read_slice_elem(slice_ref: GcRef, idx: usize, elem_bytes: usize) -> (u64, u64) {
    let base_ptr = slice::data_ptr(slice_ref);
    let elem_ptr = unsafe { base_ptr.add(idx * elem_bytes) };
    let slot0 = unsafe { *(elem_ptr as *const u64) };
    let slot1 = if elem_bytes >= 16 { unsafe { *((elem_ptr as *const u64).add(1)) } } else { 0 };
    (slot0, slot1)
}

fn set_slice_elem_from_any(
    slice_ref: GcRef,
    idx: usize,
    arg_slot0: u64,
    arg_slot1: u64,
    elem_vk: ValueKind,
    elem_slots: usize,
) {
    if elem_vk == ValueKind::Interface || elem_slots == 2 {
        slice::set_n(slice_ref, idx, &[arg_slot0, arg_slot1], elem_slots * 8);
    } else if elem_slots == 1 {
        slice::set(slice_ref, idx, arg_slot1, 8);
    } else {
        let vals = read_ref_slots(arg_slot1 as GcRef, elem_slots);
        slice::set_n(slice_ref, idx, &vals, elem_slots * 8);
    }
}

fn pack_returns(
    call: &mut ExternCallContext,
    ret_buffer: &[u64],
    ret_value_rttids: &[vo_common_core::types::ValueRttid],
    ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
    _error_offset: u16,
) {
    let mut src_off = 0usize;
    let mut dst_off: u16 = 0;
    
    for i in 0..ret_count {
        let (_expected_rttid, expected_vk, is_any) = get_expected_meta(call, metas_start, is_any_start, i);
        
        let (actual_rttid, actual_vk, actual_width) = if i < ret_value_rttids.len() {
            let vr = &ret_value_rttids[i];
            let rttid = vr.rttid();
            let vk = vr.value_kind();
            let width = match vk {
                ValueKind::Interface => 2,
                ValueKind::Struct | ValueKind::Array => call.get_type_slot_count(rttid) as usize,
                _ => 1,
            };
            (rttid, vk, width)
        } else {
            (0, ValueKind::Int, 1)
        };
        
        let raw_slots = if src_off + actual_width <= ret_buffer.len() {
            &ret_buffer[src_off..src_off + actual_width]
        } else {
            &[][..]
        };
        src_off += actual_width;
        
        let output_slots = output_slot_count(is_any, expected_vk, actual_width);
        
        if is_any {
            let boxed = call.box_to_interface(actual_rttid, actual_vk, raw_slots);
            call.ret_any(dst_off, boxed);
        } else if (expected_vk == ValueKind::Struct || expected_vk == ValueKind::Array) && actual_width > 2 {
            let new_ref = call.alloc_and_copy_slots(raw_slots);
            call.ret_u64(dst_off, 0);
            call.ret_u64(dst_off + 1, new_ref as u64);
        } else {
            call.ret_u64(dst_off, raw_slots.get(0).copied().unwrap_or(0));
            if output_slots > 1 {
                call.ret_u64(dst_off + 1, raw_slots.get(1).copied().unwrap_or(0));
            }
        }
        
        dst_off += output_slots;
    }
}

// ============================================================================
// Layer 6: Extern Entry Points
// ============================================================================

fn dyn_field(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let field_name_ref = call.arg_ref(2);
    let expected_rttid = call.arg_u64(3) as u32;
    let expected_vk = ValueKind::from_u8(call.arg_u64(4) as u8);
    
    if interface::is_nil(base_slot0) {
        return write_get_error(call, DynErr::NilBase, "cannot access field on nil");
    }
    
    let field_name = if field_name_ref.is_null() {
        return write_get_error(call, DynErr::NilBase, "field name is nil");
    } else {
        str_obj::as_str(field_name_ref)
    };
    
    match get_value(call, base_slot0, base_slot1, DynKey::Field(field_name)) {
        Ok((v0, v1)) => write_get_result(call, v0, v1, expected_rttid, expected_vk),
        Err(DynOrSuspend::Dyn(e, m)) => write_get_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

fn dyn_index(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    let expected_rttid = call.arg_u64(4) as u32;
    let expected_vk = ValueKind::from_u8(call.arg_u64(5) as u8);
    
    if interface::is_nil(base_slot0) {
        return write_get_error(call, DynErr::NilBase, "cannot index nil");
    }
    
    match get_value(call, base_slot0, base_slot1, DynKey::Index(key_slot0, key_slot1)) {
        Ok((v0, v1)) => write_get_result(call, v0, v1, expected_rttid, expected_vk),
        Err(DynOrSuspend::Dyn(e, m)) => write_get_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

fn dyn_set_field(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let field_name_ref = call.arg_ref(2);
    let val_slot0 = call.arg_u64(3);
    let val_slot1 = call.arg_u64(4);
    
    if interface::is_nil(base_slot0) {
        return write_set_error(call, DynErr::NilBase, "cannot set field on nil");
    }
    
    let field_name = if field_name_ref.is_null() {
        return write_set_error(call, DynErr::NilBase, "field name is nil");
    } else {
        str_obj::as_str(field_name_ref)
    };
    
    match set_value(call, base_slot0, base_slot1, DynKey::Field(field_name), val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err(DynOrSuspend::Dyn(e, m)) => write_set_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

fn dyn_set_index_unified(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    let val_slot0 = call.arg_u64(4);
    let val_slot1 = call.arg_u64(5);
    
    if interface::is_nil(base_slot0) {
        return write_set_error(call, DynErr::NilBase, "cannot set index on nil");
    }
    
    match set_value(call, base_slot0, base_slot1, DynKey::Index(key_slot0, key_slot1), val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err(DynOrSuspend::Dyn(e, m)) => write_set_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

fn dyn_call(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let args_slice_ref = call.arg_u64(2) as GcRef;
    let ret_count = call.arg_u64(3) as usize;
    let metas_start = 4u16;
    let is_any_start = metas_start + ret_count as u16;
    let error_offset = compute_error_offset(call, ret_count, metas_start, is_any_start);
    
    if interface::is_nil(base_slot0) {
        return call_return_error(call, error_offset, DynErr::NilBase, "cannot call nil");
    }
    
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // Protocol check
    if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().call_object_iface_id) {
        return do_call_via_protocol(call, base_slot1, rttid, vk, iface_id, args_slice_ref, ret_count, metas_start, is_any_start, error_offset);
    }
    
    // Closure fallback
    if vk != ValueKind::Closure {
        return call_return_error(call, error_offset, DynErr::BadCall, &format!("cannot call {:?}", vk));
    }
    
    do_call(call, base_slot1 as GcRef, rttid, args_slice_ref, ret_count, metas_start, is_any_start, error_offset)
}

fn dyn_method(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let method_name_ref = call.arg_u64(2) as GcRef;
    let args_slice_ref = call.arg_u64(3) as GcRef;
    let ret_count = call.arg_u64(4) as usize;
    let metas_start = 5u16;
    let is_any_start = metas_start + ret_count as u16;
    let error_offset = compute_error_offset(call, ret_count, metas_start, is_any_start);
    
    if interface::is_nil(base_slot0) {
        return call_return_error(call, error_offset, DynErr::NilBase, "cannot call method on nil");
    }
    
    let method_name = str_obj::as_str(method_name_ref);
    do_method(call, base_slot0, base_slot1, method_name, args_slice_ref, ret_count, metas_start, is_any_start, error_offset)
}

fn do_call_via_protocol(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    iface_id: u32,
    args_slice_ref: GcRef,
    ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
    error_offset: u16,
) -> ExternResult {
    // Protocol only supports single return
    if ret_count > 1 {
        return call_return_error(call, error_offset, DynErr::SigMismatch, "CallObject only supports single return");
    }
    
    let func_id = match protocol_func_id(call, rttid, vk, iface_id, DynErr::BadCall) {
        Ok(id) => id,
        Err((e, m)) => return call_return_error(call, error_offset, e, m),
    };
    
    if call.is_replay_panicked() {
        return call_return_error(call, error_offset, DynErr::BadCall, "closure panicked");
    }
    
    let closure_ref = closure::create(call.gc(), func_id, 0);
    let args = vec![base_slot1, args_slice_ref as u64];
    
    let ret_vec = match call.resume_closure_result() {
        Some(cached) => cached,
        None => {
            return ExternResult::CallClosure {
                closure_ref,
                args,
            };
        }
    };
    
    // Unpack into fixed-size array
    let mut ret = [0u64; 4];
    let copy_len = ret_vec.len().min(4);
    ret[..copy_len].copy_from_slice(&ret_vec[..copy_len]);
    
    // Check error
    if ret[2] != 0 || ret[3] != 0 {
        for i in 0..error_offset {
            call.ret_u64(i, 0);
        }
        call.ret_interface_pair(error_offset, (ret[2], ret[3]));
        return ExternResult::Ok;
    }
    
    // Unbox result
    if ret_count == 0 {
        return call_return_success(call, error_offset);
    }
    
    let (_expected_rttid, expected_vk, is_any) = get_expected_meta(call, metas_start, is_any_start, 0);
    if is_any || expected_vk == ValueKind::Interface {
        call.ret_u64(0, ret[0]);
        call.ret_u64(1, ret[1]);
    } else {
        call.ret_u64(0, ret[1]);
    }
    
    call_return_success(call, error_offset)
}

// ============================================================================
// Layer 6a: Result Writers
// ============================================================================

fn write_get_result(
    call: &mut ExternCallContext,
    data_slot0: u64,
    data_slot1: u64,
    expected_rttid: u32,
    expected_vk: ValueKind,
) -> ExternResult {
    if expected_vk == ValueKind::Interface {
        call.ret_u64(0, data_slot0);
        call.ret_u64(1, data_slot1);
        call.ret_nil(2);
        call.ret_nil(3);
        return ExternResult::Ok;
    }
    
    // Unbox
    let actual_vk = interface::unpack_value_kind(data_slot0);
    let actual_rttid = interface::unpack_rttid(data_slot0);
    
    if expected_rttid != 0 && actual_rttid != expected_rttid {
        return write_get_error(call, DynErr::TypeMismatch, "type assertion failed");
    }
    
    let expected_slots = call.get_type_slot_count(expected_rttid) as usize;
    
    if expected_slots <= 2 {
        if actual_vk == ValueKind::Struct || actual_vk == ValueKind::Array {
            let data_ref = data_slot1 as GcRef;
            if data_ref.is_null() {
                call.ret_u64(0, 0);
                call.ret_u64(1, 0);
            } else {
                call.ret_u64(0, unsafe { Gc::read_slot(data_ref, 0) });
                call.ret_u64(1, if expected_slots > 1 { unsafe { Gc::read_slot(data_ref, 1) } } else { 0 });
            }
        } else {
            call.ret_u64(0, data_slot1);
            call.ret_u64(1, 0);
        }
    } else {
        call.ret_u64(0, 0);
        call.ret_u64(1, data_slot1);
    }
    
    call.ret_nil(2);
    call.ret_nil(3);
    ExternResult::Ok
}

fn write_get_error(call: &mut ExternCallContext, err: DynErr, msg: &str) -> ExternResult {
    call.ret_u64(0, 0);
    call.ret_u64(1, 0);
    let (cause0, cause1) = dyn_sentinel_error(call, err.into());
    let (slot0, slot1) = create_error_with_cause(call, msg, cause0, cause1);
    call.ret_u64(2, slot0);
    call.ret_u64(3, slot1);
    ExternResult::Ok
}

fn write_set_error(call: &mut ExternCallContext, err: DynErr, msg: &str) -> ExternResult {
    let (cause0, cause1) = dyn_sentinel_error(call, err.into());
    let (slot0, slot1) = create_error_with_cause(call, msg, cause0, cause1);
    call.ret_u64(0, slot0);
    call.ret_u64(1, slot1);
    ExternResult::Ok
}

// ============================================================================
// Layer 7: User API (dyn.GetAttr etc)
// ============================================================================

fn dyn_get_attr(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let name_ref = call.arg_ref(2);
    
    if interface::is_nil(base_slot0) {
        return write_get_error(call, DynErr::NilBase, "cannot access field on nil");
    }
    
    let field_name = if name_ref.is_null() {
        return write_get_error(call, DynErr::NilBase, "field name is nil");
    } else {
        str_obj::as_str(name_ref)
    };
    
    match get_value(call, base_slot0, base_slot1, DynKey::Field(field_name)) {
        Ok((v0, v1)) => {
            call.ret_u64(0, v0);
            call.ret_u64(1, v1);
            call.ret_nil(2);
            call.ret_nil(3);
            ExternResult::Ok
        }
        Err(DynOrSuspend::Dyn(e, m)) => write_get_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

fn dyn_get_index(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    
    if interface::is_nil(base_slot0) {
        return write_get_error(call, DynErr::NilBase, "cannot index nil");
    }
    
    match get_value(call, base_slot0, base_slot1, DynKey::Index(key_slot0, key_slot1)) {
        Ok((v0, v1)) => {
            call.ret_u64(0, v0);
            call.ret_u64(1, v1);
            call.ret_nil(2);
            call.ret_nil(3);
            ExternResult::Ok
        }
        Err(DynOrSuspend::Dyn(e, m)) => write_get_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

fn dyn_set_attr(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let name_ref = call.arg_ref(2);
    let val_slot0 = call.arg_u64(3);
    let val_slot1 = call.arg_u64(4);
    
    if interface::is_nil(base_slot0) {
        return write_set_error(call, DynErr::NilBase, "cannot set field on nil");
    }
    
    let field_name = if name_ref.is_null() {
        return write_set_error(call, DynErr::NilBase, "field name is nil");
    } else {
        str_obj::as_str(name_ref)
    };
    
    match set_value(call, base_slot0, base_slot1, DynKey::Field(field_name), val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err(DynOrSuspend::Dyn(e, m)) => write_set_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

fn dyn_set_index(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    let val_slot0 = call.arg_u64(4);
    let val_slot1 = call.arg_u64(5);
    
    if interface::is_nil(base_slot0) {
        return write_set_error(call, DynErr::NilBase, "cannot set index on nil");
    }
    
    match set_value(call, base_slot0, base_slot1, DynKey::Index(key_slot0, key_slot1), val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err(DynOrSuspend::Dyn(e, m)) => write_set_error(call, e, m),
        Err(DynOrSuspend::Suspend(r)) => r,
    }
}

// ============================================================================
// Layer 7a: dyn_pack_any_slice (used by codegen)
// ============================================================================

fn dyn_pack_any_slice(call: &mut ExternCallContext) -> ExternResult {
    use vo_common_core::types::ValueMeta;

    let arg_count = call.arg_u64(0) as usize;
    let spread_flag = call.arg_u64(1) != 0;
    let args_start = 2u16;

    let mut spread_len = 0usize;
    let mut spread_slice_ref: GcRef = core::ptr::null_mut();
    let mut spread_elem_rttid = 0u32;
    let mut spread_elem_vk = ValueKind::Void;
    let mut spread_elem_slots = 0usize;
    let mut spread_is_any = false;

    if spread_flag && arg_count > 0 {
        let last_idx = arg_count - 1;
        let last_slot0 = call.arg_u64(args_start + (last_idx * 2) as u16);
        let last_slot1 = call.arg_u64(args_start + (last_idx * 2) as u16 + 1);
        let last_vk = interface::unpack_value_kind(last_slot0);
        if last_vk != ValueKind::Slice {
            call.ret_ref(0, core::ptr::null_mut());
            let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
            let (slot0, slot1) = create_error_with_cause(call, "spread arg must be slice", cause0, cause1);
            call.ret_u64(1, slot0);
            call.ret_u64(2, slot1);
            return ExternResult::Ok;
        }

        let slice_rttid = interface::unpack_rttid(last_slot0);
        let elem = match call.get_slice_elem(slice_rttid) {
            Some(e) => e,
            None => {
                call.ret_ref(0, core::ptr::null_mut());
                let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
                let (slot0, slot1) = create_error_with_cause(call, "invalid slice type", cause0, cause1);
                call.ret_u64(1, slot0);
                call.ret_u64(2, slot1);
                return ExternResult::Ok;
            }
        };
        
        spread_elem_rttid = elem.rttid();
        spread_elem_vk = elem.value_kind();
        spread_elem_slots = call.get_type_slot_count(spread_elem_rttid) as usize;
        spread_is_any = spread_elem_vk == ValueKind::Interface;

        spread_slice_ref = last_slot1 as GcRef;
        spread_len = if spread_slice_ref.is_null() { 0 } else { slice::len(spread_slice_ref) };
    }

    let out_len = if spread_flag && arg_count > 0 { (arg_count - 1) + spread_len } else { arg_count };
    let elem_meta = ValueMeta::new(0, ValueKind::Interface);
    let new_slice = slice::create(call.gc(), elem_meta, 16, out_len, out_len);

    if out_len > 0 {
        let dst_ptr = slice::data_ptr(new_slice) as *mut u64;
        let mut out_i = 0usize;
        let direct_count = if spread_flag && arg_count > 0 { arg_count - 1 } else { arg_count };

        for i in 0..direct_count {
            let slot0 = call.arg_u64(args_start + (i * 2) as u16);
            let slot1 = call.arg_u64(args_start + (i * 2) as u16 + 1);
            unsafe {
                *dst_ptr.add(out_i * 2) = slot0;
                *dst_ptr.add(out_i * 2 + 1) = slot1;
            }
            out_i += 1;
        }

        if spread_flag && arg_count > 0 && !spread_slice_ref.is_null() {
            let spread_elem_bytes = array::elem_bytes(slice::array_ref(spread_slice_ref));
            for i in 0..spread_len {
                let (elem_slot0, elem_slot1) = if spread_is_any {
                    read_slice_elem(spread_slice_ref, i, spread_elem_bytes)
                } else {
                    let raw: Vec<u64> = (0..spread_elem_slots)
                        .map(|j| slice::get(spread_slice_ref, i * spread_elem_slots + j, 8))
                        .collect();
                    let boxed = call.box_to_interface(spread_elem_rttid, spread_elem_vk, &raw);
                    (boxed.slot0, boxed.slot1)
                };
                unsafe {
                    *dst_ptr.add(out_i * 2) = elem_slot0;
                    *dst_ptr.add(out_i * 2 + 1) = elem_slot1;
                }
                out_i += 1;
            }
        }
    }

    call.ret_ref(0, new_slice);
    call.ret_nil(1);
    call.ret_nil(2);
    ExternResult::Ok
}

fn dyn_type_assert_error(call: &mut ExternCallContext) -> ExternResult {
    let expected_rttid = call.arg_u64(0) as u32;
    let expected_vk = call.arg_u64(1) as u8;
    let got_slot0 = call.arg_u64(2);
    
    let got_vk = interface::unpack_value_kind(got_slot0);
    let got_rttid = interface::unpack_rttid(got_slot0);
    
    let msg = format!(
        "type assertion failed: expected vk={} rttid={}, got vk={:?} rttid={}",
        expected_vk, expected_rttid, got_vk, got_rttid
    );
    write_set_error(call, DynErr::TypeMismatch, &msg)
}

// ============================================================================
// Registration
// ============================================================================

pub fn register_externs(registry: &mut crate::ffi::ExternRegistry, externs: &[crate::bytecode::ExternDef]) {
    use crate::ffi::ExternFn;
    
    const TABLE: &[(&str, ExternFn)] = &[
        ("dyn_getDynErrors", get_dyn_errors),
        ("dyn_field", dyn_field),
        ("dyn_index", dyn_index),
        ("dyn_set_field", dyn_set_field),
        ("dyn_set_index_unified", dyn_set_index_unified),
        ("dyn_call", dyn_call),
        ("dyn_method", dyn_method),
        ("dyn_pack_any_slice", dyn_pack_any_slice),
        ("dyn_type_assert_error", dyn_type_assert_error),
        ("dyn_GetAttr", dyn_get_attr),
        ("dyn_GetIndex", dyn_get_index),
        ("dyn_SetAttr", dyn_set_attr),
        ("dyn_SetIndex", dyn_set_index),
    ];
    
    for (id, def) in externs.iter().enumerate() {
        for (name, func) in TABLE {
            if def.name == *name {
                registry.register(id as u32, *func);
                break;
            }
        }
    }
}

//! Dynamic access runtime helpers for the ~> operator.
//!
//! These functions implement runtime reflection for dynamic field/index/method access.

#[cfg(not(feature = "std"))]
use alloc::vec::Vec;
#[cfg(not(feature = "std"))]
use alloc::vec;
#[cfg(not(feature = "std"))]
use alloc::format;

use vo_common_core::types::ValueKind;
use vo_ffi_macro::vo_errors;

use crate::ffi::{ExternCallContext, ExternResult};
use crate::gc::{Gc, GcRef};
use crate::objects::{array, interface, map, slice, string as str_obj, struct_ops};
use crate::slot::SLOT_BYTES;
use vo_common_core::runtime_type::RuntimeType;
use super::error_helper::write_error_to;
use super::error_helper::create_error_with_cause;

// Dyn sentinel errors - generated by vo_errors! macro
vo_errors! {
    internal "dyn" => {
        Unknown => "dynamic access: unknown error",
        NilBase => "dynamic access: base value is nil",
        BadField => "dynamic access: field does not exist",
        BadIndex => "dynamic access: invalid index type",
        OutOfBounds => "dynamic access: index out of bounds",
        BadCall => "dynamic access: cannot call value",
        SigMismatch => "dynamic access: signature mismatch",
        TypeMismatch => "dynamic access: type mismatch",
    }
}

fn dyn_pack_any_slice(call: &mut ExternCallContext) -> ExternResult {
    use vo_common_core::types::ValueMeta;

    let arg_count = call.arg_u64(0) as usize;
    let spread_flag = call.arg_u64(1) != 0;
    let args_start = 2u16;

    let mut spread_len = 0usize;
    let mut spread_slice_ref: crate::gc::GcRef = core::ptr::null_mut();
    let mut spread_elem_rttid = 0u32;
    let mut spread_elem_vk = ValueKind::Void;
    let mut spread_elem_slots = 0usize;
    let mut spread_is_any = false;

    if spread_flag && arg_count > 0 {
        let last_idx = arg_count - 1;
        let last_slot0 = call.arg_u64(args_start + (last_idx * 2) as u16);
        let last_slot1 = call.arg_u64(args_start + (last_idx * 2) as u16 + 1);
        let last_vk = interface::unpack_value_kind(last_slot0);
        if last_vk != ValueKind::Slice {
            call.ret_ref(0, core::ptr::null_mut());
            let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
            let (slot0, slot1) = create_error_with_cause(call, "dyn call spread arg must be a slice", cause0, cause1);
            call.ret_u64(1, slot0);
            call.ret_u64(2, slot1);
            return ExternResult::Ok;
        }

        let slice_rttid = interface::unpack_rttid(last_slot0);
        let elem = match call.get_slice_elem(slice_rttid) {
            Some(e) => e,
            None => {
                call.ret_ref(0, core::ptr::null_mut());
                let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
                let (slot0, slot1) = create_error_with_cause(call, "dyn call spread arg is not a slice type", cause0, cause1);
                call.ret_u64(1, slot0);
                call.ret_u64(2, slot1);
                return ExternResult::Ok;
            }
        };
        
        spread_elem_rttid = elem.rttid();
        spread_elem_vk = elem.value_kind();
        spread_elem_slots = call.get_type_slot_count(spread_elem_rttid) as usize;
        spread_is_any = spread_elem_vk == ValueKind::Interface;

        spread_slice_ref = last_slot1 as crate::gc::GcRef;
        spread_len = if spread_slice_ref.is_null() { 0 } else { slice::len(spread_slice_ref) };
    }

    let out_len = if spread_flag && arg_count > 0 {
        (arg_count - 1) + spread_len
    } else {
        arg_count
    };

    let elem_meta = ValueMeta::new(0, ValueKind::Interface);
    let new_slice = slice::create(call.gc(), elem_meta, 16, out_len, out_len);

    if out_len > 0 {
        let dst_ptr = slice::data_ptr(new_slice) as *mut u64;
        let mut out_i = 0usize;

        let direct_count = if spread_flag && arg_count > 0 { arg_count - 1 } else { arg_count };
        for i in 0..direct_count {
            let slot0 = call.arg_u64(args_start + (i * 2) as u16);
            let slot1 = call.arg_u64(args_start + (i * 2) as u16 + 1);
            unsafe {
                *dst_ptr.add(out_i * 2) = slot0;
                *dst_ptr.add(out_i * 2 + 1) = slot1;
            }
            out_i += 1;
        }

        // Handle spread slice - convert typed elements to any format
        if spread_flag && arg_count > 0 && spread_len > 0 && !spread_slice_ref.is_null() {
            if spread_is_any {
                // Already []any - direct copy
                let src_ptr = slice::data_ptr(spread_slice_ref) as *const u64;
                unsafe {
                    core::ptr::copy_nonoverlapping(src_ptr, dst_ptr.add(out_i * 2), spread_len * 2);
                }
            } else {
                // Typed slice - box each element to any format
                let arr = slice::array_ref(spread_slice_ref);
                let elem_bytes = array::elem_bytes(arr);
                let src_base = slice::data_ptr(spread_slice_ref);
                
                for j in 0..spread_len {
                    let elem_ptr = unsafe { src_base.add(j * elem_bytes) };
                    
                    // Read raw slots from element
                    let raw_slots: Vec<u64> = (0..spread_elem_slots)
                        .map(|k| unsafe { *(elem_ptr as *const u64).add(k) })
                        .collect();
                    
                    // Box to interface format
                    let boxed = call.box_to_interface(spread_elem_rttid, spread_elem_vk, &raw_slots);
                    unsafe {
                        *dst_ptr.add(out_i * 2) = boxed.slot0;
                        *dst_ptr.add(out_i * 2 + 1) = boxed.slot1;
                    }
                    out_i += 1;
                }
            }
        }
    }

    call.ret_ref(0, new_slice);
    call.ret_nil(1);
    call.ret_nil(2);
    ExternResult::Ok
}

// ==================== Helper functions ====================

/// Check if a ValueKind is an integer type (Int, Int64, Int32, Int16, Int8).
#[inline]
fn is_integer_value_kind(vk: ValueKind) -> bool {
    matches!(vk, ValueKind::Int | ValueKind::Int64 | ValueKind::Int32 | ValueKind::Int16 | ValueKind::Int8)
}

/// A pointer dereference step in an embedding path.
///
/// Only pointer embedded fields (e.g., `*Inner`) create steps.
/// Value embedded fields just contribute to the final offset.
#[derive(Debug, Clone, Copy)]
struct PtrDerefStep {
    /// Offset to read the pointer value from the current struct
    offset: usize,
}

/// Result of looking up a field, possibly through embedded structs.
struct FieldLookupResult {
    /// Pointer dereference steps to reach the final struct
    ptr_derefs: Vec<PtrDerefStep>,
    /// Final offset within the last struct (after following all steps)
    final_offset: usize,
    /// Number of slots the field occupies
    slot_count: usize,
    /// Field's rttid
    rttid: u32,
    /// Field's ValueKind
    value_kind: ValueKind,
}

/// Recursively lookup a field by name, searching through embedded structs.
///
/// Design:
/// - `ptr_derefs` accumulates pointer dereference steps (for `*T` embeddings)
/// - `current_offset` accumulates value embedding offsets (for `T` embeddings)
/// - When we hit a pointer embedding, we record it and reset offset to 0
/// - The final `final_offset` is relative to the last pointer dereference (or base struct)
fn lookup_field_recursive(
    call: &ExternCallContext,
    struct_meta_id: usize,
    field_name: &str,
    current_offset: usize,
    ptr_derefs: &mut Vec<PtrDerefStep>,
) -> Option<FieldLookupResult> {
    let struct_meta = call.struct_meta(struct_meta_id)?;
    
    // First, try direct field lookup
    if let Some(field) = struct_meta.get_field(field_name) {
        return Some(FieldLookupResult {
            ptr_derefs: ptr_derefs.clone(),
            final_offset: current_offset + field.offset as usize,
            slot_count: field.slot_count as usize,
            rttid: field.type_info.rttid(),
            value_kind: field.type_info.value_kind(),
        });
    }
    
    // Not found directly - search in embedded fields
    for field in &struct_meta.fields {
        if !field.embedded {
            continue;
        }
        
        let field_vk = field.type_info.value_kind();
        let field_rttid = field.type_info.rttid();
        
        if field_vk == ValueKind::Pointer {
            // Pointer embedding (e.g., `*Inner`): need runtime dereference
            let elem_value_rttid = call.get_elem_value_rttid_from_base(field_rttid);
            let underlying_rttid = elem_value_rttid.rttid();
            
            if let Some(embedded_meta_id) = call.get_struct_meta_id_from_rttid(underlying_rttid) {
                ptr_derefs.push(PtrDerefStep {
                    offset: current_offset + field.offset as usize,
                });
                
                // After dereference, offset resets to 0 in the pointed-to struct
                if let Some(result) = lookup_field_recursive(call, embedded_meta_id as usize, field_name, 0, ptr_derefs) {
                    return Some(result);
                }
                
                ptr_derefs.pop(); // Backtrack
            }
        } else {
            // Value embedding (e.g., `Inner`): just add to offset
            if let Some(embedded_meta_id) = call.get_struct_meta_id_from_rttid(field_rttid) {
                let embedded_offset = current_offset + field.offset as usize;
                if let Some(result) = lookup_field_recursive(call, embedded_meta_id as usize, field_name, embedded_offset, ptr_derefs) {
                    return Some(result);
                }
            }
        }
    }
    
    None
}

/// Follow pointer dereferences to get the final struct reference.
/// Returns None if any pointer in the path is nil.
fn follow_ptr_derefs(derefs: &[PtrDerefStep], mut data_ref: GcRef) -> Option<GcRef> {
    for step in derefs {
        let ptr_value = unsafe { Gc::read_slot(data_ref, step.offset) };
        data_ref = ptr_value as GcRef;
        if data_ref.is_null() {
            return None;
        }
    }
    Some(data_ref)
}

/// Prepare a value for assignment to an interface-typed field/element.
/// Validates that the value implements the interface and computes the itab.
/// Returns (stored_slot0, val_slot1) on success.
#[inline]
fn prepare_interface_value(
    call: &mut ExternCallContext,
    val_slot0: u64,
    val_slot1: u64,
    target_iface_meta_id: u32,
) -> Result<(u64, u64), &'static str> {
    let val_vk = interface::unpack_value_kind(val_slot0);
    let val_rttid = interface::unpack_rttid(val_slot0);
    
    // For empty interface (any), meta_id is 0 - no itab needed
    if target_iface_meta_id == 0 {
        return Ok((val_slot0, val_slot1));
    }
    
    let named_type_id = call.get_named_type_id_from_rttid(val_rttid, true)
        .ok_or("value does not have methods")?;
    // Value types (non-pointer) cannot use pointer receiver methods
    let src_is_pointer = val_vk == ValueKind::Pointer;
    let itab_id = call.try_get_or_create_itab(named_type_id, target_iface_meta_id, src_is_pointer)
        .ok_or("value does not implement the interface")?;
    let stored_slot0 = interface::pack_slot0(itab_id, val_rttid, val_vk);
    Ok((stored_slot0, val_slot1))
}

/// Index check error type - callers map to error codes via call.dyn_err()
enum IndexError {
    BadType,
    OutOfBounds,
}

/// Check if key is an integer type, extract its value, and validate bounds.
/// Combines type checking and bounds checking in one call.
#[inline]
fn check_int_index(key_slot0: u64, key_slot1: u64, len: usize) -> Result<usize, IndexError> {
    let key_vk = interface::unpack_value_kind(key_slot0);
    if !is_integer_value_kind(key_vk) {
        return Err(IndexError::BadType);
    }
    
    let idx = key_slot1 as i64;
    if idx < 0 || idx as usize >= len {
        return Err(IndexError::OutOfBounds);
    }
    Ok(idx as usize)
}

/// dyn_get_attr: Get a field from an interface value by name.
///
/// Args: (base: any[2], name: string[1]) -> (data[2], error[2])
/// - base slot 0-1: interface value (slot0=meta, slot1=data)
/// - name slot 2: field name string
///
/// Returns (fixed 4 slots):
/// - slot 0-1: data in interface format (slot0=packed meta, slot1=value or GcRef)
/// - slot 2-3: error (nil if success)
///
/// Note: Always returns interface format. Codegen is responsible for unboxing to concrete types.
fn dyn_get_attr(call: &mut ExternCallContext) -> ExternResult {
    let slot0 = call.arg_u64(0);
    let slot1 = call.arg_u64(1);
    let name_ref = call.arg_ref(2);
    
    if interface::is_nil(slot0) {
        return dyn_error(call, DynErr::NilBase, "cannot access field on nil");
    }
    
    let field_name = if name_ref.is_null() {
        return dyn_error(call, DynErr::NilBase, "field name is nil");
    } else {
        str_obj::as_str(name_ref)
    };
    
    // Reuse unified implementation
    match get_field_as_interface(call, slot0, slot1, field_name) {
        Ok((data0, data1)) => {
            call.ret_u64(0, data0);
            call.ret_u64(1, data1);
            call.ret_nil(2);
            call.ret_nil(3);
            ExternResult::Ok
        }
        Err((err, msg)) => dyn_error(call, err, msg),
    }
}

/// Sentinel error types for dyn operations.
#[derive(Clone, Copy)]
enum DynErr {
    NilBase,
    BadField,
    BadIndex,
    OutOfBounds,
    BadCall,
    SigMismatch,
    TypeMismatch,
}

impl From<DynErr> for DynErrorKind {
    fn from(err: DynErr) -> Self {
        match err {
            DynErr::NilBase => DynErrorKind::NilBase,
            DynErr::BadField => DynErrorKind::BadField,
            DynErr::BadIndex => DynErrorKind::BadIndex,
            DynErr::OutOfBounds => DynErrorKind::OutOfBounds,
            DynErr::BadCall => DynErrorKind::BadCall,
            DynErr::SigMismatch => DynErrorKind::SigMismatch,
            DynErr::TypeMismatch => DynErrorKind::TypeMismatch,
        }
    }
}

/// Check if type implements a protocol interface.
/// Returns Some(iface_id) if the type implements the protocol, None otherwise.
fn check_protocol(
    call: &ExternCallContext,
    rttid: u32,
    vk: ValueKind,
    iface_id: Option<u32>,
) -> Option<u32> {
    let iface_id = iface_id?;
    let is_named = call.get_named_type_id_from_rttid(rttid, true).is_some();
    if is_named && call.check_interface_satisfaction(rttid, vk, iface_id) {
        Some(iface_id)
    } else {
        None
    }
}

/// Get func_id for a protocol method (method index 0) via itab lookup.
/// Common helper for all protocol dispatch functions.
fn get_protocol_func_id(
    call: &mut ExternCallContext,
    rttid: u32,
    vk: ValueKind,
    iface_id: u32,
    err_kind: DynErr,
) -> Result<u32, (DynErr, &'static str)> {
    let named_type_id = call.get_named_type_id_from_rttid(rttid, true)
        .ok_or((err_kind, "type has no methods"))?;
    
    let src_is_pointer = vk == ValueKind::Pointer;
    let itab_id = call.try_get_or_create_itab(named_type_id, iface_id, src_is_pointer)
        .ok_or((err_kind, "type does not implement protocol"))?;
    
    let itab = call.get_itab(itab_id)
        .ok_or((err_kind, "invalid itab"))?;
    
    itab.methods.first().copied()
        .ok_or((err_kind, "protocol has no methods"))
}

/// Call a protocol method and check for error in return value.
/// Returns the non-error portion of the return buffer.
fn call_protocol_method<const RET_SLOTS: usize>(
    call: &mut ExternCallContext,
    func_id: u32,
    args: &[u64],
    err_kind: DynErr,
) -> Result<[u64; RET_SLOTS], (DynErr, &'static str)> {
    use crate::objects::closure;
    let closure_ref = closure::create(call.gc(), func_id, 0);
    
    let mut ret_buffer = [0u64; RET_SLOTS];
    match call.call_closure(closure_ref, args, &mut ret_buffer) {
        Ok(_) => {
            // Error is always in last 2 slots
            let err_start = RET_SLOTS.saturating_sub(2);
            if ret_buffer[err_start] != 0 || ret_buffer.get(err_start + 1).copied().unwrap_or(0) != 0 {
                return Err((err_kind, "protocol returned error"));
            }
            Ok(ret_buffer)
        }
        Err(_) => Err((DynErr::BadCall, "protocol call failed")),
    }
}

/// Return a sentinel error for dyn operations (2 nil data slots + 2 error slots).
fn dyn_error(call: &mut ExternCallContext, err: DynErr, _fallback_msg: &str) -> ExternResult {
    call.ret_nil(0);
    call.ret_nil(1);
    let (slot0, slot1) = dyn_sentinel_error(call, err.into());
    call.ret_u64(2, slot0);
    call.ret_u64(3, slot1);
    ExternResult::Ok
}

/// Unbox interface value and write to return slots 0-1, with type check.
/// Returns Ok(()) on success, Err on type mismatch.
/// Caller is responsible for writing error slots (2-3) on success (nil) or failure.
fn unbox_and_write_value(
    call: &mut ExternCallContext,
    data_slot0: u64,
    data_slot1: u64,
    expected_rttid: u32,
) -> Result<(), DynErr> {
    let actual_vk = interface::unpack_value_kind(data_slot0);
    let actual_rttid = interface::unpack_rttid(data_slot0);
    
    // Type check
    if expected_rttid != 0 && actual_rttid != expected_rttid {
        return Err(DynErr::TypeMismatch);
    }
    
    let expected_slots = call.get_type_slot_count(expected_rttid) as usize;
    
    if expected_slots <= 2 {
        if actual_vk == ValueKind::Struct || actual_vk == ValueKind::Array {
            let data_ref = data_slot1 as GcRef;
            if data_ref.is_null() {
                call.ret_u64(0, 0);
                call.ret_u64(1, 0);
            } else {
                let slot0 = unsafe { Gc::read_slot(data_ref, 0) };
                let slot1 = if expected_slots > 1 {
                    unsafe { Gc::read_slot(data_ref, 1) }
                } else { 0 };
                call.ret_u64(0, slot0);
                call.ret_u64(1, slot1);
            }
        } else {
            call.ret_u64(0, data_slot1);
            call.ret_u64(1, 0);
        }
    } else {
        if actual_vk == ValueKind::Struct || actual_vk == ValueKind::Array {
            call.ret_u64(0, 0);
            call.ret_u64(1, data_slot1);
        } else {
            return Err(DynErr::TypeMismatch);
        }
    }
    Ok(())
}

/// Return a sentinel error for dyn operations (error only, 2 slots).
fn dyn_error_only(call: &mut ExternCallContext, err: DynErr, _fallback_msg: &str) -> ExternResult {
    let (slot0, slot1) = dyn_sentinel_error(call, err.into());
    call.ret_u64(0, slot0);
    call.ret_u64(1, slot1);
    ExternResult::Ok
}

/// dyn_get_index: Get an element from an interface value by index/key.
/// Args: (base: any[2], key: any[2]) -> (data[2], error[2])
fn dyn_get_index(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    
    if interface::is_nil(base_slot0) {
        return dyn_error(call, DynErr::NilBase, "cannot index nil");
    }
    
    // Reuse unified implementation
    match get_index_as_interface(call, base_slot0, base_slot1, key_slot0, key_slot1) {
        Ok((data0, data1)) => {
            call.ret_u64(0, data0);
            call.ret_u64(1, data1);
            call.ret_nil(2);
            call.ret_nil(3);
            ExternResult::Ok
        }
        Err((err, msg)) => dyn_error(call, err, msg),
    }
}

/// dyn_set_attr: Set a struct field on an interface value by name.
/// Args: (base: any[2], name: string[1], value: any[2]) -> error[2]
fn dyn_set_attr(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let name_ref = call.arg_ref(2);
    let val_slot0 = call.arg_u64(3);
    let val_slot1 = call.arg_u64(4);

    if interface::is_nil(base_slot0) {
        return dyn_error_only(call, DynErr::NilBase, "cannot set field on nil");
    }
    if name_ref.is_null() {
        return dyn_error_only(call, DynErr::NilBase, "field name is nil");
    }
    let field_name = str_obj::as_str(name_ref);

    // Reuse unified implementation
    match set_field_impl(call, base_slot0, base_slot1, field_name, val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err((err, msg)) => dyn_error_only(call, err, msg),
    }
}

/// dyn_set_index: Set an element in a map or slice by key/index.
/// Args: (base: any[2], key: any[2], value: any[2]) -> error[2]
fn dyn_set_index(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    let val_slot0 = call.arg_u64(4);
    let val_slot1 = call.arg_u64(5);

    if interface::is_nil(base_slot0) {
        return dyn_error_only(call, DynErr::NilBase, "cannot set index on nil");
    }

    // Reuse unified implementation
    match set_index_impl(call, base_slot0, base_slot1, key_slot0, key_slot1, val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err((err, msg)) => dyn_error_only(call, err, msg),
    }
}

/// dyn_type_assert_error: Create a type assertion error for dynamic access.
///
/// Args: (expected_rttid[1], expected_vk[1], got_slot0[1]) -> error[2]
/// - expected_rttid: expected runtime type id (0 for interface targets)
/// - expected_vk: expected value kind
/// - got_slot0: raw interface slot0 (runtime extracts rttid/vk from it)
///
/// Returns (2 slots): error interface
///
/// This is used by codegen when IfaceAssert fails during typed dynamic access.
fn dyn_type_assert_error(call: &mut ExternCallContext) -> ExternResult {
    let expected_rttid = call.arg_u64(0) as u32;
    let expected_vk = call.arg_u64(1) as u8;
    // slot0 format: [itab_id:32 | rttid:24 | value_kind:8]
    let got_slot0 = call.arg_u64(2);
    
    let expected_vk = ValueKind::from_u8(expected_vk);
    let got_vk = interface::unpack_value_kind(got_slot0);
    let got_rttid = interface::unpack_rttid(got_slot0);
    
    let msg = format!(
        "type assertion failed: expected {:?} (rttid {}), got {:?} (rttid {})",
        expected_vk, expected_rttid, got_vk, got_rttid
    );
    
    write_error_to(call, 0, &msg);
    ExternResult::Ok
}

// =============================================================================
// Public API - exposed via dyn package in stdlib
// =============================================================================
// These extern entries use Vo package naming convention (dyn_FuncName)
// to match the generated extern names from `dyn.FuncName()` calls.

// =============================================================================
// Unified dyn_field: Get field with type assertion in one step
// =============================================================================

/// dyn_field: Get a field and optionally unbox to expected type.
///
/// This combines dyn_get_attr + type assertion into one extern call,
/// eliminating the need for IfaceAssert/CallIface bytecode in codegen.
///
/// Args: (base[2], field_name[1], expected_rttid[1], expected_vk[1]) = 5 slots
/// - base[0-1]: interface value
/// - field_name[2]: string ref for field name
/// - expected_rttid[3]: expected type rttid (0 = any, no unboxing)
/// - expected_vk[4]: expected value kind
///
/// Returns: (value[2], error[2]) = 4 slots fixed
/// - If expected_vk == Interface: returns raw interface format (no unboxing)
/// - If expected_vk is 1-slot: slot0=value, slot1=0
/// - If expected_vk is 2-slot: slot0, slot1 = value
/// - If expected_vk is >2-slot: slot0=0, slot1=GcRef (heap allocated)
/// - error[2-3]: nil on success, error on failure
fn dyn_field(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let field_name_ref = call.arg_ref(2);
    let expected_rttid = call.arg_u64(3) as u32;
    let expected_vk = ValueKind::from_u8(call.arg_u64(4) as u8);
    
    // Check if interface is nil
    if interface::is_nil(base_slot0) {
        return dyn_value_error(call, DynErr::NilBase, "cannot access field on nil");
    }
    
    // Get field name
    let field_name = if field_name_ref.is_null() {
        return dyn_value_error(call, DynErr::NilBase, "field name is nil");
    } else {
        str_obj::as_str(field_name_ref)
    };
    
    // Get the field value as interface format using existing logic
    let (data_slot0, data_slot1) = match get_field_as_interface(call, base_slot0, base_slot1, field_name) {
        Ok(v) => v,
        Err((err, msg)) => return dyn_value_error(call, err, msg),
    };
    
    // If expected_vk is Interface (any), return as-is without unboxing
    if expected_vk == ValueKind::Interface {
        call.ret_u64(0, data_slot0);
        call.ret_u64(1, data_slot1);
        call.ret_nil(2);
        call.ret_nil(3);
        return ExternResult::Ok;
    }
    
    // Unbox and write value with type check
    if let Err(err) = unbox_and_write_value(call, data_slot0, data_slot1, expected_rttid) {
        return dyn_value_error(call, err, "type assertion failed");
    }
    
    call.ret_nil(2);
    call.ret_nil(3);
    ExternResult::Ok
}

/// Helper: get field value as interface format.
/// Returns (slot0, slot1) on success, or (DynErr, message) on failure.
/// 
/// Protocol-first: If the type implements AttrObject, call its DynAttr method.
/// Otherwise, fall back to reflection-based field access.
fn get_field_as_interface(
    call: &mut ExternCallContext,
    slot0: u64,
    slot1: u64,
    field_name: &str,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    let vk = interface::unpack_value_kind(slot0);
    let rttid = interface::unpack_rttid(slot0);
    
    // Protocol-first: check if type implements AttrObject
    if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().attr_object_iface_id) {
        return call_dyn_attr_protocol(call, slot0, slot1, rttid, vk, iface_id, field_name);
    }
    
    // Handle Map types with string keys
    if vk == ValueKind::Map {
        return get_map_field(call, slot1 as GcRef, rttid, field_name);
    }
    
    // Handle Pointer and Struct types
    let (effective_rttid, data_ref) = if vk == ValueKind::Pointer {
        let elem_value_rttid = call.get_elem_value_rttid_from_base(rttid);
        (elem_value_rttid.rttid(), slot1 as GcRef)
    } else if vk == ValueKind::Struct {
        (rttid, slot1 as GcRef)
    } else {
        // Try method lookup for named basic types
        if call.get_named_type_id_from_rttid(rttid, false).is_some() {
            return get_method_as_interface(call, rttid, slot1, field_name);
        }
        return Err((DynErr::TypeMismatch, "cannot access field on this type"));
    };
    
    // Get struct field
    let struct_meta_id = match call.get_struct_meta_id_from_rttid(effective_rttid) {
        Some(id) => id as usize,
        None => return get_method_as_interface(call, rttid, slot1, field_name),
    };
    
    let mut ptr_derefs = Vec::new();
    let field_result = match lookup_field_recursive(call, struct_meta_id, field_name, 0, &mut ptr_derefs) {
        Some(r) => r,
        None => return get_method_as_interface(call, rttid, slot1, field_name),
    };
    
    if data_ref.is_null() {
        return Err((DynErr::NilBase, "struct data is nil"));
    }
    
    let final_data_ref = match follow_ptr_derefs(&field_result.ptr_derefs, data_ref) {
        Some(r) => r,
        None => return Err((DynErr::NilBase, "nil pointer in embedding path")),
    };
    
    let raw_slots: Vec<u64> = (0..field_result.slot_count)
        .map(|i| unsafe { Gc::read_slot(final_data_ref, field_result.final_offset + i) })
        .collect();
    
    let boxed = call.box_to_interface(field_result.rttid, field_result.value_kind, &raw_slots);
    Ok((boxed.slot0, boxed.slot1))
}

/// Helper: get map field (string key access).
fn get_map_field(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    rttid: u32,
    field_name: &str,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    if base_ref.is_null() {
        return Err((DynErr::NilBase, "cannot access field on nil map"));
    }
    
    let map_key_vk = map::key_kind(base_ref);
    if map_key_vk != ValueKind::String && map_key_vk != ValueKind::Interface {
        return Err((DynErr::BadField, "cannot use field access on map with non-string key"));
    }
    
    let key_ref = call.alloc_str(field_name);
    let val_meta = map::val_meta(base_ref);
    let val_vk = val_meta.value_kind();
    let val_value_rttid = call.get_elem_value_rttid_from_base(rttid);
    
    let found = if map_key_vk == ValueKind::Interface {
        let key_slot0 = interface::pack_slot0(0, ValueKind::String as u32, ValueKind::String);
        let key_data = [key_slot0, key_ref as u64];
        map::get(base_ref, &key_data, Some(call.module()))
    } else {
        let key_data = [key_ref as u64];
        map::get(base_ref, &key_data, Some(call.module()))
    };
    
    if val_vk == ValueKind::Interface {
        if let Some(val_slice) = found {
            return Ok((val_slice[0], val_slice[1]));
        }
        return Ok((0, 0)); // nil interface for missing key
    }
    
    let raw_slots: Vec<u64> = if let Some(val_slice) = found {
        val_slice.to_vec()
    } else {
        let val_slots = call.get_type_slot_count(val_value_rttid.rttid()) as usize;
        vec![0u64; val_slots]
    };
    
    let boxed = call.box_to_interface(val_value_rttid.rttid(), val_vk, &raw_slots);
    Ok((boxed.slot0, boxed.slot1))
}

/// Helper: get method as closure in interface format.
fn get_method_as_interface(
    call: &mut ExternCallContext,
    rttid: u32,
    receiver_slot1: u64,
    method_name: &str,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    use crate::objects::closure;
    
    let (func_id, _is_pointer_receiver, signature_rttid) = match call.lookup_method(rttid, method_name) {
        Some(info) => info,
        None => return Err((DynErr::BadField, "field or method not found")),
    };
    
    let closure_ref = closure::create(call.gc(), func_id, 1);
    closure::set_capture(closure_ref, 0, receiver_slot1);
    
    let result_slot0 = interface::pack_slot0(0, signature_rttid, ValueKind::Closure);
    Ok((result_slot0, closure_ref as u64))
}

/// Helper: call AttrObject.DynAttr protocol method.
/// Returns (slot0, slot1) on success, or (DynErr, message) on failure.
fn call_dyn_attr_protocol(
    call: &mut ExternCallContext,
    _base_slot0: u64,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    attr_iface_id: u32,
    field_name: &str,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    let func_id = get_protocol_func_id(call, rttid, vk, attr_iface_id, DynErr::BadField)?;
    let name_ref = call.alloc_str(field_name);
    let ret = call_protocol_method::<4>(call, func_id, &[base_slot1, name_ref as u64], DynErr::BadField)?;
    Ok((ret[0], ret[1]))
}

// =============================================================================
// Unified dyn_index: Get index with type assertion in one step
// =============================================================================

/// dyn_index: Index access with optional type unboxing.
///
/// Args: (base[2], key[2], expected_rttid[1], expected_vk[1]) = 6 slots
/// - base[0-1]: interface value (slice, array, map, string, or IndexObject)
/// - key[2-3]: interface value for key
/// - expected_rttid[4]: expected type rttid (0 = any, no unboxing)
/// - expected_vk[5]: expected value kind
///
/// Returns: (value[2], error[2]) = 4 slots fixed
fn dyn_index(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    let expected_rttid = call.arg_u64(4) as u32;
    let expected_vk = ValueKind::from_u8(call.arg_u64(5) as u8);
    
    // Check if interface is nil
    if interface::is_nil(base_slot0) {
        return dyn_value_error(call, DynErr::NilBase, "cannot index nil");
    }
    
    // Get the indexed value as interface format
    let (data_slot0, data_slot1) = match get_index_as_interface(call, base_slot0, base_slot1, key_slot0, key_slot1) {
        Ok(v) => v,
        Err((err, msg)) => return dyn_value_error(call, err, msg),
    };
    
    // If expected_vk is Interface (any), return as-is without unboxing
    if expected_vk == ValueKind::Interface {
        call.ret_u64(0, data_slot0);
        call.ret_u64(1, data_slot1);
        call.ret_nil(2);
        call.ret_nil(3);
        return ExternResult::Ok;
    }
    
    // Unbox and write value with type check
    if let Err(err) = unbox_and_write_value(call, data_slot0, data_slot1, expected_rttid) {
        return dyn_value_error(call, err, "type assertion failed");
    }
    
    call.ret_nil(2);
    call.ret_nil(3);
    ExternResult::Ok
}

/// Helper: get indexed value as interface format.
/// Protocol-first: checks IndexObject protocol before reflection fallback.
fn get_index_as_interface(
    call: &mut ExternCallContext,
    base_slot0: u64,
    base_slot1: u64,
    key_slot0: u64,
    key_slot1: u64,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // Protocol-first: check if type implements IndexObject
    if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().index_object_iface_id) {
        return call_dyn_index_protocol(call, base_slot0, base_slot1, rttid, vk, iface_id, key_slot0, key_slot1);
    }
    
    // Reflection fallback: handle built-in indexable types
    let base_ref = base_slot1 as GcRef;
    
    match vk {
        ValueKind::Slice => {
            if base_ref.is_null() {
                return Err((DynErr::NilBase, "cannot index nil slice"));
            }
            let len = crate::objects::slice::len(base_ref);
            let idx = match check_int_index(key_slot0, key_slot1, len) {
                Ok(i) => i,
                Err(IndexError::BadType) => return Err((DynErr::BadIndex, "index must be integer")),
                Err(IndexError::OutOfBounds) => return Err((DynErr::OutOfBounds, "slice index out of bounds")),
            };
            
            let elem_meta = crate::objects::slice::elem_meta(base_ref);
            let elem_vk = elem_meta.value_kind();
            let elem_value_rttid = call.get_elem_value_rttid_from_base(rttid);
            let elem_slots = call.get_type_slot_count(elem_value_rttid.rttid()) as usize;
            
            let raw_slots: Vec<u64> = (0..elem_slots)
                .map(|i| crate::objects::slice::get(base_ref, idx as usize * elem_slots + i, 8))
                .collect();
            
            let boxed = call.box_to_interface(elem_value_rttid.rttid(), elem_vk, &raw_slots);
            Ok((boxed.slot0, boxed.slot1))
        }
        ValueKind::Array => {
            if base_ref.is_null() {
                return Err((DynErr::NilBase, "cannot index nil array"));
            }
            let len = crate::objects::array::len(base_ref);
            let idx = match check_int_index(key_slot0, key_slot1, len) {
                Ok(i) => i,
                Err(IndexError::BadType) => return Err((DynErr::BadIndex, "index must be integer")),
                Err(IndexError::OutOfBounds) => return Err((DynErr::OutOfBounds, "array index out of bounds")),
            };
            
            let elem_meta = crate::objects::array::elem_meta(base_ref);
            let elem_vk = elem_meta.value_kind();
            let elem_bytes = crate::objects::array::elem_bytes(base_ref);
            let elem_value_rttid = call.get_elem_value_rttid_from_base(rttid);
            let elem_slots = call.get_type_slot_count(elem_value_rttid.rttid()) as usize;
            
            let mut raw_slots: Vec<u64> = vec![0u64; elem_slots];
            crate::objects::array::get_n(base_ref, idx as usize, &mut raw_slots, elem_bytes);
            
            let boxed = call.box_to_interface(elem_value_rttid.rttid(), elem_vk, &raw_slots);
            Ok((boxed.slot0, boxed.slot1))
        }
        ValueKind::String => {
            let s = str_obj::as_str(base_ref);
            let bytes = s.as_bytes();
            let idx = match check_int_index(key_slot0, key_slot1, bytes.len()) {
                Ok(i) => i,
                Err(IndexError::BadType) => return Err((DynErr::BadIndex, "index must be integer")),
                Err(IndexError::OutOfBounds) => return Err((DynErr::OutOfBounds, "string index out of bounds")),
            };
            let boxed = call.box_to_interface(
                ValueKind::Uint8 as u32,
                ValueKind::Uint8,
                &[bytes[idx as usize] as u64],
            );
            Ok((boxed.slot0, boxed.slot1))
        }
        ValueKind::Map => {
            if base_ref.is_null() {
                return Err((DynErr::NilBase, "cannot index nil map"));
            }
            get_map_index(call, base_ref, rttid, key_slot0, key_slot1)
        }
        _ => Err((DynErr::TypeMismatch, "type does not support indexing")),
    }
}

/// Helper: get map value by key.
fn get_map_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    base_rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    let key_vk = interface::unpack_value_kind(key_slot0);
    let map_key_vk = crate::objects::map::key_kind(base_ref);
    
    let key_compatible = match (map_key_vk, key_vk) {
        (a, b) if a == b => true,
        (ValueKind::Interface, _) => true,
        (ValueKind::Int, k) | (k, ValueKind::Int) => is_integer_value_kind(k),
        _ => false,
    };
    
    if !key_compatible {
        return Err((DynErr::BadIndex, "map key type mismatch"));
    }
    
    // map::get takes &[u64] as key, and needs Module for InterfaceKey maps
    // For interface keys (map[any]T), pass both slots; for single-slot keys, just one
    let key_slots = if map_key_vk == ValueKind::Interface {
        vec![key_slot0, key_slot1]
    } else {
        vec![key_slot1]
    };
    let val_opt = crate::objects::map::get(base_ref, &key_slots, Some(call.module()));
    
    let elem_rttid = call.get_elem_value_rttid_from_base(base_rttid);
    let elem_vk = crate::objects::map::val_kind(base_ref);
    
    // Dynamic access: missing key returns error (unlike Go's zero value)
    match val_opt {
        None => Err((DynErr::BadField, "map key not found")),
        Some(raw_slots) => {
            let boxed = call.box_to_interface(elem_rttid.rttid(), elem_vk, raw_slots);
            Ok((boxed.slot0, boxed.slot1))
        }
    }
}

/// Helper: call IndexObject.DynIndex protocol method.
fn call_dyn_index_protocol(
    call: &mut ExternCallContext,
    _base_slot0: u64,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    index_iface_id: u32,
    key_slot0: u64,
    key_slot1: u64,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    let func_id = get_protocol_func_id(call, rttid, vk, index_iface_id, DynErr::BadIndex)?;
    let ret = call_protocol_method::<4>(call, func_id, &[base_slot1, key_slot0, key_slot1], DynErr::BadIndex)?;
    Ok((ret[0], ret[1]))
}

// =============================================================================
// Unified dyn_set_field: Set field with protocol support
// =============================================================================

/// dyn_set_field: Set a field with protocol-first dispatch.
///
/// Args: (base[2], field_name[1], value[2]) = 5 slots
/// Returns: error[2]
fn dyn_set_field(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let field_name_ref = call.arg_ref(2);
    let val_slot0 = call.arg_u64(3);
    let val_slot1 = call.arg_u64(4);
    
    if interface::is_nil(base_slot0) {
        return dyn_error_only(call, DynErr::NilBase, "cannot set field on nil");
    }
    
    let field_name = if field_name_ref.is_null() {
        return dyn_error_only(call, DynErr::NilBase, "field name is nil");
    } else {
        str_obj::as_str(field_name_ref)
    };
    
    match set_field_impl(call, base_slot0, base_slot1, field_name, val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err((err, _msg)) => dyn_error_only(call, err, _msg),
    }
}

/// Helper: set field implementation with protocol-first dispatch.
fn set_field_impl(
    call: &mut ExternCallContext,
    base_slot0: u64,
    base_slot1: u64,
    field_name: &str,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // Protocol-first: check if type implements SetAttrObject
    if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().set_attr_object_iface_id) {
        return call_dyn_set_attr_protocol(call, base_slot1, rttid, vk, iface_id, field_name, val_slot0, val_slot1);
    }
    
    // Reflection fallback: delegate to existing dyn_set_attr logic
    // For Map types with string keys, treat field_name as map key
    if vk == ValueKind::Map {
        let base_ref = base_slot1 as GcRef;
        let map_key_vk = crate::objects::map::key_kind(base_ref);
        
        if map_key_vk != ValueKind::String {
            return Err((DynErr::BadField, "cannot use field access on map with non-string key"));
        }
        
        return set_map_field(call, base_ref, rttid, field_name, val_slot0, val_slot1);
    }
    
    // Handle Pointer and Struct types
    let (effective_rttid, data_ref) = if vk == ValueKind::Pointer {
        let elem_value_rttid = call.get_elem_value_rttid_from_base(rttid);
        (elem_value_rttid.rttid(), base_slot1 as GcRef)
    } else if vk == ValueKind::Struct {
        (rttid, base_slot1 as GcRef)
    } else {
        return Err((DynErr::BadField, "cannot set field on this type"));
    };
    
    if data_ref.is_null() {
        return Err((DynErr::NilBase, "struct data is nil"));
    }
    
    set_struct_field(call, data_ref, effective_rttid, field_name, val_slot0, val_slot1)
}

/// Helper: set struct field by name.
fn set_struct_field(
    call: &mut ExternCallContext,
    data_ref: GcRef,
    effective_rttid: u32,
    field_name: &str,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let struct_meta_id = match call.get_struct_meta_id_from_rttid(effective_rttid) {
        Some(id) => id as usize,
        None => return Err((DynErr::BadField, "cannot set field on non-struct type")),
    };
    
    // Find field by name
    let mut ptr_derefs = Vec::new();
    let field_result = match lookup_field_recursive(&call, struct_meta_id, field_name, 0, &mut ptr_derefs) {
        Some(r) => r,
        None => return Err((DynErr::BadField, "field not found")),
    };
    
    // Get effective data pointer (handle embedded pointer fields)
    let mut effective_ref = data_ref;
    for deref in &field_result.ptr_derefs {
        let ptr_val = unsafe { Gc::read_slot(effective_ref, deref.offset as usize) } as GcRef;
        if ptr_val.is_null() {
            return Err((DynErr::NilBase, "embedded pointer is nil"));
        }
        effective_ref = ptr_val;
    }
    
    // Write value to field
    let field_vk = field_result.value_kind;
    let field_slots = field_result.slot_count;
    let val_vk = interface::unpack_value_kind(val_slot0);
    
    // Write value
    if field_vk == ValueKind::Interface {
        // Interface field: need to prepare the interface value with correct itab
        // Get the target interface's meta_id from the field's rttid
        let iface_meta_id = call.get_interface_meta_id_from_rttid(field_result.rttid)
            .unwrap_or(0);  // 0 for empty interface (any)
        let (stored_slot0, stored_slot1) = match prepare_interface_value(call, val_slot0, val_slot1, iface_meta_id) {
            Ok(v) => v,
            Err(_) => return Err((DynErr::TypeMismatch, "value does not implement interface")),
        };
        unsafe {
            Gc::write_slot(effective_ref, field_result.final_offset, stored_slot0);
            Gc::write_slot(effective_ref, field_result.final_offset + 1, stored_slot1);
        }
    } else if field_vk != val_vk {
        // Type check for non-interface fields
        return Err((DynErr::TypeMismatch, "field type mismatch"));
    } else if field_vk == ValueKind::Struct || field_vk == ValueKind::Array {
        // Multi-slot value: copy from source ref
        let src_ref = val_slot1 as GcRef;
        if src_ref.is_null() {
            for i in 0..field_slots {
                unsafe { Gc::write_slot(effective_ref, field_result.final_offset + i, 0); }
            }
        } else {
            for i in 0..field_slots {
                let slot = unsafe { Gc::read_slot(src_ref, i) };
                unsafe { Gc::write_slot(effective_ref, field_result.final_offset + i, slot); }
            }
        }
    } else {
        // Single-slot value
        unsafe { Gc::write_slot(effective_ref, field_result.final_offset, val_slot1); }
    }
    
    Ok(())
}

/// Helper: set map field (field_name as key).
fn set_map_field(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    base_rttid: u32,
    field_name: &str,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let key_ref = call.alloc_str(field_name);
    let key_buf = [key_ref as u64];
    
    let val_meta = crate::objects::map::val_meta(base_ref);
    let map_val_vk = val_meta.value_kind();
    let map_val_slots = crate::objects::map::val_slots(base_ref) as usize;
    let map_val_value_rttid = call.get_elem_value_rttid_from_base(base_rttid);
    
    let mut val_buf: Vec<u64> = Vec::with_capacity(map_val_slots);
    if map_val_vk == ValueKind::Interface {
        val_buf.push(val_slot0);
        val_buf.push(val_slot1);
    } else {
        let val_vk = interface::unpack_value_kind(val_slot0);
        if val_vk != map_val_vk {
            return Err((DynErr::TypeMismatch, "map value type mismatch"));
        }
        
        match map_val_vk {
            ValueKind::Struct | ValueKind::Array => {
                let src_ref = val_slot1 as GcRef;
                if src_ref.is_null() {
                    for _ in 0..map_val_slots {
                        val_buf.push(0);
                    }
                } else {
                    for i in 0..map_val_slots {
                        val_buf.push(unsafe { Gc::read_slot(src_ref, i) });
                    }
                }
            }
            _ => {
                val_buf.push(val_slot1);
            }
        }
    }
    
    crate::objects::map::set(base_ref, &key_buf, &val_buf, Some(call.module()));
    Ok(())
}

/// Helper: call SetAttrObject.DynSetAttr protocol method.
fn call_dyn_set_attr_protocol(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    set_attr_iface_id: u32,
    field_name: &str,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let func_id = get_protocol_func_id(call, rttid, vk, set_attr_iface_id, DynErr::BadField)?;
    let name_ref = call.alloc_str(field_name);
    let _ = call_protocol_method::<2>(call, func_id, &[base_slot1, name_ref as u64, val_slot0, val_slot1], DynErr::BadField)?;
    Ok(())
}

// =============================================================================
// Unified dyn_set_index: Set index with protocol support
// =============================================================================

/// dyn_set_index: Set an indexed value with protocol-first dispatch.
///
/// Args: (base[2], key[2], value[2]) = 6 slots
/// Returns: error[2]
fn dyn_set_index_unified(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let key_slot0 = call.arg_u64(2);
    let key_slot1 = call.arg_u64(3);
    let val_slot0 = call.arg_u64(4);
    let val_slot1 = call.arg_u64(5);
    
    if interface::is_nil(base_slot0) {
        return dyn_error_only(call, DynErr::NilBase, "cannot set index on nil");
    }
    
    match set_index_impl(call, base_slot0, base_slot1, key_slot0, key_slot1, val_slot0, val_slot1) {
        Ok(()) => {
            call.ret_nil(0);
            call.ret_nil(1);
            ExternResult::Ok
        }
        Err((err, _msg)) => dyn_error_only(call, err, _msg),
    }
}

/// Helper: set index implementation with protocol-first dispatch.
fn set_index_impl(
    call: &mut ExternCallContext,
    base_slot0: u64,
    base_slot1: u64,
    key_slot0: u64,
    key_slot1: u64,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // Protocol-first: check if type implements SetIndexObject
    if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().set_index_object_iface_id) {
        return call_dyn_set_index_protocol(call, base_slot1, rttid, vk, iface_id, key_slot0, key_slot1, val_slot0, val_slot1);
    }
    
    // Reflection fallback - only Slice and Map support index assignment
    // Array and String are value types and cannot be modified through dynamic access
    let base_ref = base_slot1 as GcRef;
    
    match vk {
        ValueKind::Slice => {
            if base_ref.is_null() {
                return Err((DynErr::NilBase, "cannot set index on nil slice"));
            }
            set_slice_index(call, base_ref, rttid, key_slot0, key_slot1, val_slot0, val_slot1)
        }
        ValueKind::Map => {
            if base_ref.is_null() {
                return Err((DynErr::NilBase, "cannot set index on nil map"));
            }
            set_map_index(call, base_ref, rttid, key_slot0, key_slot1, val_slot0, val_slot1)
        }
        ValueKind::Array => Err((DynErr::TypeMismatch, "cannot set index on value-type array")),
        ValueKind::String => Err((DynErr::TypeMismatch, "cannot set index on string")),
        _ => Err((DynErr::TypeMismatch, "type does not support index assignment")),
    }
}

/// Helper: set slice index.
fn set_slice_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    base_rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let len = crate::objects::slice::len(base_ref);
    let idx = match check_int_index(key_slot0, key_slot1, len) {
        Ok(i) => i as usize,
        Err(IndexError::BadType) => return Err((DynErr::BadIndex, "index must be integer")),
        Err(IndexError::OutOfBounds) => return Err((DynErr::OutOfBounds, "slice index out of bounds")),
    };
    
    let elem_meta = crate::objects::slice::elem_meta(base_ref);
    let elem_vk = elem_meta.value_kind();
    let elem_value_rttid = call.get_elem_value_rttid_from_base(base_rttid);
    let elem_slots = call.get_type_slot_count(elem_value_rttid.rttid()) as usize;
    
    // Type check
    let val_vk = interface::unpack_value_kind(val_slot0);
    if elem_vk != val_vk && elem_vk != ValueKind::Interface {
        return Err((DynErr::TypeMismatch, "slice element type mismatch"));
    }
    
    // Write value
    if elem_vk == ValueKind::Interface {
        crate::objects::slice::set(base_ref, idx * elem_slots, val_slot0, 8);
        crate::objects::slice::set(base_ref, idx * elem_slots + 1, val_slot1, 8);
    } else if elem_vk == ValueKind::Struct || elem_vk == ValueKind::Array {
        let src_ref = val_slot1 as GcRef;
        for i in 0..elem_slots {
            let slot = if src_ref.is_null() { 0 } else { unsafe { Gc::read_slot(src_ref, i) } };
            crate::objects::slice::set(base_ref, idx * elem_slots + i, slot, 8);
        }
    } else {
        crate::objects::slice::set(base_ref, idx * elem_slots, val_slot1, 8);
    }
    
    Ok(())
}

/// Helper: set map index.
fn set_map_index(
    call: &mut ExternCallContext,
    base_ref: GcRef,
    base_rttid: u32,
    key_slot0: u64,
    key_slot1: u64,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let key_vk = interface::unpack_value_kind(key_slot0);
    let map_key_vk = crate::objects::map::key_kind(base_ref);
    
    let key_compatible = match (map_key_vk, key_vk) {
        (a, b) if a == b => true,
        (ValueKind::Interface, _) => true,
        (ValueKind::Int, k) | (k, ValueKind::Int) => is_integer_value_kind(k),
        _ => false,
    };
    
    if !key_compatible {
        return Err((DynErr::BadIndex, "map key type mismatch"));
    }
    
    // Prepare key
    let key_slots = if map_key_vk == ValueKind::Interface {
        vec![key_slot0, key_slot1]
    } else {
        vec![key_slot1]
    };
    
    // Prepare value
    let val_meta = crate::objects::map::val_meta(base_ref);
    let map_val_vk = val_meta.value_kind();
    let map_val_slots = crate::objects::map::val_slots(base_ref) as usize;
    
    let mut val_buf: Vec<u64> = Vec::with_capacity(map_val_slots);
    if map_val_vk == ValueKind::Interface {
        val_buf.push(val_slot0);
        val_buf.push(val_slot1);
    } else {
        let val_vk = interface::unpack_value_kind(val_slot0);
        if val_vk != map_val_vk && map_val_vk != ValueKind::Interface {
            return Err((DynErr::TypeMismatch, "map value type mismatch"));
        }
        
        match map_val_vk {
            ValueKind::Struct | ValueKind::Array => {
                let src_ref = val_slot1 as GcRef;
                for i in 0..map_val_slots {
                    val_buf.push(if src_ref.is_null() { 0 } else { unsafe { Gc::read_slot(src_ref, i) } });
                }
            }
            _ => {
                val_buf.push(val_slot1);
            }
        }
    }
    
    crate::objects::map::set(base_ref, &key_slots, &val_buf, Some(call.module()));
    Ok(())
}

/// Helper: call SetIndexObject.DynSetIndex protocol method.
fn call_dyn_set_index_protocol(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    set_index_iface_id: u32,
    key_slot0: u64,
    key_slot1: u64,
    val_slot0: u64,
    val_slot1: u64,
) -> Result<(), (DynErr, &'static str)> {
    let func_id = get_protocol_func_id(call, rttid, vk, set_index_iface_id, DynErr::BadIndex)?;
    let _ = call_protocol_method::<2>(call, func_id, &[base_slot1, key_slot0, key_slot1, val_slot0, val_slot1], DynErr::BadIndex)?;
    Ok(())
}

/// Helper: return error for dyn_field/dyn_index (4 slots: value[2] + error[2]).
fn dyn_value_error(call: &mut ExternCallContext, err: DynErr, _msg: &str) -> ExternResult {
    call.ret_u64(0, 0);
    call.ret_u64(1, 0);
    let (slot0, slot1) = dyn_sentinel_error(call, err.into());
    call.ret_u64(2, slot0);
    call.ret_u64(3, slot1);
    ExternResult::Ok
}

// ============================================================================
// Unified dyn_call extern
// ============================================================================

/// dyn_call: Unified dynamic call with protocol-first dispatch.
///
/// Handles both CallObject protocol and closure calls in a single extern.
/// Protocol path is tried first; if type doesn't implement CallObject, falls back to closure call.
///
/// Args: (base[2], args_slice[1], expected_ret_count[1], expected_metas[N], is_any_flags[N])
/// - base[2]: the callable value as interface
/// - args_slice[1]: GcRef to []any slice containing packed arguments
/// - expected_ret_count[1]: number of expected return values (from LHS)
/// - expected_metas[N]: ValueRttid raw values for each expected return
/// - is_any_flags[N]: 1 if LHS expects any, 0 otherwise
///
/// Returns: (results[variable], error[2])
/// - results: return values in format matching LHS types
/// - error[2]: nil on success, error on failure
fn dyn_call(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let args_slice_ref = call.arg_u64(2) as GcRef;
    let expected_ret_count = call.arg_u64(3) as usize;
    let metas_start = 4u16;
    let is_any_start = metas_start + expected_ret_count as u16;
    
    // Calculate error slot offset based on expected return types
    let error_slot_offset = compute_dyn_call_error_offset(call, expected_ret_count, metas_start, is_any_start);
    
    // Helper macro to return error
    macro_rules! return_error {
        ($err:expr, $msg:expr) => {{
            for i in 0..error_slot_offset {
                call.ret_u64(i, 0);
            }
            let (cause0, cause1) = dyn_sentinel_error(call, $err.into());
            let (slot0, slot1) = create_error_with_cause(call, $msg, cause0, cause1);
            call.ret_u64(error_slot_offset, slot0);
            call.ret_u64(error_slot_offset + 1, slot1);
            return ExternResult::Ok;
        }};
    }
    
    // 1. Check nil
    if interface::is_nil(base_slot0) {
        return_error!(DynErr::NilBase, "cannot call nil");
    }
    
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // 2. Protocol-first: check if type implements CallObject
    if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().call_object_iface_id) {
        return dyn_call_via_protocol(
            call, base_slot1, rttid, vk, iface_id, args_slice_ref,
            expected_ret_count, metas_start, is_any_start, error_slot_offset,
        );
    }
    
    // 3. Fallback: check if it's a closure
    if vk != ValueKind::Closure {
        return_error!(DynErr::BadCall, &format!("cannot call non-function type {:?}", vk));
    }
    
    // 4. Closure call path
    dyn_call_closure_impl(
        call, base_slot1 as GcRef, rttid, args_slice_ref,
        expected_ret_count, metas_start, is_any_start, error_slot_offset,
    )
}

/// Compute the error slot offset for dyn_call based on expected return types.
fn compute_dyn_call_error_offset(
    call: &ExternCallContext,
    expected_ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
) -> u16 {
    let mut offset: u16 = 0;
    for i in 0..expected_ret_count {
        let meta_raw = call.arg_u64(metas_start + i as u16) as u32;
        let is_any = call.arg_u64(is_any_start + i as u16) != 0;
        let rttid = meta_raw >> 8;
        let vk = ValueKind::from_u8((meta_raw & 0xFF) as u8);
        let width = match vk {
            ValueKind::Interface => 2,
            ValueKind::Struct | ValueKind::Array => call.get_type_slot_count(rttid) as usize,
            _ => 1,
        };
        offset += dyn_call_output_slots(is_any, vk, width);
    }
    offset
}

/// Calculate output slot count for a return value in dyn_call.
#[inline]
fn dyn_call_output_slots(is_any: bool, vk: ValueKind, width: usize) -> u16 {
    if is_any {
        2
    } else if (vk == ValueKind::Struct || vk == ValueKind::Array) && width > 2 {
        2  // Large struct/array: (0, GcRef)
    } else {
        width.min(2) as u16
    }
}

/// Call via CallObject protocol: DynCall(args []any) (any, error)
fn dyn_call_via_protocol(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    call_iface_id: u32,
    args_slice_ref: GcRef,
    expected_ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
    error_slot_offset: u16,
) -> ExternResult {
    // Helper macro to return error
    macro_rules! return_error {
        ($err:expr, $msg:expr) => {{
            for i in 0..error_slot_offset {
                call.ret_u64(i, 0);
            }
            let (cause0, cause1) = dyn_sentinel_error(call, $err.into());
            let (slot0, slot1) = create_error_with_cause(call, $msg, cause0, cause1);
            call.ret_u64(error_slot_offset, slot0);
            call.ret_u64(error_slot_offset + 1, slot1);
            return ExternResult::Ok;
        }};
    }
    
    // Protocol only supports single return
    if expected_ret_count > 1 {
        return_error!(DynErr::SigMismatch, "CallObject protocol only supports single return value");
    }
    
    // Get named_type_id and create itab
    let named_type_id = match call.get_named_type_id_from_rttid(rttid, true) {
        Some(id) => id,
        None => return_error!(DynErr::BadCall, "type has no methods"),
    };
    
    let src_is_pointer = vk == ValueKind::Pointer;
    let itab_id = match call.try_get_or_create_itab(named_type_id, call_iface_id, src_is_pointer) {
        Some(id) => id,
        None => return_error!(DynErr::BadCall, "failed to create itab for CallObject"),
    };
    
    let itab = match call.get_itab(itab_id) {
        Some(t) => t,
        None => return_error!(DynErr::BadCall, "invalid itab"),
    };
    
    // DynCall is method index 0 in CallObject interface
    let func_id = match itab.methods.first() {
        Some(&id) => id,
        None => return_error!(DynErr::BadCall, "CallObject has no methods"),
    };
    
    // Create closure and call
    use crate::objects::closure;
    let closure_ref = closure::create(call.gc(), func_id, 0);
    
    // Prepare args: receiver (base_slot1) + args_slice
    let args = [base_slot1, args_slice_ref as u64];
    
    // Call returns (any[2], error[2]) = 4 slots
    let mut ret_buffer = vec![0u64; 4];
    
    if let Err(msg) = call.call_closure(closure_ref, &args, &mut ret_buffer) {
        return_error!(DynErr::BadCall, &msg);
    }
    
    // ret_buffer: [any_slot0, any_slot1, error_slot0, error_slot1]
    let result_slot0 = ret_buffer[0];
    let result_slot1 = ret_buffer[1];
    let proto_error_slot0 = ret_buffer[2];
    let proto_error_slot1 = ret_buffer[3];
    
    // Check protocol error
    if proto_error_slot0 != 0 || proto_error_slot1 != 0 {
        // Propagate protocol error
        for i in 0..error_slot_offset {
            call.ret_u64(i, 0);
        }
        call.ret_u64(error_slot_offset, proto_error_slot0);
        call.ret_u64(error_slot_offset + 1, proto_error_slot1);
        return ExternResult::Ok;
    }
    
    // Unbox result to expected type
    if expected_ret_count == 0 {
        // No return expected, just return nil error
        call.ret_nil(error_slot_offset);
        call.ret_nil(error_slot_offset + 1);
    } else {
        // Single return expected
        let meta_raw = call.arg_u64(metas_start) as u32;
        let is_any = call.arg_u64(is_any_start) != 0;
        let expected_rttid = meta_raw >> 8;
        let expected_vk = ValueKind::from_u8((meta_raw & 0xFF) as u8);
        
        unbox_protocol_result(
            call, result_slot0, result_slot1,
            expected_rttid, expected_vk, is_any,
            0, error_slot_offset,
        );
    }
    
    ExternResult::Ok
}

/// Unbox protocol result (any) to expected type.
fn unbox_protocol_result(
    call: &mut ExternCallContext,
    result_slot0: u64,
    result_slot1: u64,
    expected_rttid: u32,
    expected_vk: ValueKind,
    is_any: bool,
    dst_offset: u16,
    error_slot_offset: u16,
) {
    if is_any || expected_vk == ValueKind::Interface {
        // Expect any/interface: copy both slots
        call.ret_u64(dst_offset, result_slot0);
        call.ret_u64(dst_offset + 1, result_slot1);
        call.ret_nil(error_slot_offset);
        call.ret_nil(error_slot_offset + 1);
        return;
    }
    
    // Type check
    let got_vk = interface::unpack_value_kind(result_slot0);
    let got_rttid = interface::unpack_rttid(result_slot0);
    
    // Allow nil for pointer/reference types
    if interface::is_nil(result_slot0) {
        match expected_vk {
            ValueKind::Pointer | ValueKind::Slice | ValueKind::Map | 
            ValueKind::String | ValueKind::Closure | ValueKind::Channel => {
                call.ret_u64(dst_offset, 0);
                call.ret_nil(error_slot_offset);
                call.ret_nil(error_slot_offset + 1);
                return;
            }
            _ => {}
        }
    }
    
    // Check type compatibility
    let type_ok = if expected_rttid == 0 {
        // Only check ValueKind
        got_vk == expected_vk
    } else {
        got_vk == expected_vk && got_rttid == expected_rttid
    };
    
    if !type_ok {
        // Type mismatch - return error
        for i in 0..error_slot_offset {
            call.ret_u64(i, 0);
        }
        let msg = format!(
            "type assertion failed: expected {:?} (rttid {}), got {:?} (rttid {})",
            expected_vk, expected_rttid, got_vk, got_rttid
        );
        write_error_to(call, error_slot_offset, &msg);
        return;
    }
    
    // Unbox value
    let width = match expected_vk {
        ValueKind::Struct | ValueKind::Array => call.get_type_slot_count(expected_rttid) as usize,
        _ => 1,
    };
    
    if width == 1 {
        call.ret_u64(dst_offset, result_slot1);
    } else if width == 2 {
        // 2-slot type stored directly in interface
        call.ret_u64(dst_offset, result_slot0);
        call.ret_u64(dst_offset + 1, result_slot1);
    } else {
        // Large struct/array: result_slot1 is GcRef, return as (0, GcRef)
        call.ret_u64(dst_offset, 0);
        call.ret_u64(dst_offset + 1, result_slot1);
    }
    
    call.ret_nil(error_slot_offset);
    call.ret_nil(error_slot_offset + 1);
}

/// Closure call implementation for dyn_call.
fn dyn_call_closure_impl(
    call: &mut ExternCallContext,
    closure_ref: GcRef,
    closure_sig_rttid: u32,
    args_slice_ref: GcRef,
    expected_ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
    error_slot_offset: u16,
) -> ExternResult {
    use crate::objects::closure;
    
    // Helper macro to return error
    macro_rules! return_error {
        ($msg:expr) => {{
            for i in 0..error_slot_offset {
                call.ret_u64(i, 0);
            }
            write_error_to(call, error_slot_offset, $msg);
            return ExternResult::Ok;
        }};
    }
    
    if !call.can_call_closure() {
        return_error!("closure calling not available");
    }
    if closure_ref.is_null() {
        return_error!("closure is null");
    }
    
    // Get function signature
    let (params, ret_value_rttids, is_variadic) = match call.get_func_signature(closure_sig_rttid) {
        Some((p, r, v)) => (p.clone(), r.clone(), v),
        None => return_error!("invalid closure signature"),
    };
    
    // Check return count mismatch
    let actual_ret_count = ret_value_rttids.len();
    if expected_ret_count != actual_ret_count {
        for i in 0..error_slot_offset {
            call.ret_u64(i, 0);
        }
        let msg = format!(
            "return count mismatch: expected {} return value(s), function returns {} (hint: adjust LHS variable count to match function signature)",
            expected_ret_count, actual_ret_count
        );
        let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
        let (slot0, slot1) = create_error_with_cause(call, &msg, cause0, cause1);
        call.ret_u64(error_slot_offset, slot0);
        call.ret_u64(error_slot_offset + 1, slot1);
        return ExternResult::Ok;
    }
    
    // Check parameter count mismatch
    let arg_count = if args_slice_ref.is_null() { 0 } else { slice::len(args_slice_ref) as usize };
    let expected_param_count = if is_variadic && !params.is_empty() {
        params.len() - 1  // Non-variadic params count
    } else {
        params.len()
    };
    
    if !is_variadic {
        // Non-variadic: exact match required
        if arg_count != expected_param_count {
            for i in 0..error_slot_offset {
                call.ret_u64(i, 0);
            }
            let msg = format!(
                "parameter count mismatch: expected {} argument(s), got {}",
                expected_param_count, arg_count
            );
            let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
            let (slot0, slot1) = create_error_with_cause(call, &msg, cause0, cause1);
            call.ret_u64(error_slot_offset, slot0);
            call.ret_u64(error_slot_offset + 1, slot1);
            return ExternResult::Ok;
        }
    } else {
        // Variadic: at least non-variadic params required
        if arg_count < expected_param_count {
            for i in 0..error_slot_offset {
                call.ret_u64(i, 0);
            }
            let msg = format!(
                "parameter count mismatch: expected at least {} argument(s), got {}",
                expected_param_count, arg_count
            );
            let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
            let (slot0, slot1) = create_error_with_cause(call, &msg, cause0, cause1);
            call.ret_u64(error_slot_offset, slot0);
            call.ret_u64(error_slot_offset + 1, slot1);
            return ExternResult::Ok;
        }
    }
    
    // Unpack args from []any slice and repack for closure
    let args = match unpack_args_for_closure(call, args_slice_ref, &params, is_variadic) {
        Ok(a) => a,
        Err(_) => {
            // Type mismatch during argument unpacking
            for i in 0..error_slot_offset {
                call.ret_u64(i, 0);
            }
            let (cause0, cause1) = dyn_sentinel_error(call, DynErr::SigMismatch.into());
            let (slot0, slot1) = create_error_with_cause(call, "argument type mismatch", cause0, cause1);
            call.ret_u64(error_slot_offset, slot0);
            call.ret_u64(error_slot_offset + 1, slot1);
            return ExternResult::Ok;
        },
    };
    
    // Get function def and call
    let func_id = closure::func_id(closure_ref);
    let func_def = match call.get_func_def(func_id) {
        Some(fd) => fd,
        None => return_error!("function not found"),
    };
    let actual_ret_slots = func_def.ret_slots as usize;
    
    let mut ret_buffer = vec![0u64; actual_ret_slots];
    if let Err(msg) = call.call_closure(closure_ref, &args, &mut ret_buffer) {
        return_error!(&msg);
    }
    
    // Unpack return values to LHS format
    unpack_closure_returns(
        call, &ret_buffer, &ret_value_rttids,
        expected_ret_count, metas_start, is_any_start, error_slot_offset,
    );
    
    ExternResult::Ok
}

/// Set a slice element from interface-format data.
fn set_slice_elem_from_interface(
    slice_ref: crate::gc::GcRef,
    idx: usize,
    arg_slot0: u64,
    arg_slot1: u64,
    elem_vk: ValueKind,
    elem_slots: u16,
    elem_bytes: usize,
) {
    if elem_vk == ValueKind::Interface || elem_slots == 2 {
        slice::set_n(slice_ref, idx, &[arg_slot0, arg_slot1], elem_bytes);
    } else if elem_slots == 1 {
        slice::set(slice_ref, idx, arg_slot1, elem_bytes);
    } else {
        let src_ref = arg_slot1 as crate::gc::GcRef;
        if !src_ref.is_null() {
            let mut vals = vec![0u64; elem_slots as usize];
            for j in 0..elem_slots as usize {
                vals[j] = unsafe { crate::gc::Gc::read_slot(src_ref, j) };
            }
            slice::set_n(slice_ref, idx, &vals, elem_bytes);
        }
    }
}

/// Unpack args from []any slice for closure call.
fn unpack_args_for_closure(
    call: &mut ExternCallContext,
    args_slice_ref: GcRef,
    params: &[vo_common_core::types::ValueRttid],
    is_variadic: bool,
) -> Result<Vec<u64>, ExternResult> {
    use vo_common_core::types::ValueMeta;
    
    let mut args = Vec::new();
    
    if args_slice_ref.is_null() {
        // No args - check if that's valid
        if !params.is_empty() && !is_variadic {
            // Need args but none provided - will fail at call time
        }
        return Ok(args);
    }
    
    let arg_count = slice::len(args_slice_ref) as usize;
    let elem_bytes = array::elem_bytes(slice::array_ref(args_slice_ref));
    
    // For variadic: non_variadic_count = params.len() - 1
    let non_variadic_count = if is_variadic && !params.is_empty() {
        params.len() - 1
    } else {
        params.len()
    };
    
    // Unpack non-variadic args
    for i in 0..non_variadic_count.min(arg_count) {
        let param = &params[i];
        let param_vk = param.value_kind();
        let param_rttid = param.rttid();
        let param_slots = call.get_type_slot_count(param_rttid) as usize;
        
        // Read interface-format arg from slice (each element is 2 slots = 16 bytes)
        let base_ptr = slice::data_ptr(args_slice_ref);
        let elem_ptr = unsafe { base_ptr.add(i * elem_bytes) };
        let arg_slot0 = unsafe { *(elem_ptr as *const u64) };
        let arg_slot1 = if elem_bytes >= 16 {
            unsafe { *((elem_ptr as *const u64).add(1)) }
        } else {
            0
        };
        
        // Type check: verify arg type matches param type (unless param is interface/any)
        if param_vk != ValueKind::Interface {
            let arg_vk = interface::unpack_value_kind(arg_slot0);
            let arg_rttid = interface::unpack_rttid(arg_slot0);
            
            // Allow nil for pointer/reference types
            if interface::is_nil(arg_slot0) {
                if matches!(param_vk, 
                    ValueKind::Pointer | ValueKind::Slice | ValueKind::Map | 
                    ValueKind::String | ValueKind::Closure | ValueKind::Channel) {
                    // nil is valid for these types
                } else {
                    return Err(ExternResult::Ok); // nil not valid for value types
                }
            } else {
                // Check ValueKind compatibility
                if arg_vk != param_vk {
                    return Err(ExternResult::Ok); // Type mismatch
                }
                
                // For composite types, also check rttid to catch e.g. []int vs []string
                if matches!(param_vk, ValueKind::Struct | ValueKind::Array | 
                           ValueKind::Slice | ValueKind::Map | ValueKind::Pointer) {
                    if arg_rttid != param_rttid {
                        return Err(ExternResult::Ok); // Type mismatch
                    }
                }
            }
        }
        
        // Unbox to param type
        if param_vk == ValueKind::Interface {
            args.push(arg_slot0);
            args.push(arg_slot1);
        } else if param_slots == 1 {
            args.push(arg_slot1);
        } else {
            // Multi-slot: arg_slot1 is GcRef to boxed data
            let src_ref = arg_slot1 as GcRef;
            for j in 0..param_slots {
                let val = if !src_ref.is_null() {
                    unsafe { Gc::read_slot(src_ref, j) }
                } else { 0 };
                args.push(val);
            }
        }
    }
    
    // Handle variadic args
    if is_variadic && !params.is_empty() {
        let variadic_param = params.last().unwrap();
        let variadic_slice_rttid = variadic_param.rttid();
        
        // Get variadic element type
        let elem_vr = match call.get_slice_elem(variadic_slice_rttid) {
            Some(vr) => vr,
            None => return Ok(args), // Error will be caught at call time
        };
        let elem_vk = elem_vr.value_kind();
        let elem_slots = call.get_type_slot_count(elem_vr.rttid()) as usize;
        let elem_meta = ValueMeta::new(elem_vr.rttid(), elem_vk);
        
        // Remaining args become the variadic slice
        let variadic_count = arg_count.saturating_sub(non_variadic_count);
        if variadic_count == 0 {
            // Empty variadic slice
            args.push(core::ptr::null::<u8>() as u64);
        } else {
            // Create new slice for variadic args
            let new_slice = slice::create(call.gc(), elem_meta, elem_slots * 8, variadic_count, variadic_count);
            for i in 0..variadic_count {
                let src_idx = non_variadic_count + i;
                let base_ptr = slice::data_ptr(args_slice_ref);
                let elem_ptr = unsafe { base_ptr.add(src_idx * elem_bytes) };
                let arg_slot0 = unsafe { *(elem_ptr as *const u64) };
                let arg_slot1 = if elem_bytes >= 16 {
                    unsafe { *((elem_ptr as *const u64).add(1)) }
                } else {
                    0
                };
                
                set_slice_elem_from_interface(new_slice, i, arg_slot0, arg_slot1, elem_vk, elem_slots as u16, elem_slots * 8);
            }
            args.push(new_slice as u64);
        }
    }
    
    Ok(args)
}

/// Unpack closure returns to LHS format.
fn unpack_closure_returns(
    call: &mut ExternCallContext,
    ret_buffer: &[u64],
    ret_value_rttids: &[vo_common_core::types::ValueRttid],
    expected_ret_count: usize,
    metas_start: u16,
    is_any_start: u16,
    error_slot_offset: u16,
) {
    let mut src_off = 0usize;
    let mut ret_off: u16 = 0;
    
    for i in 0..expected_ret_count {
        let expected_meta_raw = call.arg_u64(metas_start + i as u16) as u32;
        let is_any = call.arg_u64(is_any_start + i as u16) != 0;
        let expected_rttid = expected_meta_raw >> 8;
        let expected_vk = ValueKind::from_u8((expected_meta_raw & 0xFF) as u8);
        
        // Get actual return type from closure signature
        let (actual_rttid, actual_vk, actual_width) = if i < ret_value_rttids.len() {
            let vr = &ret_value_rttids[i];
            let rttid = vr.rttid();
            let vk = vr.value_kind();
            let width = match vk {
                ValueKind::Interface => 2,
                ValueKind::Struct | ValueKind::Array => call.get_type_slot_count(rttid) as usize,
                _ => 1,
            };
            (rttid, vk, width)
        } else {
            // More expected returns than actual - use zeros
            (0, ValueKind::Int, 1)
        };
        
        let raw_slots = if src_off + actual_width <= ret_buffer.len() {
            &ret_buffer[src_off..src_off + actual_width]
        } else {
            &[][..]
        };
        src_off += actual_width;
        
        let output_slots = dyn_call_output_slots(is_any, expected_vk, actual_width);
        
        if is_any {
            // Box to interface
            let boxed = call.box_to_interface(actual_rttid, actual_vk, raw_slots);
            call.ret_u64(ret_off, boxed.slot0);
            call.ret_u64(ret_off + 1, boxed.slot1);
        } else if (expected_vk == ValueKind::Struct || expected_vk == ValueKind::Array) && actual_width > 2 {
            // Large struct/array: allocate and copy
            let new_ref = call.alloc_and_copy_slots(raw_slots);
            call.ret_u64(ret_off, 0);
            call.ret_u64(ret_off + 1, new_ref as u64);
        } else {
            // Direct copy
            call.ret_u64(ret_off, raw_slots.get(0).copied().unwrap_or(0));
            if output_slots > 1 {
                call.ret_u64(ret_off + 1, raw_slots.get(1).copied().unwrap_or(0));
            }
        }
        
        ret_off += output_slots;
    }
    
    call.ret_nil(error_slot_offset);
    call.ret_nil(error_slot_offset + 1);
}

// ============================================================================
// Unified dyn_method extern
// ============================================================================

/// dyn_method: Unified dynamic method call with protocol-first dispatch.
///
/// Combines getting the method (via AttrObject protocol or reflection) and calling it.
/// This is equivalent to `a~>method(args)`.
///
/// Args: (base[2], method_name[1], args_slice[1], expected_ret_count[1], expected_metas[N], is_any_flags[N])
/// - base[2]: the receiver value as interface
/// - method_name[1]: GcRef to string containing method name
/// - args_slice[1]: GcRef to []any slice containing packed arguments
/// - expected_ret_count[1]: number of expected return values (from LHS)
/// - expected_metas[N]: ValueRttid raw values for each expected return
/// - is_any_flags[N]: 1 if LHS expects any, 0 otherwise
///
/// Returns: (results[variable], error[2])
fn dyn_method(call: &mut ExternCallContext) -> ExternResult {
    let base_slot0 = call.arg_u64(0);
    let base_slot1 = call.arg_u64(1);
    let method_name_ref = call.arg_u64(2) as GcRef;
    let args_slice_ref = call.arg_u64(3) as GcRef;
    let expected_ret_count = call.arg_u64(4) as usize;
    let metas_start = 5u16;
    let is_any_start = metas_start + expected_ret_count as u16;
    
    // Calculate error slot offset based on expected return types
    let error_slot_offset = compute_dyn_call_error_offset(call, expected_ret_count, metas_start, is_any_start);
    
    // Helper macro to return error
    macro_rules! return_error {
        ($err:expr, $msg:expr) => {{
            for i in 0..error_slot_offset {
                call.ret_u64(i, 0);
            }
            let (cause0, cause1) = dyn_sentinel_error(call, $err.into());
            let (slot0, slot1) = create_error_with_cause(call, $msg, cause0, cause1);
            call.ret_u64(error_slot_offset, slot0);
            call.ret_u64(error_slot_offset + 1, slot1);
            return ExternResult::Ok;
        }};
    }
    
    // 1. Check nil
    if interface::is_nil(base_slot0) {
        return_error!(DynErr::NilBase, "cannot call method on nil");
    }
    
    // Get method name string
    let method_name = crate::objects::string::as_str(method_name_ref);
    
    let vk = interface::unpack_value_kind(base_slot0);
    let rttid = interface::unpack_rttid(base_slot0);
    
    // 2. Protocol-first: check if type implements AttrObject to get method
    let method_closure: Option<(u64, u64)> = if let Some(iface_id) = check_protocol(call, rttid, vk, call.well_known().attr_object_iface_id) {
        match call_dyn_attr_protocol_for_method(call, base_slot1, rttid, vk, iface_id, method_name) {
            Ok((slot0, slot1)) => Some((slot0, slot1)),
            Err((err, msg)) => {
                return_error!(err, msg);
            }
        }
    } else {
        None
    };
    
    // 3. Fallback to reflection if protocol not available
    let (closure_slot0, closure_slot1) = if let Some((s0, s1)) = method_closure {
        (s0, s1)
    } else {
        // Try reflection: get method from struct
        match get_method_by_reflection(call, base_slot0, base_slot1, rttid, vk, method_name) {
            Ok((s0, s1)) => (s0, s1),
            Err(msg) => {
                return_error!(DynErr::BadField, msg);
            }
        }
    };
    
    // 4. Check if we got a valid closure
    let closure_vk = interface::unpack_value_kind(closure_slot0);
    if closure_vk != ValueKind::Closure {
        return_error!(DynErr::BadCall, &format!("{} is not a callable method", method_name));
    }
    
    let closure_rttid = interface::unpack_rttid(closure_slot0);
    let closure_ref = closure_slot1 as GcRef;
    
    // 5. Call the closure
    dyn_call_closure_impl(
        call, closure_ref, closure_rttid, args_slice_ref,
        expected_ret_count, metas_start, is_any_start, error_slot_offset,
    )
}

/// Helper: call AttrObject.DynAttr protocol method to get a method closure.
fn call_dyn_attr_protocol_for_method(
    call: &mut ExternCallContext,
    base_slot1: u64,
    rttid: u32,
    vk: ValueKind,
    attr_iface_id: u32,
    method_name: &str,
) -> Result<(u64, u64), (DynErr, &'static str)> {
    let func_id = get_protocol_func_id(call, rttid, vk, attr_iface_id, DynErr::BadField)?;
    let name_ref = call.alloc_str(method_name);
    let ret = call_protocol_method::<4>(call, func_id, &[base_slot1, name_ref as u64], DynErr::BadField)?;
    Ok((ret[0], ret[1]))
}

/// Helper: get method by reflection (for types without AttrObject protocol).
/// Reuses the same logic as try_get_method but returns Result.
fn get_method_by_reflection(
    call: &mut ExternCallContext,
    _base_slot0: u64,
    base_slot1: u64,
    rttid: u32,
    _vk: ValueKind,
    method_name: &str,
) -> Result<(u64, u64), &'static str> {
    use crate::objects::closure;
    
    // Lookup method by name - returns (func_id, is_pointer_receiver, signature_rttid)
    let (func_id, _is_pointer_receiver, signature_rttid) = match call.lookup_method(rttid, method_name) {
        Some(info) => info,
        None => return Err("method not found"),
    };
    
    // Create closure with receiver as capture
    let closure_ref = closure::create(call.gc(), func_id, 1);
    closure::set_capture(closure_ref, 0, base_slot1);
    
    // Return as interface format (meta, GcRef)
    let result_slot0 = interface::pack_slot0(0, signature_rttid, ValueKind::Closure);
    Ok((result_slot0, closure_ref as u64))
}

/// Register dynamic extern functions (for no_std mode).
/// Note: dynamic functions use ExternCallContext directly, not wrapper functions.
pub fn register_externs(registry: &mut crate::ffi::ExternRegistry, externs: &[crate::bytecode::ExternDef]) {
    use crate::ffi::ExternFnWithContext;
    
    // Dynamic functions take ExternCallContext directly - no wrapper needed
    const TABLE: &[(&str, ExternFnWithContext)] = &[
        ("dyn_getDynErrors", get_dyn_errors),
        ("dyn_field", dyn_field),  // Unified field access
        ("dyn_index", dyn_index),  // Unified index access
        ("dyn_set_field", dyn_set_field),  // Unified field set
        ("dyn_set_index_unified", dyn_set_index_unified),  // Unified index set
        ("dyn_call", dyn_call),  // Unified call (protocol + closure)
        ("dyn_method", dyn_method),  // Unified method call
        ("dyn_pack_any_slice", dyn_pack_any_slice),  // Used by dyn_call/dyn_method codegen
        ("dyn_type_assert_error", dyn_type_assert_error),
        // User API: dyn.GetAttr/GetIndex/SetAttr/SetIndex - always return (any, error)
        ("dyn_GetAttr", dyn_get_attr),
        ("dyn_GetIndex", dyn_get_index),
        ("dyn_SetAttr", dyn_set_attr),
        ("dyn_SetIndex", dyn_set_index),
    ];
    
    for (id, def) in externs.iter().enumerate() {
        for (name, func) in TABLE {
            if def.name == *name {
                registry.register_with_context(id as u32, *func);
                break;
            }
        }
    }
}

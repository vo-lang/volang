// IDE action handlers (state mutations).
package studio

import (
	"encoding/json"
	"vox"
	"vogui"
)

// stopRunningGuest stops any active guest VM and clears its state.
func stopRunningGuest(s *State) {
	if s.GuestModule != nil {
		vox.StopGui(s.GuestModule)
		s.GuestModule = nil
		s.GuestRender = ""
	}
}

// onEditorChange updates file content when the CodeMirror widget reports a change.
func onEditorChange(state any, payload string) {
	s := state.(*State)
	if s.ActiveFile >= 0 && s.ActiveFile < len(s.Files) {
		s.Files[s.ActiveFile].Content = payload
	}
}

// onExplorerEvent handles events from the file-explorer ExternalWidget.
// Use vogui.ParseFileExplorerEvent to decode the payload into a typed struct.
func onExplorerEvent(state any, payload string) {
	s := state.(*State)
	evt, err := vogui.ParseFileExplorerEvent(payload)
	if err != nil {
		return
	}
	switch evt.Type {
	case vogui.FileExplorerOpen, vogui.FileExplorerCreate:
		stopRunningGuest(s)
		for i, f := range s.Files {
			if f.Path == evt.Path {
				s.Files[i].Content = evt.Content
				s.ActiveFile = i
				return
			}
		}
		s.Files = append(s.Files, FileEntry{Path: evt.Path, Content: evt.Content})
		s.ActiveFile = len(s.Files) - 1

	case vogui.FileExplorerRename:
		for i, f := range s.Files {
			if f.Path == evt.OldPath {
				s.Files[i].Path = evt.Path
				if s.ActiveFile == i {
					// active file path stays in sync
				}
				return
			}
		}

	case vogui.FileExplorerDelete:
		for i, f := range s.Files {
			if f.Path == evt.Path {
				s.Files = append(s.Files[:i], s.Files[i+1:]...)
				if s.ActiveFile == i {
					s.ActiveFile = -1
				} else if s.ActiveFile > i {
					s.ActiveFile--
				}
				return
			}
		}
	}
}

// runCode compiles and runs the current file.
func runCode(state any) {
	s := state.(*State)
	if s.ActiveFile < 0 || s.ActiveFile >= len(s.Files) {
		return
	}
	code := s.Files[s.ActiveFile].Content
	s.Output = ""
	s.GuestRender = ""

	m, err := vox.CompileString(code)
	if err != nil {
		s.Output = "Compile error:\n" + err.Error()
		return
	}

	output, err := vox.RunCapture(m)
	if err != nil {
		s.Output = output + "\nRun error:\n" + err.Error()
	} else {
		s.Output = output
	}
	vox.Free(m)
}

// runGui compiles the current file as a vogui app and launches it.
func runGui(state any) {
	s := state.(*State)
	if s.ActiveFile < 0 || s.ActiveFile >= len(s.Files) {
		return
	}
	code := s.Files[s.ActiveFile].Content

	stopRunningGuest(s)

	m, err := vox.CompileString(code)
	if err != nil {
		s.Output = "Compile error:\n" + err.Error()
		return
	}

	render, err := vox.RunGui(m)
	if err != nil {
		s.Output = "GUI error:\n" + err.Error()
		vox.Free(m)
		return
	}

	s.GuestModule = m
	s.GuestRender = render
	s.Output = ""
	s.Mode = "split"
}

// sendGuestEvent forwards a GUI event from the guest widget to the guest VM.
func sendGuestEvent(state any, payload string) {
	s := state.(*State)
	if s.GuestModule == nil {
		return
	}

	var eventData struct {
		HandlerID int    `json:"h"`
		Payload   string `json:"p"`
	}
	if err := json.Unmarshal([]byte(payload), &eventData); err != nil {
		s.Output = "Event decode error: " + err.Error()
		return
	}

	render, err := vox.SendGuiEvent(s.GuestModule, eventData.HandlerID, eventData.Payload)
	if err != nil {
		s.Output = "Guest event error: " + err.Error()
		return
	}
	s.GuestRender = render
}

// stopGuest stops the running guest app.
func stopGuest(state any) {
	s := state.(*State)
	stopRunningGuest(s)
	s.Mode = "code"
}

// setModeIdx changes the layout mode by integer index (0=code, 1=split, 2=preview).
func setModeIdx(state any, idx int) {
	s := state.(*State)
	modes := []string{"code", "split", "preview"}
	if idx >= 0 && idx < len(modes) {
		s.Mode = modes[idx]
	}
}


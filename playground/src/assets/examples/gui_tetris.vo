// Tetris Game - VoGUI v2
package main

import (
	"fmt"
	"vogui"
)

// ============ Constants ============

const Rows = 20
const Cols = 10
const CellSize = 25

// ============ Types ============

type Point struct {
	X int
	Y int
}

type Piece struct {
	Type  int // 0-6: I, J, L, O, S, T, Z
	Rot   int // 0-3
	X     int
	Y     int
	Cells []Point // Relative coordinates
}

type State struct {
	Grid      []int // Rows * Cols, 0=empty, >0=colorIndex
	Score     int
	Level     int
	GameOver  bool
	Paused    bool
	Current   Piece
	TimerID   int
	TickCount int
    RngState  int
}

var pieceColors = []string{
	"#1a1a2e", "#00f0f0", "#0000f0", "#f0a000",
	"#f0f000", "#00f000", "#a000f0", "#f00000",
}

// Shapes: [Type][Rotation][4 cells]
// Coordinates are relative to pivot
// I: Type 0
var shapeI = []Point{Point{-1, 0}, Point{0, 0}, Point{1, 0}, Point{2, 0}}
// J: Type 1
var shapeJ = []Point{Point{-1, -1}, Point{-1, 0}, Point{0, 0}, Point{1, 0}}
// L: Type 2
var shapeL = []Point{Point{1, -1}, Point{-1, 0}, Point{0, 0}, Point{1, 0}}
// O: Type 3
var shapeO = []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{1, 1}}
// S: Type 4
var shapeS = []Point{Point{0, 0}, Point{1, 0}, Point{-1, 1}, Point{0, 1}}
// T: Type 5
var shapeT = []Point{Point{0, 0}, Point{-1, 0}, Point{1, 0}, Point{0, -1}}
// Z: Type 6
var shapeZ = []Point{Point{-1, 0}, Point{0, 0}, Point{0, 1}, Point{1, 1}}

// ============ App ============

func main() {
	vogui.SetGlobalKeyHandler(handleKey)
	vogui.Run(vogui.App{
		Init: initGame,
		View: view,
	})
}

func initGame() any {
	s := &State{
		Grid:     make([]int, Rows*Cols),
		Score:    0,
		Level:    1,
		GameOver: false,
		Paused:   false,
        RngState: 12345, // Seed
	}
	spawnPiece(s)
	// Start timer: 500ms
	s.TimerID = vogui.SetInterval(func(state any) {
		tick(state.(*State))
	}, 500)
	return s
}

// ============ Update Logic ============

func tick(s *State) {
	if s.GameOver || s.Paused {
		return
	}
	
	// Move down
	if canMove(s, s.Current, 0, 1) {
		s.Current.Y++
	} else {
		lockPiece(s)
		clearLines(s)
		spawnPiece(s)
		if !canMove(s, s.Current, 0, 0) {
			s.GameOver = true
		}
	}
}

func handleKey(state any, key string) {
	s := state.(*State)
	if s.GameOver {
        if key == "Enter" {
            restart(s)
        }
		return
	}
    
    if key == "p" || key == "P" {
        s.Paused = !s.Paused
        return
    }

	if s.Paused {
		return
	}

	switch key {
	case "ArrowLeft":
		if canMove(s, s.Current, -1, 0) {
			s.Current.X--
		}
	case "ArrowRight":
		if canMove(s, s.Current, 1, 0) {
			s.Current.X++
		}
	case "ArrowDown":
		if canMove(s, s.Current, 0, 1) {
			s.Current.Y++
		}
	case "ArrowUp":
		rotatePiece(s)
    case " ":
        dropPiece(s)
	}
}

func restart(s *State) {
    s.Grid = make([]int, Rows*Cols)
    s.Score = 0
    s.Level = 1
    s.GameOver = false
    s.Paused = false
    spawnPiece(s)
}

func spawnPiece(s *State) {
    // Random type 0-6
    t := rand(s) % 7
    s.Current = Piece{
        Type: t,
        Rot: 0,
        X: Cols / 2 - 1,
        Y: 0,
        Cells: getCells(t, 0),
    }
}

func getCells(t int, rot int) []Point {
    var base []Point
    if t == 0 { base = shapeI }
    if t == 1 { base = shapeJ }
    if t == 2 { base = shapeL }
    if t == 3 { base = shapeO }
    if t == 4 { base = shapeS }
    if t == 5 { base = shapeT }
    if t == 6 { base = shapeZ }
    
    // Rotate
    cells := make([]Point, 4)
    for i, p := range base {
        x, y := p.X, p.Y
        for r := 0; r < rot; r++ {
            // Rotate 90 deg clockwise: (x, y) -> (-y, x)
            x, y = -y, x
        }
        cells[i] = Point{x, y}
    }
    return cells
}

func rotatePiece(s *State) {
    newRot := (s.Current.Rot + 1) % 4
    newCells := getCells(s.Current.Type, newRot)
    
    // Test if valid
    p := s.Current
    p.Rot = newRot
    p.Cells = newCells
    
    if canMove(s, p, 0, 0) {
        s.Current = p
    } else {
        // Wall kicks (simple)
        if canMove(s, p, 1, 0) {
            s.Current = p
            s.Current.X++
        } else if canMove(s, p, -1, 0) {
            s.Current = p
            s.Current.X--
        }
    }
}

func canMove(s *State, p Piece, dx int, dy int) bool {
    for _, cell := range p.Cells {
        nx := p.X + cell.X + dx
        ny := p.Y + cell.Y + dy
        
        if nx < 0 || nx >= Cols || ny >= Rows {
            return false
        }
        if ny >= 0 {
            idx := ny*Cols + nx
            if s.Grid[idx] != 0 {
                return false
            }
        }
    }
    return true
}

func lockPiece(s *State) {
    c := s.Current.Type + 1
    for _, cell := range s.Current.Cells {
        nx := s.Current.X + cell.X
        ny := s.Current.Y + cell.Y
        if ny >= 0 && ny < Rows && nx >= 0 && nx < Cols {
            s.Grid[ny*Cols+nx] = c
        }
    }
}

func clearLines(s *State) {
    lines := 0
    for y := Rows - 1; y >= 0; y-- {
        full := true
        for x := 0; x < Cols; x++ {
            if s.Grid[y*Cols+x] == 0 {
                full = false
                break
            }
        }
        if full {
            lines++
            // Move lines down
            for ky := y; ky > 0; ky-- {
                for kx := 0; kx < Cols; kx++ {
                    s.Grid[ky*Cols+kx] = s.Grid[(ky-1)*Cols+kx]
                }
            }
            // Clear top line
            for kx := 0; kx < Cols; kx++ {
                s.Grid[kx] = 0
            }
            y++ // Recheck this line
        }
    }
    if lines > 0 {
        s.Score += lines * 100 * s.Level
    }
}

func dropPiece(s *State) {
    for canMove(s, s.Current, 0, 1) {
        s.Current.Y++
    }
    lockPiece(s)
    clearLines(s)
    spawnPiece(s)
    if !canMove(s, s.Current, 0, 0) {
        s.GameOver = true
    }
}

// Pseudo-random number generator
func rand(s *State) int {
    s.RngState = (s.RngState * 1103515245 + 12345) % 2147483648
    if s.RngState < 0 {
        s.RngState = -s.RngState
    }
    return s.RngState
}

// ============ View ============

func view(state any) vogui.Node {
	s := state.(*State)
	return vogui.Center(
		vogui.Column(
			vogui.Row(
				vogui.H2("TETRIS").Fg("#a000f0"),
				vogui.Spacer(),
				vogui.Column(
					vogui.Text("Score: "+fmt.Sprint(s.Score)).Font(16).Bold(),
					vogui.Text("Level: "+fmt.Sprint(s.Level)).Font(12).Fg("#666"),
				),
			).W(CellSize*Cols),
			renderGrid(s),
			vogui.Text("Arrows: move/rotate | Space: drop | P: pause").Font(12).Fg("#666"),
			vogui.Show(s.GameOver,
				vogui.Center(
					vogui.Column(
						vogui.H2("GAME OVER").Fg("#f00"),
						vogui.Text("Final Score: "+fmt.Sprint(s.Score)),
						vogui.Button("Restart (Enter)", vogui.On(func(s *State) { restart(s) })).
							Bg("#a000f0").Fg("#fff"),
					).P(20).Bg("rgba(0,0,0,0.8)").Rounded(10).Gap(12),
				).Style("position", "absolute").
					Style("top", "0").Style("left", "0").
					Style("right", "0").Style("bottom", "0"),
			),
		).Style("position", "relative").Gap(8),
	).P(24)
}

func renderGrid(s *State) vogui.Node {
	displayGrid := make([]int, Rows*Cols)
	copyGrid(displayGrid, s.Grid)
	if !s.GameOver {
		c := s.Current.Type + 1
		for _, cell := range s.Current.Cells {
			nx := s.Current.X + cell.X
			ny := s.Current.Y + cell.Y
			if ny >= 0 && ny < Rows && nx >= 0 && nx < Cols {
				displayGrid[ny*Cols+nx] = c
			}
		}
	}
	var cells []vogui.Node
	for i := 0; i < Rows*Cols; i++ {
		cells = append(cells,
			vogui.Div().
				W(CellSize).H(CellSize).
				Bg(pieceColors[displayGrid[i]]).
				Border("1px solid rgba(255,255,255,0.1)"),
		)
	}
	return vogui.Grid(Cols, cells...).Gap(0).Bg("#000").Border("2px solid #333")
}

func copyGrid(dst []int, src []int) {
	for i := 0; i < len(src); i++ {
		dst[i] = src[i]
	}
}

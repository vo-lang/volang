//! Vo Playground WASM - combines vo-web (system) and vogui (GUI library).

use std::cell::UnsafeCell;
use std::path::PathBuf;
use wasm_bindgen::prelude::*;
use vo_common::vfs::MemoryFs;
use vo_web::Vm;
use js_sys;

// Generated by build.rs: only the .vo source files from libs/vogui/ are embedded.
include!(concat!(env!("OUT_DIR"), "/vogui_files.rs"));

// =============================================================================
// Global State
// =============================================================================

struct GuiAppState {
    vm: Vm,
}

thread_local! {
    static GUI_STATE: UnsafeCell<Option<GuiAppState>> = UnsafeCell::new(None);
}

// =============================================================================
// Result Type
// =============================================================================

#[wasm_bindgen]
pub struct WasmGuiResult {
    status: String,
    render_bytes: Vec<u8>,
    error: String,
}

#[wasm_bindgen]
impl WasmGuiResult {
    #[wasm_bindgen(getter)]
    pub fn status(&self) -> String { self.status.clone() }

    #[wasm_bindgen(getter, js_name = "renderBytes")]
    pub fn render_bytes(&self) -> Vec<u8> { self.render_bytes.clone() }

    #[wasm_bindgen(getter)]
    pub fn error(&self) -> String { self.error.clone() }
}

impl WasmGuiResult {
    fn ok(render_bytes: Vec<u8>) -> Self {
        Self { status: "ok".into(), render_bytes, error: String::new() }
    }

    fn err(msg: impl Into<String>) -> Self {
        Self { status: "error".into(), render_bytes: Vec::new(), error: msg.into() }
    }

    fn compile_err(msg: impl Into<String>) -> Self {
        Self { status: "compile_error".into(), render_bytes: Vec::new(), error: msg.into() }
    }
}

// =============================================================================
// WASM API
// =============================================================================

/// Initialize a GUI app from source code.
#[wasm_bindgen(js_name = "initGuiApp")]
pub fn init_gui_app(source: &str, filename: Option<String>) -> WasmGuiResult {
    let filename = filename.unwrap_or_else(|| "main.vo".to_string());
    
    // Build combined filesystem: stdlib + vogui package
    let mut fs = vo_web::build_stdlib_fs();
    add_vogui_to_fs(&mut fs);
    
    // Compile
    let bytecode = match vo_web::compile_source_with_std_fs(source, &filename, fs) {
        Ok(b) => b,
        Err(e) => return WasmGuiResult::compile_err(e),
    };
    
    // Run
    run_gui_bytecode(&bytecode, vogui::register_externs)
}

/// Initialize a GUI app from pre-compiled bytecode.
#[wasm_bindgen(js_name = "initGuiAppBytecode")]
pub fn init_gui_app_bytecode(bytecode: &[u8]) -> WasmGuiResult {
    run_gui_bytecode(bytecode, vogui::register_externs)
}

/// Handle a GUI event.
#[wasm_bindgen(js_name = "handleGuiEvent")]
pub fn handle_gui_event(handler_id: i32, payload: &str) -> WasmGuiResult {
    handle_event(handler_id, payload)
}

// =============================================================================
// Core Implementation
// =============================================================================

fn run_gui_bytecode(
    bytecode: &[u8],
    registrar: fn(&mut vo_web::ExternRegistry, &[vo_web::ExternDef]),
) -> WasmGuiResult {
    #[cfg(target_arch = "wasm32")]
    vogui::set_platform(Box::new(vogui::WasmPlatform));

    GUI_STATE.with(|s| unsafe { *s.get() = None });
    vogui::clear_event_state();
    vogui::clear_pending_render();

    let vm = match vo_web::create_vm(bytecode, registrar) {
        Ok(vm) => vm,
        Err(e) => return WasmGuiResult::err(e),
    };

    // Flush any user println output to console
    let stdout = vo_web::take_output();
    if !stdout.is_empty() {
        for line in stdout.lines() {
            if !line.is_empty() {
                web_sys::console::log_1(&format!("[Vo] {}", line).into());
            }
        }
    }

    // Read render bytes from dedicated channel (not stdout)
    let render_bytes = match vogui::take_pending_render_bytes() {
        Some(b) if !b.is_empty() => b,
        _ => return WasmGuiResult::err("No render output. emitRenderBinary was not called."),
    };

    GUI_STATE.with(|s| unsafe {
        *s.get() = Some(GuiAppState { vm });
    });

    WasmGuiResult::ok(render_bytes)
}

fn handle_event(handler_id: i32, payload: &str) -> WasmGuiResult {
    GUI_STATE.with(|s| {
        // SAFETY: WASM is single-threaded. JS-side busy guard prevents reentrant calls.
        let state = unsafe { &mut *s.get() };
        let state = match state.as_mut() {
            Some(st) => st,
            None => return WasmGuiResult::err("GUI app not initialized"),
        };

        vogui::clear_pending_render();
        vo_runtime::output::clear_output();

        // Store event data and wake the blocked main fiber
        let token = match vogui::send_event(handler_id, payload.to_string()) {
            Some(t) => t,
            None => return WasmGuiResult::err("Main fiber not waiting for events"),
        };

        state.vm.scheduler.wake_host_event(token);
        if let Err(e) = state.vm.run_scheduled() {
            return WasmGuiResult::err(format!("{:?}", e));
        }

        // Flush any user println output to console
        let stdout = vo_web::take_output();
        if !stdout.is_empty() {
            for line in stdout.lines() {
                if !line.is_empty() {
                    web_sys::console::log_1(&format!("[Vo] {}", line).into());
                }
            }
        }

        // Read render bytes from dedicated channel
        let render_bytes = vogui::take_pending_render_bytes().unwrap_or_default();
        WasmGuiResult::ok(render_bytes)
    })
}

fn add_vogui_to_fs(fs: &mut MemoryFs) {
    for (vfs_path, bytes) in VOGUI_FILES {
        if let Ok(content) = std::str::from_utf8(bytes) {
            fs.add_file(PathBuf::from(vfs_path), content.to_string());
        }
    }
}

/// Initialize a GUI app that also imports third-party GitHub modules.
///
/// 1. Detects `import "github.com/..."` in source.
/// 2. Fetches Vo source files and pre-compiled .wasm binaries from GitHub.
/// 3. Compiles with stdlib + vogui + mod_fs.
/// 4. Runs as a GUI app with both vogui and ext-bridge extern registrars.
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen(js_name = "initGuiAppWithModules")]
pub fn init_gui_app_with_modules(source: &str) -> js_sys::Promise {
    let source = source.to_string();
    wasm_bindgen_futures::future_to_promise(async move {
        let result = init_gui_with_modules_inner(&source).await;
        let obj = js_sys::Object::new();
        js_sys::Reflect::set(&obj, &"status".into(), &result.status.into()).unwrap();
        let bytes = js_sys::Uint8Array::from(result.render_bytes.as_slice());
        js_sys::Reflect::set(&obj, &"renderBytes".into(), &bytes).unwrap();
        js_sys::Reflect::set(&obj, &"error".into(), &result.error.into()).unwrap();
        Ok(obj.into())
    })
}

#[cfg(target_arch = "wasm32")]
async fn init_gui_with_modules_inner(source: &str) -> WasmGuiResult {
    let (mod_fs, clean_source) = match vo_web::prepare_github_modules(source).await {
        Ok(v) => v,
        Err(e) => return WasmGuiResult::err(e),
    };

    let mut std_fs = vo_web::build_stdlib_fs();
    add_vogui_to_fs(&mut std_fs);

    let bytecode = match vo_web::compile_source_with_mod_fs(&clean_source, "main.vo", std_fs, mod_fs) {
        Ok(b) => b,
        Err(e) => return WasmGuiResult::compile_err(e),
    };

    run_gui_bytecode(&bytecode, register_gui_and_ext_bridges)
}

fn register_gui_and_ext_bridges(reg: &mut vo_web::ExternRegistry, externs: &[vo_web::ExternDef]) {
    vogui::register_externs(reg, externs);
    vo_web::ext_bridge::register_wasm_ext_bridges(reg, externs);
}

// Re-export vo-web functions (exposes them in the playground WASM JS API)
#[cfg(target_arch = "wasm32")]
pub use vo_web::compile_and_run_with_modules;
pub use vo_web::{compile_and_run, preload_ext_module, version, RunResult};

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_vogui_files_embedded() {
        assert!(VOGUI_FILES.len() > 0, "No .vo files embedded from vogui!");
        let has_app = VOGUI_FILES.iter().any(|(p, _)| *p == "vogui/app.vo");
        assert!(has_app, "vogui/app.vo not embedded");

        let mut fs = vo_common::vfs::MemoryFs::new();
        add_vogui_to_fs(&mut fs);

        use vo_common::vfs::FileSystem;
        assert!(fs.exists(std::path::Path::new("vogui/app.vo")), "vogui/app.vo not in fs");
    }
}

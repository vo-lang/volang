//! Vo Playground WASM - combines vo-web (system) and vogui (GUI library).

use std::cell::UnsafeCell;
use std::path::PathBuf;
use wasm_bindgen::prelude::*;
use vo_common::vfs::MemoryFs;
use vo_web::{Vm, GcRef};
use js_sys;

// Generated by build.rs: only the .vo source files from libs/vogui/ are embedded.
include!(concat!(env!("OUT_DIR"), "/vogui_files.rs"));

// =============================================================================
// Global State
// =============================================================================

struct GuiAppState {
    vm: Vm,
    event_handler: GcRef,
}

thread_local! {
    static GUI_STATE: UnsafeCell<Option<GuiAppState>> = UnsafeCell::new(None);
}

// =============================================================================
// Result Type
// =============================================================================

#[wasm_bindgen]
pub struct WasmGuiResult {
    status: String,
    render_json: String,
    error: String,
}

#[wasm_bindgen]
impl WasmGuiResult {
    #[wasm_bindgen(getter)]
    pub fn status(&self) -> String { self.status.clone() }
    
    #[wasm_bindgen(getter, js_name = "renderJson")]
    pub fn render_json(&self) -> String { self.render_json.clone() }
    
    #[wasm_bindgen(getter)]
    pub fn error(&self) -> String { self.error.clone() }
}

impl WasmGuiResult {
    fn ok(render_json: String) -> Self {
        Self { status: "ok".into(), render_json, error: String::new() }
    }
    
    fn err(msg: impl Into<String>) -> Self {
        Self { status: "error".into(), render_json: String::new(), error: msg.into() }
    }
    
    fn compile_err(msg: impl Into<String>) -> Self {
        Self { status: "compile_error".into(), render_json: String::new(), error: msg.into() }
    }
}

// =============================================================================
// WASM API
// =============================================================================

/// Initialize a GUI app from source code.
#[wasm_bindgen(js_name = "initGuiApp")]
pub fn init_gui_app(source: &str, filename: Option<String>) -> WasmGuiResult {
    let filename = filename.unwrap_or_else(|| "main.vo".to_string());
    
    // Build combined filesystem: stdlib + vogui package
    let mut fs = vo_web::build_stdlib_fs();
    add_vogui_to_fs(&mut fs);
    
    // Compile
    let bytecode = match vo_web::compile_source_with_std_fs(source, &filename, fs) {
        Ok(b) => b,
        Err(e) => return WasmGuiResult::compile_err(e),
    };
    
    // Run
    run_gui_bytecode(&bytecode, vogui::register_externs)
}

/// Initialize a GUI app from pre-compiled bytecode.
#[wasm_bindgen(js_name = "initGuiAppBytecode")]
pub fn init_gui_app_bytecode(bytecode: &[u8]) -> WasmGuiResult {
    run_gui_bytecode(bytecode, vogui::register_externs)
}

/// Handle a GUI event.
#[wasm_bindgen(js_name = "handleGuiEvent")]
pub fn handle_gui_event(handler_id: i32, payload: &str) -> WasmGuiResult {
    handle_event(handler_id, payload)
}

// =============================================================================
// Core Implementation
// =============================================================================

fn run_gui_bytecode(
    bytecode: &[u8],
    registrar: fn(&mut vo_web::ExternRegistry, &[vo_web::ExternDef]),
) -> WasmGuiResult {
    GUI_STATE.with(|s| unsafe { *s.get() = None });
    vogui::clear_pending_handler();
    vogui::clear_pending_render();

    let vm = match vo_web::create_vm(bytecode, registrar) {
        Ok(vm) => vm,
        Err(e) => return WasmGuiResult::err(e),
    };

    // Flush any user println output to console
    let stdout = vo_web::take_output();
    if !stdout.is_empty() {
        for line in stdout.lines() {
            if !line.is_empty() {
                web_sys::console::log_1(&format!("[Vo] {}", line).into());
            }
        }
    }

    // Read render JSON from dedicated channel (not stdout)
    let render_json = vogui::take_pending_render().unwrap_or_default();

    if render_json.is_empty() {
        return WasmGuiResult::err("No render output. emitRender was not called.".to_string());
    }

    let event_handler = match vogui::take_pending_handler() {
        Some(h) => h,
        None => return WasmGuiResult::err("registerEventHandler not called"),
    };

    GUI_STATE.with(|s| unsafe {
        *s.get() = Some(GuiAppState { vm, event_handler });
    });

    WasmGuiResult::ok(render_json)
}

fn handle_event(handler_id: i32, payload: &str) -> WasmGuiResult {
    GUI_STATE.with(|s| {
        // SAFETY: WASM is single-threaded. JS-side busy guard prevents reentrant calls.
        // We use UnsafeCell instead of RefCell because WASM traps don't unwind,
        // which would permanently leak RefCell borrow guards and poison all subsequent calls.
        let state = unsafe { &mut *s.get() };
        let state = match state.as_mut() {
            Some(st) => st,
            None => return WasmGuiResult::err("GUI app not initialized"),
        };

        // Allocate payload string using vo-web API
        let payload_ref = vo_web::alloc_string(&mut state.vm, payload);

        // Call closure using vo-web API
        let args = [handler_id as u64, payload_ref as u64];
        if let Err(e) = vo_web::call_closure(&mut state.vm, state.event_handler, &args) {
            return WasmGuiResult::err(e);
        }

        // Flush any user println output to console
        let stdout = vo_web::take_output();
        if !stdout.is_empty() {
            for line in stdout.lines() {
                if !line.is_empty() {
                    web_sys::console::log_1(&format!("[Vo] {}", line).into());
                }
            }
        }

        // Read render JSON from dedicated channel
        let render_json = vogui::take_pending_render().unwrap_or_default();
        WasmGuiResult::ok(render_json)
    })
}

fn add_vogui_to_fs(fs: &mut MemoryFs) {
    for (vfs_path, bytes) in VOGUI_FILES {
        if let Ok(content) = std::str::from_utf8(bytes) {
            fs.add_file(PathBuf::from(vfs_path), content.to_string());
        }
    }
}

/// Initialize a GUI app that also imports third-party GitHub modules.
///
/// 1. Detects `import "github.com/..."` in source.
/// 2. Fetches Vo source files and pre-compiled .wasm binaries from GitHub.
/// 3. Compiles with stdlib + vogui + mod_fs.
/// 4. Runs as a GUI app with both vogui and ext-bridge extern registrars.
#[wasm_bindgen(js_name = "initGuiAppWithModules")]
pub fn init_gui_app_with_modules(source: &str) -> js_sys::Promise {
    let source = source.to_string();
    wasm_bindgen_futures::future_to_promise(async move {
        let result = init_gui_with_modules_inner(&source).await;
        let obj = js_sys::Object::new();
        js_sys::Reflect::set(&obj, &"status".into(), &result.status.into()).unwrap();
        js_sys::Reflect::set(&obj, &"renderJson".into(), &result.render_json.into()).unwrap();
        js_sys::Reflect::set(&obj, &"error".into(), &result.error.into()).unwrap();
        Ok(obj.into())
    })
}

/// Fetch all GitHub module dependencies declared in `source`:
/// - Downloads Vo source files into a `MemoryFs` for the compiler.
/// - Fetches each module's `.wasm` binary and loads it via the ext bridge.
/// - Returns the populated `MemoryFs` and the version-stripped source.
async fn prepare_github_modules(
    source: &str,
) -> Result<(MemoryFs, String), String> {
    let imports = vo_module::fetch::detect_github_imports(source)?;
    let mut mod_fs = MemoryFs::new();

    for imp in &imports {
        match vo_module::fetch::fetch_module_files(&imp.module, &imp.version).await {
            Ok(files) => {
                for (vfs_path, content) in files {
                    mod_fs.add_file(vfs_path, content);
                }
            }
            Err(e) => return Err(format!("Failed to fetch {}: {}", imp.module, e)),
        }

        match vo_module::fetch::fetch_wasm_binary(&imp.module, &imp.version).await {
            Ok(Some(bytes)) => {
                // Check if a wasm-bindgen JS glue file exists alongside the .wasm
                let js_glue_url = vo_module::fetch::fetch_wasm_js_glue_url(&imp.module, &imp.version)
                    .await
                    .unwrap_or(None)
                    .unwrap_or_default();
                vo_web::ext_bridge::load_wasm_ext_module(&imp.module, &bytes, &js_glue_url).await?;
            }
            Ok(None) => {}
            Err(e) => return Err(format!("Failed to fetch {}.wasm: {}", imp.module, e)),
        }
    }

    let clean_source = vo_module::fetch::strip_module_versions(source);
    Ok((mod_fs, clean_source))
}

async fn init_gui_with_modules_inner(source: &str) -> WasmGuiResult {
    let (mod_fs, clean_source) = match prepare_github_modules(source).await {
        Ok(v) => v,
        Err(e) => return WasmGuiResult::err(e),
    };

    let mut std_fs = vo_web::build_stdlib_fs();
    add_vogui_to_fs(&mut std_fs);

    let bytecode = match vo_web::compile_source_with_mod_fs(&clean_source, "main.vo", std_fs, mod_fs) {
        Ok(b) => b,
        Err(e) => return WasmGuiResult::compile_err(e),
    };

    run_gui_bytecode(&bytecode, register_gui_and_ext_bridges)
}

fn register_gui_and_ext_bridges(reg: &mut vo_web::ExternRegistry, externs: &[vo_web::ExternDef]) {
    vogui::register_externs(reg, externs);
    vo_web::ext_bridge::register_wasm_ext_bridges(reg, externs);
}

// Re-export vo-web functions
pub use vo_web::{compile_and_run, version, RunResult};

/// Compile and run Vo source that imports third-party GitHub modules.
///
/// 1. Detects `import "github.com/..."` in source.
/// 2. Fetches Vo source files from the GitHub archive tarball.
/// 3. Fetches the pre-compiled `<module>.wasm` binary for dynamic loading.
/// 4. Calls `window.voSetupExtModule` so JS can instantiate the WASM.
/// 5. Compiles with the fetched mod_fs, runs with JS-bridge extern registrar.
#[wasm_bindgen(js_name = "compileAndRunWithModules")]
pub fn compile_and_run_with_modules(source: &str) -> js_sys::Promise {
    let source = source.to_string();
    wasm_bindgen_futures::future_to_promise(async move {
        let (status, stdout, stderr) = run_with_modules_inner(&source).await;
        Ok(vo_web::make_run_result_js(&status, &stdout, &stderr))
    })
}

async fn run_with_modules_inner(source: &str) -> (String, String, String) {
    let (mod_fs, clean_source) = match prepare_github_modules(source).await {
        Ok(v) => v,
        Err(e) => return ("error".into(), String::new(), e),
    };

    let std_fs = vo_web::build_stdlib_fs();
    let bytecode = match vo_web::compile_source_with_mod_fs(&clean_source, "main.vo", std_fs, mod_fs) {
        Ok(b) => b,
        Err(e) => return ("compile_error".into(), String::new(), e),
    };

    vo_web::run_bytecode_async_with_externs(
        &bytecode,
        vo_web::ext_bridge::register_wasm_ext_bridges,
    ).await
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_vogui_files_embedded() {
        assert!(VOGUI_FILES.len() > 0, "No .vo files embedded from vogui!");
        let has_app = VOGUI_FILES.iter().any(|(p, _)| *p == "vogui/app.vo");
        assert!(has_app, "vogui/app.vo not embedded");

        let mut fs = vo_common::vfs::MemoryFs::new();
        add_vogui_to_fs(&mut fs);

        use vo_common::vfs::FileSystem;
        assert!(fs.exists(std::path::Path::new("vogui/app.vo")), "vogui/app.vo not in fs");
    }
}

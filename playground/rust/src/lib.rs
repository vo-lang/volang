//! Vo Playground WASM - combines vo-web (system) and vogui (GUI library).

use std::cell::RefCell;
use std::path::PathBuf;
use wasm_bindgen::prelude::*;
use vo_common::vfs::MemoryFs;
use vo_web::{Vm, GcRef};
use js_sys;

// Generated by build.rs: only the .vo source files from libs/vogui/ are embedded.
include!(concat!(env!("OUT_DIR"), "/vogui_files.rs"));

// =============================================================================
// Global State
// =============================================================================

struct GuiAppState {
    vm: Vm,
    event_handler: GcRef,
}

thread_local! {
    static GUI_STATE: RefCell<Option<GuiAppState>> = RefCell::new(None);
}

// =============================================================================
// Result Type
// =============================================================================

#[wasm_bindgen]
pub struct WasmGuiResult {
    status: String,
    render_json: String,
    error: String,
}

#[wasm_bindgen]
impl WasmGuiResult {
    #[wasm_bindgen(getter)]
    pub fn status(&self) -> String { self.status.clone() }
    
    #[wasm_bindgen(getter, js_name = "renderJson")]
    pub fn render_json(&self) -> String { self.render_json.clone() }
    
    #[wasm_bindgen(getter)]
    pub fn error(&self) -> String { self.error.clone() }
}

impl WasmGuiResult {
    fn ok(render_json: String) -> Self {
        Self { status: "ok".into(), render_json, error: String::new() }
    }
    
    fn err(msg: impl Into<String>) -> Self {
        Self { status: "error".into(), render_json: String::new(), error: msg.into() }
    }
    
    fn compile_err(msg: impl Into<String>) -> Self {
        Self { status: "compile_error".into(), render_json: String::new(), error: msg.into() }
    }
}

// =============================================================================
// WASM API
// =============================================================================

/// Initialize a GUI app from source code.
#[wasm_bindgen(js_name = "initGuiApp")]
pub fn init_gui_app(source: &str, filename: Option<String>) -> WasmGuiResult {
    let filename = filename.unwrap_or_else(|| "main.vo".to_string());
    
    // Build combined filesystem: stdlib + vogui package
    let mut fs = vo_web::build_stdlib_fs();
    add_vogui_to_fs(&mut fs);
    
    // Compile
    let bytecode = match vo_web::compile_source_with_std_fs(source, &filename, fs) {
        Ok(b) => b,
        Err(e) => return WasmGuiResult::compile_err(e),
    };
    
    // Run
    init_gui_app_bytecode(&bytecode)
}

/// Initialize a GUI app from pre-compiled bytecode.
#[wasm_bindgen(js_name = "initGuiAppBytecode")]
pub fn init_gui_app_bytecode(bytecode: &[u8]) -> WasmGuiResult {
    run_gui_bytecode(bytecode)
}

/// Handle a GUI event.
#[wasm_bindgen(js_name = "handleGuiEvent")]
pub fn handle_gui_event(handler_id: i32, payload: &str) -> WasmGuiResult {
    handle_event(handler_id, payload)
}

// =============================================================================
// Core Implementation
// =============================================================================

fn run_gui_bytecode(bytecode: &[u8]) -> WasmGuiResult {
    // Clear previous state
    GUI_STATE.with(|s| *s.borrow_mut() = None);
    vogui::clear_pending_handler();
    
    // Create VM using vo-web's generic API
    let vm = match vo_web::create_vm(bytecode, vogui::register_externs) {
        Ok(vm) => vm,
        Err(e) => return WasmGuiResult::err(e),
    };
    
    // Extract render output
    let stdout = vo_web::take_output();
    let render_json = extract_render_json(&stdout);
    
    if render_json.is_empty() {
        return WasmGuiResult::err(format!("No render output. stdout: {}", stdout));
    }
    
    // Get event handler (vogui protocol)
    let event_handler = match vogui::take_pending_handler() {
        Some(h) => h,
        None => return WasmGuiResult::err("registerEventHandler not called"),
    };
    
    // Store state
    GUI_STATE.with(|s| {
        *s.borrow_mut() = Some(GuiAppState { vm, event_handler });
    });
    
    WasmGuiResult::ok(render_json)
}

fn handle_event(handler_id: i32, payload: &str) -> WasmGuiResult {
    GUI_STATE.with(|s| {
        let mut state_ref = s.borrow_mut();
        let state = match state_ref.as_mut() {
            Some(st) => st,
            None => return WasmGuiResult::err("GUI app not initialized"),
        };
        
        // Allocate payload string using vo-web API
        let payload_ref = vo_web::alloc_string(&mut state.vm, payload);
        
        // Call closure using vo-web API
        let args = [handler_id as u64, payload_ref as u64];
        if let Err(e) = vo_web::call_closure(&mut state.vm, state.event_handler, &args) {
            return WasmGuiResult::err(e);
        }
        
        let stdout = vo_web::take_output();
        let render_json = extract_render_json(&stdout);
        
        WasmGuiResult::ok(render_json)
    })
}

fn extract_render_json(stdout: &str) -> String {
    let mut render_json = String::new();
    for line in stdout.lines() {
        if let Some(json) = line.strip_prefix("__VOGUI__") {
            render_json = json.to_string();
        } else if !line.is_empty() {
            web_sys::console::log_1(&format!("[Vo] {}", line).into());
        }
    }
    render_json
}

fn add_vogui_to_fs(fs: &mut MemoryFs) {
    for (vfs_path, bytes) in VOGUI_FILES {
        if let Ok(content) = std::str::from_utf8(bytes) {
            fs.add_file(PathBuf::from(vfs_path), content.to_string());
        }
    }
}

/// Initialize a GUI app that also imports third-party GitHub modules.
///
/// 1. Detects `import "github.com/..."` in source.
/// 2. Fetches Vo source files and pre-compiled .wasm binaries from GitHub.
/// 3. Compiles with stdlib + vogui + mod_fs.
/// 4. Runs as a GUI app with both vogui and ext-bridge extern registrars.
#[wasm_bindgen(js_name = "initGuiAppWithModules")]
pub fn init_gui_app_with_modules(source: &str) -> js_sys::Promise {
    let source = source.to_string();
    wasm_bindgen_futures::future_to_promise(async move {
        let result = init_gui_with_modules_inner(&source).await;
        let obj = js_sys::Object::new();
        js_sys::Reflect::set(&obj, &"status".into(), &result.status.into()).unwrap();
        js_sys::Reflect::set(&obj, &"renderJson".into(), &result.render_json.into()).unwrap();
        js_sys::Reflect::set(&obj, &"error".into(), &result.error.into()).unwrap();
        Ok(obj.into())
    })
}

async fn init_gui_with_modules_inner(source: &str) -> WasmGuiResult {
    let imports = vo_module::fetch::detect_github_imports(source);
    let mut mod_fs = vo_common::vfs::MemoryFs::new();

    for module_path in &imports {
        let version = match playground_module_version(module_path) {
            Some(v) => v,
            None => return WasmGuiResult::err(format!(
                "Unknown module: {}. Not in the playground module registry.", module_path
            )),
        };

        match vo_module::fetch::fetch_module_files(module_path, version).await {
            Ok(files) => {
                for (vfs_path, content) in files {
                    mod_fs.add_file(vfs_path, content);
                }
            }
            Err(e) => return WasmGuiResult::err(format!("Failed to fetch {}: {}", module_path, e)),
        }

        match vo_module::fetch::fetch_wasm_binary(module_path, version).await {
            Ok(Some(bytes)) => {
                let repo = module_path.splitn(4, '/').nth(2).unwrap_or(module_path);
                let promise = js_setup_ext_module(repo, &bytes);
                if let Err(e) = wasm_bindgen_futures::JsFuture::from(promise).await {
                    return WasmGuiResult::err(format!("Failed to setup {}.wasm: {:?}", repo, e));
                }
            }
            Ok(None) => {}
            Err(e) => return WasmGuiResult::err(format!("Failed to fetch {}.wasm: {}", module_path, e)),
        }
    }

    let mut std_fs = vo_web::build_stdlib_fs();
    add_vogui_to_fs(&mut std_fs);

    let bytecode = match vo_web::compile_source_with_mod_fs(source, "main.vo", std_fs, mod_fs) {
        Ok(b) => b,
        Err(e) => return WasmGuiResult::compile_err(e),
    };

    run_gui_bytecode_with_ext(&bytecode)
}

fn run_gui_bytecode_with_ext(bytecode: &[u8]) -> WasmGuiResult {
    GUI_STATE.with(|s| *s.borrow_mut() = None);
    vogui::clear_pending_handler();

    let vm = match vo_web::create_vm(bytecode, register_gui_and_ext_bridges) {
        Ok(vm) => vm,
        Err(e) => return WasmGuiResult::err(e),
    };

    let stdout = vo_web::take_output();
    let render_json = extract_render_json(&stdout);

    if render_json.is_empty() {
        return WasmGuiResult::err(format!("No render output. stdout: {}", stdout));
    }

    let event_handler = match vogui::take_pending_handler() {
        Some(h) => h,
        None => return WasmGuiResult::err("registerEventHandler not called"),
    };

    GUI_STATE.with(|s| {
        *s.borrow_mut() = Some(GuiAppState { vm, event_handler });
    });

    WasmGuiResult::ok(render_json)
}

fn register_gui_and_ext_bridges(reg: &mut vo_web::ExternRegistry, externs: &[vo_web::ExternDef]) {
    vogui::register_externs(reg, externs);
    register_ext_bridges(reg, externs);
}

// Re-export vo-web functions
pub use vo_web::{compile_and_run, version, RunResult};

// ── Module-aware compile and run ──────────────────────────────────────────────

#[wasm_bindgen]
extern "C" {
    /// Called from Rust to set up an extension WASM module.
    /// `bytes` is the raw .wasm binary; `module_name` is e.g. "resvg".
    /// Returns a Promise that resolves when WebAssembly.instantiate completes.
    #[wasm_bindgen(js_namespace = window, js_name = "voSetupExtModule")]
    fn js_setup_ext_module(module_name: &str, bytes: &[u8]) -> js_sys::Promise;

    /// JS bridge: renders SVG string → PNG bytes using the dynamically
    /// loaded resvg.wasm instance.  Returns empty slice on error.
    #[wasm_bindgen(js_namespace = window, js_name = "voExtRender")]
    fn js_ext_render(svg: &str) -> Vec<u8>;
}

/// ExternFn bridge for `github.com/vo-lang/resvg.Render`.
fn resvg_render_bridge(call: &mut vo_web::ExternCallContext) -> vo_web::ExternResult {
    use vo_runtime::builtins::error_helper::{write_error_to, write_nil_error};
    let svg = call.arg_str(0).to_string();
    let png = js_ext_render(&svg);
    if png.is_empty() {
        call.ret_nil(0);
        write_error_to(call, 1, "resvg render failed");
    } else {
        let slice_ref = call.alloc_bytes(&png);
        call.ret_ref(0, slice_ref);
        write_nil_error(call, 1);
    }
    vo_web::ExternResult::Ok
}

/// Register all known extension bridge functions.
/// For each extern in the bytecode whose name matches a known module function,
/// register the corresponding JS bridge.
fn register_ext_bridges(reg: &mut vo_web::ExternRegistry, externs: &[vo_web::ExternDef]) {
    for (id, def) in externs.iter().enumerate() {
        if def.name == "github_com_vo_lang_resvg_Render" {
            reg.register(id as u32, resvg_render_bridge);
        }
    }
}

/// Compile and run Vo source that imports third-party GitHub modules.
///
/// 1. Detects `import "github.com/..."` in source.
/// 2. Fetches Vo source files from the GitHub archive tarball.
/// 3. Fetches the pre-compiled `<module>.wasm` binary for dynamic loading.
/// 4. Calls `window.voSetupExtModule` so JS can instantiate the WASM.
/// 5. Compiles with the fetched mod_fs, runs with JS-bridge extern registrar.
#[wasm_bindgen(js_name = "compileAndRunWithModules")]
pub fn compile_and_run_with_modules(source: &str) -> js_sys::Promise {
    let source = source.to_string();
    wasm_bindgen_futures::future_to_promise(async move {
        let (status, stdout, stderr) = run_with_modules_inner(&source).await;
        Ok(vo_web::make_run_result_js(&status, &stdout, &stderr))
    })
}

async fn run_with_modules_inner(source: &str) -> (String, String, String) {
    let imports = vo_module::fetch::detect_github_imports(source);

    let mut mod_fs = vo_common::vfs::MemoryFs::new();
    for module_path in &imports {
        let version = match playground_module_version(module_path) {
            Some(v) => v,
            None => return (
                "error".into(),
                String::new(),
                format!("Unknown module: {}. Not in the playground module registry.", module_path),
            ),
        };

        // Fetch Vo source files
        match vo_module::fetch::fetch_module_files(module_path, version).await {
            Ok(files) => {
                for (vfs_path, content) in files {
                    mod_fs.add_file(vfs_path, content);
                }
            }
            Err(e) => return ("error".into(), String::new(), format!("Failed to fetch {}: {}", module_path, e)),
        }

        // Fetch pre-compiled .wasm binary and hand it to JS for instantiation
        match vo_module::fetch::fetch_wasm_binary(module_path, version).await {
            Ok(Some(bytes)) => {
                let repo = module_path.splitn(4, '/').nth(2).unwrap_or(module_path);
                let promise = js_setup_ext_module(repo, &bytes);
                if let Err(e) = wasm_bindgen_futures::JsFuture::from(promise).await {
                    return ("error".into(), String::new(),
                        format!("Failed to setup {}.wasm: {:?}", repo, e));
                }
            }
            Ok(None) => {} // no .wasm in repo — bridge calls will fail at runtime
            Err(e) => return ("error".into(), String::new(), format!("Failed to fetch {}.wasm: {}", module_path, e)),
        }
    }

    let std_fs = vo_web::build_stdlib_fs();
    let bytecode = match vo_web::compile_source_with_mod_fs(source, "main.vo", std_fs, mod_fs) {
        Ok(b) => b,
        Err(e) => return ("compile_error".into(), String::new(), e),
    };

    vo_web::run_bytecode_async_with_externs(&bytecode, register_ext_bridges).await
}

/// Version registry for modules known to the playground.
fn playground_module_version(module: &str) -> Option<&'static str> {
    match module {
        "github.com/vo-lang/resvg" => Some("v0.1.0"),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_vogui_files_embedded() {
        assert!(VOGUI_FILES.len() > 0, "No .vo files embedded from vogui!");
        let has_app = VOGUI_FILES.iter().any(|(p, _)| *p == "vogui/app.vo");
        assert!(has_app, "vogui/app.vo not embedded");

        let mut fs = vo_common::vfs::MemoryFs::new();
        add_vogui_to_fs(&mut fs);

        use vo_common::vfs::FileSystem;
        assert!(fs.exists(std::path::Path::new("vogui/app.vo")), "vogui/app.vo not in fs");
    }
}
